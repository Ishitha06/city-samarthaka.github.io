<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pratiksha Chougule — Contributions</title>

  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="p.css">
  <script src="p.js" defer></script>
</head>
<body>
  <div class="page-wrapper">

    <header class="page-head">
      <div class="brand">SAMARTHAKA — Smart City Modules (Pratiksha)</div>
      <nav class="mini-nav">
        <a class="back-btn" href="../index.html#team">← Back to Team</a>
      </nav>
    </header>

    <section class="hero">
      <h1>Smart City — Data Structures & Algorithms Modules</h1>
      <p class="lead">Commercial, Healthcare, Education and Solar — complete subsystems, algorithms, datasets and efficiency analysis.</p>
    </section>

    <section class="mindmap">
      <img src="assets/smart_city_ds_mindmap.png" alt="Smart City Data Structures Mindmap" />
      <p class="caption">Mindmap: module relationships, DS & algorithm choices, and SDG alignment.</p>
    </section>

    <section id="commercial" class="module">
      <div class="module-head">
        <h2>Commercial Services Management System</h2>
        <p class="module-lead">Centralized licensing, hospitality, retail, digital marketplace, mobility-linked commerce and revenue analytics for a 2.6M city.</p>
      </div>

      <div class="module-content">

        <div class="module-left">

          <article class="subpoint">
            <h3>Digital Business Licensing — Hash Table <span class="sdg">SDG 9</span></h3>
            <p class="problem"><strong>Problem:</strong> Permit lookups and updates must be instant during peak intake; paper-processes are slow and error-prone.</p>
            <p class="why"><strong>Why Hash:</strong> O(1) average lookup for ID-based retrievals; simple key-based updates and compact mapping for permit IDs.</p>
            <p class="how"><strong>How it solves:</strong> A hash-table registry stores permit meta (owner, type, expiry, status). During intake and renewals the system does direct key lookup. Collision resolution via chaining keeps worst-case rare for urban-sized datasets; periodic rehash keeps load low. For audit trails, append-only logs reference hash keys so lookups remain O(1) even when producing historical reports.</p>
             </article>

          <article class="subpoint">
            <h3>Smart Ticketing & Events — Queue (FIFO) <span class="sdg">SDG 11</span></h3>
            <p class="problem"><strong>Problem:</strong> Event admission flow must be fair, fast, and support re-entry and validation rules.</p>
            <p class="why"><strong>Why Queue:</strong> FIFO ticket issuance and validation matches real-world admission flows; simple integration with scans and validators.</p>
            <p class="how"><strong>How it solves:</strong> Tickets are enqueued; validation pops from front. Parallel worker threads validate in batches and analytics track queue backlog for dynamic opening of additional gates. Queue integrates with hashing for ticket lookup and with analytics for load prediction.</p>
            <img class="subimage" src="assets/smart_ticketing_gate.jpg" alt="Smart Event Ticketing Gate">
          </article>

          <article class="subpoint">
            <h3>Priority Vendor Approvals — Max-Heap <span class="sdg">SDG 8</span></h3>
            <p class="problem"><strong>Problem:</strong> Critical vendors (healthcare, transport) need fast approvals rather than FIFO processing.</p>
            <p class="why"><strong>Why Max-Heap:</strong> Gives fast extraction of highest-priority items; insertion/pop are O(log n).</p>
            <p class="how"><strong>How it solves:</strong> Each vendor application is given a composite priority (impact score, urgency, risk). The heap pops the highest priority for fast review. Lower-priority items wait in queue. Heap combined with bucketing avoids starvation (periodic promotions of queued items).</p>
            </article>

          <article class="subpoint">
            <h3>Revenue Ranking & Analytics — AVL Tree<span class="sdg">SDG 9</span></h3>
            <p class="problem"><strong>Problem:</strong> Top-k revenue reports and sorted queries are frequent; scanning unsorted lists is too slow.</p>
            <p class="why"><strong>Why AVL:</strong> Balanced BST gives O(log n) update and O(k + log n) top-k extraction when maintaining subtree sizes.</p>
            <p class="how"><strong>How it solves:</strong> Store (revenue, id) pairs in an AVL tree sorted by revenue. On updates (new sale) do an O(log n) update; extract top-k by walking down the tree using stored subtree sizes. For extremely large data, offload to sorted indexes or B-trees for disk-based storage.</p>
            <img class="subimage" src="assets/revenue_ranking_dashboard.jpg" alt="City Revenue Analytics">
          </article>
          
          <article class="subpoint">
              <h3>Fraud Detection Engine — Hash Maps + Pattern Matching <span class="sdg">SDG 8, 16</span></h3>
              <p class="problem"><strong>Problem:</strong> Digital marketplaces are vulnerable to fraudulent transactions (e.g., identity theft, abnormal returns) leading to financial losses.</p>
              <p class="why"><strong>Why Hashing + Pattern Matching:</strong> **Hash Maps** provide O(1) lookups for blacklisted IDs. **Pattern Matching (KMP/Rabin-Karp)** efficiently analyzes transaction sequences/strings for abnormal patterns.</p>
              <p class="how"><strong>How it solves:</strong> Transaction strings/data are hashed and compared to known fraud patterns using **Rabin-Karp** for fast similarity checks. **Hash Maps** store user risk scores for instant verification. This reduces losses (Business) and protects small vendors (Welfare).</p>
              </article>

          <article class="subpoint">
              <h3>Dynamic Pricing System — Max-Heap + AVL Tree <span class="sdg">SDG 9, 11</span></h3>
              <p class="problem"><strong>Problem:</strong> Static pricing misses out on revenue maximization during peak demand and fails to reduce congestion.</p>
              <p class="why"><strong>Why Max-Heap + AVL:</strong> **AVL Tree** manages the inventory/service list ($O(\log n)$ updates). **Max-Heap** prioritizes the item with the highest immediate demand score ($O(\log n)$ extraction) for instant price adjustment.</p>
              <p class="how"><strong>How it solves:</strong> Products/Services are ranked by urgency/demand in a **Max-Heap**. The system extracts the top item to calculate a new optimal price, maximizing vendor profit. It can also steer traffic (e.g., lower parking prices in outer zones) for sustainability.</p>
              <img class="subimage" src="assets/commercial_dynamic_pricing.jpg" alt="Dynamic Pricing System Interface" />
          </article>

          <article class="subpoint">
            <h3>Hotels, Shopping Malls & Retail Indexing — Hash + AVL <span class="sdg">SDG 8</span></h3>
            <p class="problem"><strong>Problem:</strong> Need instant lookup (hotel id) and ranked queries for top hotels/shops.</p>
            <p class="why"><strong>Why Hash + AVL:</strong> Hash for instant id lookup; AVL for revenue-sorted lists and top-k analytics.</p>
            <p class="how"><strong>How it solves:</strong> Maintain a hash map for id→record for CRUD. Maintain an AVL index for revenue and occupancy readouts. For inventory indexes, maintain secondary hash maps by category with AVL top-sellers.</p>
            </article>

          <article class="subpoint">
            <h3>Restaurants & Food Delivery — Hash + Max-Heap + Queue <span class="sdg">SDG 12</span></h3>
            <p class="problem"><strong>Problem:</strong> Peak-time surges and urgent deliveries cause mis-prioritisation.</p>
            <p class="why"><strong>Why:</strong> Hash for restaurant lookup, max-heap for urgent deliveries, FIFO queue for normal orders.</p>
            <p class="how"><strong>How it solves:</strong> Orders get a composite score (urgency, distance, prep-time). Urgent orders go into heap; normal ones into queue. Drivers are assigned by popping heap first then queue. Metrics are recorded for SLA analytics.</p>
            </article>

          <article class="subpoint">
            <h3>Digital Marketplace & E-services — Hashing + AVL <span class="sdg">SDG 9,12</span></h3>
            <p class="problem"><strong>Problem:</strong> Fast vendor search and best-seller extraction across categories.</p>
            <p class="why"><strong>Why:</strong> Hash for vendor lookup by id; AVL for sorted best-seller lists & top-k queries.</p>
            <p class="how"><strong>How it solves:</strong> Vendor entries stored in multiple indices: primary hash by id, secondary AVL trees by revenue and rating. Faceted search uses precomputed hash buckets by category for ultra-fast search.</p>
             </article>

          <h4 class="eff-heading">Efficiency Analysis (Commercial)</h4>
          <table class="eff-table">
            <thead><tr><th>Structure / Operation</th><th>Insert</th><th>Search</th><th>Update</th><th>Space</th></tr></thead>
            <tbody>
              <tr><td>Hash Table</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr>
              <tr><td>AVL Tree</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td></tr>
              <tr><td>Heap (priority)</td><td>O(log n)</td><td>O(n)</td><td>O(log n)</td><td>O(n)</td></tr>
              <tr><td>Queue</td><td>O(1)</td><td>O(n)</td><td>O(1)</td><td>O(n)</td></tr>
              <tr><td>Rabin-Karp (Pattern Match)</td><td>O(m) (Pre-processing)</td><td>O(n+m) (Avg.)</td><td>-</td><td>O(m)</td></tr>
            </tbody>
          </table>

          <div class="actions">
            <button class="btn code-btn" data-module="commercial">View C++ Code</button>
            <a class="btn ghost" target="_blank" href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/pratiksha/datasets/commercial_dataset.csv">Show dataset</a>
          </div>

        </div>

        <aside class="module-right">
          <div class="side-box">
            <h4>All commercial services (combined)</h4>
            <ul>
              <li>Digital Business Licensing</li>
              <li>Smart ticketing & event permits</li>
              <li>Priority vendor approvals</li>
              <li>Tourism navigation & kiosks</li>
              <li>Revenue analytics & ranking</li>
              <li>Hotels, shopping malls & retail indexes</li>
              <li>Restaurants & food delivery pipelines</li>
              <li>Digital marketplace & e-services</li>
              <li>Transport-related commerce (parking, smartcards)</li>
              <li>Advertising & loyalty engines</li>
              <li>Hyper-local manufacturing hubs</li>
              <li>**Fraud Detection Engine**</li>
              <li>**Dynamic Pricing System**</li>
            </ul>
          </div>

          <div class="side-box">
            <h4>Notes (for implementation)</h4>
            <p>Use sharded hashmaps for scale, caching for hot lookups, and periodic rebalancing of AVL indices. Combine streaming analytics for real-time dashboards.</p>
          </div>
        </aside>

      </div>
    </section>

    <section id="healthcare" class="module">
      <div class="module-head">
        <h2>Healthcare Management System</h2>
        <p class="module-lead">Patient lookup, triage, ambulance routing, facility indexing and predictive maintenance for medical infrastructure.</p>
      </div>

      <div class="module-content">
        <div class="module-left">

          <article class="subpoint">
            <h3>Patient Records — Hash Table <span class="sdg">SDG 3</span></h3>
            <p class="problem"><strong>Problem:</strong> Rapid access to patient records during emergencies and high concurrency.</p>
            <p class="why"><strong>Why Hash:</strong> Fast O(1) id-based lookups; simple mapping from patient id to secure record.</p>
            <p class="how"><strong>How it solves:</strong> Encrypted patient IDs hashed to securely locate medical history. Caching recent records reduces latency. For long-term analytics, export snapshots to sorted indices for trend queries.</p>
            </article>

          <article class="subpoint">
            <h3>Triage Queue — Max-Heap <span class="sdg">SDG 3</span></h3>
            <p class="problem"><strong>Problem:</strong> Emergency severity varies; must quickly identify most critical patients.</p>
            <p class="why"><strong>Why Heap:</strong> Priority queue allows O(log n) insertion and extraction of highest-severity cases.</p>
            <p class="how"><strong>How it solves:</strong> Severity computed from vitals & urgency; heap pops top cases for immediate attention. Non-critical patients remain in FIFO queue for standard processing. Periodic re-ranking ensures changing vitals are reflected.</p>
            <img class="subimage" src="assets/triage_emergency_room.jpg" alt="Emergency Triage Process" />
            </article>

          <article class="subpoint">
            <h3>Ambulance Routing — Dijkstra <span class="sdg">SDG 11</span></h3>
            <p class="problem"><strong>Problem:</strong> Ambulance routing must pick shortest/fastest safe path considering live traffic & closures.</p>
            <p class="why"><strong>Why Dijkstra:</strong> Computes shortest weighted path (time) with O(E + V log V) using a priority queue.</p>
            <p class="how"><strong>How it solves:</strong> Model city roads as graph; edge weights are time estimates (live). Run Dijkstra from ambulance to patient, then to hospital. Use precomputed highway overlays for speed and incremental replan on live updates.</p>
           </article>
           
          <article class="subpoint">
              <h3>Medicine Inventory Prediction — Queues + Time-Series Arrays <span class="sdg">SDG 3</span></h3>
              <p class="problem"><strong>Problem:</strong> Unpredictable demand leads to shortages of critical medicines or wasted expired stock.</p>
              <p class="why"><strong>Why Queues + Arrays:</strong> **Queues** model FIFO demand flow for recent usage. Historical demand is stored in **Arrays** to allow time-series analysis for forecasting.</p>
              <p class="how"><strong>How it solves:</strong> Hospital stock movements are recorded in a **Queue** (Sliding Window). Time-series models use historical **Array** data to predict future consumption, allowing proactive purchasing to prevent critical shortages (Welfare) and minimize waste (Business).</p>
              <img class="subimage" src="assets/healthcare_inventory_prediction.jpg" alt="Medicine Inventory System" />
          </article>

          <article class="subpoint">
              <h3>Doctor–Patient Matching — Bipartite Graph Matching (DFS/BFS) <span class="sdg">SDG 3</span></h3>
              <p class="problem"><strong>Problem:</strong> Patients often wait too long to see the most appropriate specialist, leading to delayed treatment.</p>
              <p class="why"><strong>Why Bipartite Graph (DFS/BFS):</strong> Bipartite matching finds the optimal one-to-one assignment between two sets (Doctors and Patients). Algorithms using **DFS/BFS** find augmenting paths for maximum matching efficiently.</p>
              <p class="how"><strong>How it solves:</strong> A Bipartite Graph connects Doctors (specialties) to Patients (needs). **DFS** or **BFS** is used to find the maximum number of matches, ensuring patients see the most qualified doctor instantly (Welfare), which improves clinic efficiency (Business).</p>
              <img class="subimage" src="assets/healthcare_doctor_patient_matching.jpg" alt="Bipartite Graph Matching" />
          </article>

          <article class="subpoint">
            <h3>Facility Indexing & Scheduling — AVL / Hash <span class="sdg">SDG 3</span></h3>
            <p class="problem"><strong>Problem:</strong> Finding available facility slots (OR rooms, beds) under changing availability.</p>
            <p class="why"><strong>Why AVL+Hash:</strong> Hash maps for direct facility id lookup; AVL for sorted availability windows and top-capacity queries.</p>
            <p class="how"><strong>How it solves:</strong> Facilities stored in map; queries for the nearest available facility use BFS on road graph combined with AVL index of available beds sorted by expected availability time.</p>
             </article>

          <h4 class="eff-heading">Efficiency Analysis (Healthcare)</h4>
          <table class="eff-table">
            <thead><tr><th>Structure / Operation</th><th>Insert</th><th>Search</th><th>Update</th><th>Space</th></tr></thead>
            <tbody>
              <tr><td>Hash Table</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr>
              <tr><td>Heap (priority)</td><td>O(log n)</td><td>O(n)</td><td>O(log n)</td><td>O(n)</td></tr>
              <tr><td>Graph (Dijkstra)</td><td>O(1)</td><td>O(E + V log V)</td><td>O(1)</td><td>O(V+E)</td></tr>
              <tr><td>AVL Tree</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td></tr>
              <tr><td>Bipartite Matching (DFS/BFS)</td><td>O(1) (Edge Add)</td><td>O(V+E)</td><td>O(1)</td><td>O(V+E)</td></tr>
              <tr><td>Queue/Array (Time-Series)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr>
            </tbody>
          </table>

          <div class="actions">
            <button class="btn code-btn" data-module="healthcare">View C++ Code</button>
            <a class="btn ghost" target="_blank" href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/pratiksha/datasets/healthcare_dataset.csv">Show dataset</a>
          </div>

        </div>

        <aside class="module-right">
          <div class="side-box">
            <h4>Implementation notes</h4>
            <p>Encrypt patient ids at rest. Maintain audit logs. Use ephemeral caches for recent emergency zones to reduce lookup times during peak incidents.</p>
          </div>
        </aside>
      </div>
    </section>

    <section id="education" class="module">
      <div class="module-head">
        <h2>Education System</h2>
        <p class="module-lead">Student indexing, scholarships ranking, resource allocation, timetable scheduling and personalized learning analytics.</p>
      </div>

      <div class="module-content">
        <div class="module-left">

          <article class="subpoint">
            <h3>Student Records — Hash Table <span class="sdg">SDG 4</span></h3>
            <p class="problem"><strong>Problem:</strong> Fast enrollment checks and student lookups at scale.</p>
            <p class="why"><strong>Why Hash:</strong> O(1) id-based access for student records and performance metrics.</p>
            <p class="how"><strong>How it solves:</strong> Maintain a student registry keyed by id. Use stable snapshots for semester reports; combine with caches for hot queries (recent check-ins).</p>
            </article>

          <article class="subpoint">
            <h3>Scholarship Ranking — AVL Tree <span class="sdg">SDG 4</span></h3>
            <p class="problem"><strong>Problem:</strong> Frequent top-k extraction for scholarship awards and leaderboards.</p>
            <p class="why"><strong>Why AVL:</strong> Balanced tree keeps scores sorted with O(log n) updates, ideal for frequent top-k queries.</p>
            <p class="how"><strong>How it solves:</strong> Insert student (score, id) into AVL. For top-k, traverse in descending order using subtree sizes. Perform periodic batch updates when many scores change.</p>
            <img class="subimage" src="assets/scholarship_ranking_board.jpg" alt="Scholarship Ranking">
          </article>

          <article class="subpoint">
            <h3>Timetable Scheduling — Graph Coloring <span class="sdg">SDG 4</span></h3>
            <p class="problem"><strong>Problem:</strong> Avoid teacher/room conflicts and optimize allocation.</p>
            <p class="why"><strong>Why Coloring:</strong> Model conflicts as graph edges; color classes are time slots ensuring no adjacent conflicts.</p>
            <p class="how"><strong>How it solves:</strong> Build conflict graph (class nodes, edges where teacher/room overlap). Apply greedy coloring heuristics (syllabus-friendly) to produce conflict-free timetables. Use local search or simulated annealing for further optimization if needed.</p>
            </article>
          
          <article class="subpoint">
              <h3>Smart Scholarship Allocation System — Max-Heap + Hash Map <span class="sdg">SDG 4</span></h3>
              <p class="problem"><strong>Problem:</strong> Manual application review is slow and inconsistent, risking aid going to the wrong students.</p>
              <p class="why"><strong>Why Max-Heap + Hash:</strong> **Max-Heap** ranks composite priority (Need + Merit) for fast allocation ($O(\log n)$). **Hash Map** stores full student profiles for instant ($O(1)$) lookups during final verification.</p>
              <p class="how"><strong>How it solves:</strong> Applications are placed in a **Max-Heap** by score. Reviewers pop the top candidate, instantly retrieving the full record from the **Hash Map**, ensuring fairness (Welfare) and reducing administrative costs (Business).</p>
          </article>
          
          <article class="subpoint">
              <h3>Adaptive Learning Path Generator — Graphs + DFS <span class="sdg">SDG 4</span></h3>
              <p class="problem"><strong>Problem:</strong> Generic curricula lead to student frustration and high dropout rates due to knowledge gaps.</p>
              <p class="why"><strong>Why Graph + DFS:</strong> **Graphs** model topic prerequisites. **DFS** (Depth First Search) traverses this graph to generate a sequential path, ensuring students master foundational topics first.</p>
              <p class="how"><strong>How it solves:</strong> Topics are **Graph** nodes; prerequisites are directed edges. **DFS** is used to check that all necessary prerequisites are met before recommending a topic, providing a custom sequence that increases pass rates (Welfare) and creates a valuable EdTech product (Business).</p>
              <img class="subimage" src="assets/adaptive_learning_path.jpg" alt="Personalized Learning Path" />
          </article>
          
          <article class="subpoint">
              <h3>Teacher Workload Optimization — Min-Heap + Greedy Scheduling <span class="sdg">SDG 4</span></h3>
              <p class="problem"><strong>Problem:</strong> Uneven workload distribution leads to teacher burnout and inconsistent teaching quality.</p>
              <p class="why"><strong>Why Min-Heap + Greedy:</strong> A **Min-Heap** maintains the list of teachers prioritized by the lowest current workload. The **Greedy Algorithm** makes the optimal scheduling choice at each step.</p>
              <p class="how"><strong>How it solves:</strong> New sessions are allocated by the **Greedy Scheduler** to the teacher with the current minimum workload (extracted from the heap in $O(\log n)$). This balances assignments, reducing burnout (Welfare) and optimizing school staff utilization (Business).</p>
              </article>
          
          <article class="subpoint">
              <h3>Real-Time Classroom Monitoring Analytics — Sliding Window (Queues) <span class="sdg">SDG 4</span></h3>
              <p class="problem"><strong>Problem:</strong> Detecting real-time issues like overcrowding or sudden performance drops is difficult with batch processing.</p>
              <p class="why"><strong>Why Sliding Window (Queues):** A **Sliding Window** (implemented with two **Queues** or **Arrays**) efficiently tracks metrics over a fixed, recent time frame without recalculating the entire stream ($O(1)$ update).</p>
              <p class="how">**How it solves:** Metrics (e.g., login times, activity rates) are fed into the **Sliding Window**. The system compares the current window's average against a baseline to detect anomalies, allowing for instant alerts on potential issues like overcrowding or disengagement (Welfare/Business).</p>
              </article>
          
          <article class="subpoint">
              <h3>Exam Generation + Plagiarism Detection — Graphs + Hashing <span class="sdg">SDG 4, 16</span></h3>
              <p class="problem"><strong>Problem:</strong> Ensuring comprehensive syllabus coverage and quickly detecting similar or copied answers.</p>
              <p class="why"><strong>Why Hashing + Graph:** **Hashing** (**Rabin-Karp**) is fast for text similarity detection. **Graph Algorithms** (Connectivity via DFS/BFS) ensure syllabus coverage in generated papers.</p>
              <p class="how">**How it solves:** **Graph Algorithms** (DFS/BFS on a Topic Graph) ensure question sets cover all prerequisite topic clusters. **Rabin-Karp Hashing** checks for matching hash sequences across all submissions ($O(N+M)$ average time), flagging cheating instantly (Welfare) and reducing manual evaluation (Business).</p>
              </article>

          <article class="subpoint">
              <h3>Career Recommendation Engine — Decision Trees + AVL Trees <span class="sdg">SDG 4, 8</span></h3>
              <p class="problem"><strong>Problem:</strong> Students lack guidance on career paths aligned with their skills and market demand.</p>
              <p class="why"><strong>Why Decision Trees + AVL Trees:** **Decision Trees** categorize student profiles. **AVL Trees** rank the best job matches within those categories based on market salary/demand ($O(\log n)$ query/ranking).</p>
              <p class="how">**How it solves:** Student skill data traverses the **Decision Tree** for category placement. Job market data (salary, demand) is stored in an **AVL Tree** for fast extraction of the top $K$ best-matched jobs, guiding students to better opportunities (Welfare/Business).</p>
              </article>

          <h4 class="eff-heading">Efficiency Analysis (Education)</h4>
          <table class="eff-table">
            <thead><tr><th>Structure / Operation</th><th>Insert</th><th>Search</th><th>Update</th><th>Space</th></tr></thead>
            <tbody>
              <tr><td>Hash Table</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr>
              <tr><td>AVL Tree</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td></tr>
              <tr><td>Heap (priority)</td><td>O(log n)</td><td>O(n)</td><td>O(log n)</td><td>O(n)</td></tr>
              <tr><td>Graph (DFS)</td><td>O(1)</td><td>O(V+E)</td><td>-</td><td>O(V+E)</td></tr>
              <tr><td>Rabin-Karp (Pattern Match)</td><td>O(m)</td><td>O(N+M) (Avg.)</td><td>-</td><td>O(m)</td></tr>
              <tr><td>Sliding Window (Queue/Array)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr>
            </tbody>
          </table>

          <div class="actions">
            <button class="btn code-btn" data-module="education">View C++ Code</button>
            <a class="btn ghost" target="_blank" href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/pratiksha/datasets/education_dataset.csv">Show dataset</a>
          </div>

        </div>

        <aside class="module-right">
          <div class="side-box">
            <h4>Notes</h4>
            <p>Maintain yearly snapshots, anonymize student data for public analytics, and use caches for hot records (attendance/exam day).</p>
          </div>
        </aside>
      </div>
    </section>

    <section id="solar" class="module">
      <div class="module-head">
        <h2>Solar Energy Management System</h2>
        <p class="module-lead">Panel indexing, predictive maintenance, backup allocation and routing for service teams.</p>
      </div>

      <div class="module-content">
        <div class="module-left">

          <article class="subpoint">
            <h3>Panel Lookup — Hash Table <span class="sdg">SDG 7</span></h3>
            <p class="problem"><strong>Problem:</strong> Need instant retrieval of panel metadata for monitoring and repairs.</p>
            <p class="why"><strong>Why Hash:</strong> O(1) access to panel by id for quick reads/writes to status and telemetry.</p>
            <p class="how"><strong>How it solves:</strong> Each panel has an id mapped in a hash table to its meta+telemetry. Quick lookups support dashboards and alert routing. Combined with time-series DB for historic analytics.</p>
            <img class="subimage" src="assets/solar_panel_array.jpg" alt="Large Solar Panel Array">
          </article>

          <article class="subpoint">
            <h3>Backup Allocation — Max-Heap <span class="sdg">SDG 7</span></h3>
            <p class="problem"><strong>Problem:</strong> Limited battery backups must be allocated to critical zones fast.</p>
            <p class="why"><strong>Why Heap:</strong> Max-heap efficiently selects highest-priority zones by urgency/criticality score.</p>
            <p class="how"><strong>How it solves:</strong> Compute a priority for each backup request; pop the highest-priority to allocate battery. Reinsert when usage finishes. Heap ensures O(log n) fairness and speed.</p>
            </article>

          <article class="subpoint">
            <h3>Maintenance Routing — Dijkstra <span class="sdg">SDG 11</span></h3>
            <p class="problem"><strong>Problem:</strong> Route teams must take shortest safe path when multiple faults arise.</p>
            <p class="why"><strong>Why Dijkstra:</strong> Shortest path on weighted graphs minimizes travel time considering traffic or road closures.</p>
            <p class="how"><strong>How it solves:</strong> Graph nodes = panels/locations. Dijkstra finds quickest maintenance route for each crew, aggregated for multi-stop tours. Use heuristics to batch repairs for efficiency.</p>
            <img class="subimage" src="assets/maintenance_routing_map.jpg" alt="Maintenance Routing on Digital Map">
          </article>
          
          <article class="subpoint">
              <h3>Fault Prediction Engine — Decision Trees + AVL Trees <span class="sdg">SDG 7</span></h3>
              <p class="problem"><strong>Problem:</strong> Unanticipated panel failure causes energy loss and expensive reactive maintenance.</p>
              <p class="why"><strong>Why Decision Trees + AVL Trees:</strong> **Decision Trees** classify panel health data (temp, output) to predict failure. **AVL Trees** efficiently store and rank panels by their current risk score for $O(\log n)$ updates and ranking.</p>
              <p class="how"><strong>How it solves:</strong> Sensor data runs through a pre-trained **Decision Tree** model which outputs a risk score. This score is inserted into the **AVL Tree**, which maintains the panels ranked by risk. Technicians service the top $K$ riskiest panels proactively, reducing downtime (Welfare) and optimizing maintenance scheduling (Business).</p>
              </article>

          <article class="subpoint">
              <h3>Energy Trading Marketplace — Hash Tables + Ledgers <span class="sdg">SDG 7, 11</span></h3>
              <p class="problem"><strong>Problem:</strong> Excess solar energy often goes unutilized; no direct peer-to-peer trading mechanism exists.</p>
              <p class="why"><strong>Why Hash Tables:</strong> **Hash Tables** provide $O(1)$ instant lookups for user accounts and live balance updates, crucial for high-frequency trading ledgers.</p>
              <p class="how"><strong>How it solves:</strong> A digital ledger tracks energy credits. **Hash Tables** store user accounts and balances, facilitating near-instantaneous, secure debits and credits when energy is bought/sold. The marketplace generates profit through transaction fees while incentivizing citizens to generate solar power (Welfare/Sustainability).</p>
              </article>

          <h4 class="eff-heading">Efficiency Analysis (Solar)</h4>
          <table class="eff-table">
            <thead><tr><th>Structure / Operation</th><th>Insert</th><th>Search</th><th>Update</th><th>Space</th></tr></thead>
            <tbody>
              <tr><td>Hash Table</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr>
              <tr><td>AVL Tree (Risk Ranking)</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td></tr>
              <tr><td>Heap</td><td>O(log n)</td><td>O(n)</td><td>O(log n)</td><td>O(n)</td></tr>
              <tr><td>Graph (Dijkstra)</td><td>O(1)</td><td>O(E + V log V)</td><td>O(1)</td><td>O(V+E)</td></tr>
              <tr><td>Decision Tree (Classification)</td><td>O(1) (Query)</td><td>O(Tree Height)</td><td>-</td><td>O(n)</td></tr>
            </tbody>
          </table>

          <div class="actions">
            <button class="btn code-btn" data-module="solar">View C++ Code</button>
            <a class="btn ghost" target="_blank" href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/pratiksha/datasets/solar_dataset.csv">Show dataset</a>
          </div>

        </div>

        <aside class="module-right">
          <div class="side-box">
            <h4>Tips</h4>
            <p>Use rolling averages for sensor smoothing. Cache frequent routes. Create emergency backup policies for critical zones.</p>
          </div>
        </aside>
      </div>
    </section>

    <footer class="site-footer">
      <div class="footer-inner">
        <div>Samarthaka — Design & Analysis of Algorithms | 24ECSC205</div>
        <div>&copy; Project Team</div>
      </div>
    </footer>
  </div>

  <div id="modalBackdrop" class="modal-back hidden">
    <div class="modal">
      <button id="closeModal" class="close-btn">✕</button>
      <h3 id="modalTitle">C++ — sample</h3>
      <pre id="modalCode" class="code-block" tabindex="0" aria-live="polite"></pre>
    </div>
  </div>

</body>
</html>
