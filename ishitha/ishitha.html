<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ishitha – Contributions</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="ishi.css"> <!-- your updated css file -->
    
</head>

<body>

    <div class="page-wrapper">

        <h1 class="page-title">ISHITHA S</h1>
        <p class="subtitle">Detailed Contribution Breakdown</p>

        <h2 class="section-heading">Infrastructure</h2>

        <div class="content-box-container">

            <div class="content-box">
            <h3>Automated power grid monitoring & control</h3>
            <div class="rule"></div>

            <p>An automated power grid monitoring and control system is a smart infrastructure solution that continuously observes the flow of electricity across the grid and takes automatic actions to maintain stability. It uses sensors, communication networks, and intelligent algorithms to detect faults, balance loads, and optimize energy distribution. Instead of relying on manual checks, the system responds instantly to changes in voltage, current, frequency, or equipment health. <br></p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>Primary: 7 (7.1,7.2,7.3) <br> Secondary: 9,11,13</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>
            <br>
            <br>
            <img src="Infrastructure/powerGrid-flow.png" class="sequence">

            <p><b>Power Source Selection:</b> To dynamically select the most efficient or cost-effective power source available. This could be the Solar Plant during a sunny day, or a traditional power plant when demand is high. <br> <br>

            <b>The Algorithm:</b> A <b>Max-Heap</b> data structure is used to maintain a prioritized list of available power sources. The source at the "top" of the heap is always the best current option, allowing for instant selection.</p>
            <br>

            <div class="image-box">

              <img src="Infrastructure/max-heap.png" class="image">

               <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>
    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Deletion (Extract-Max)</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Updating Priority</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Retrieving Max</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
  </table>
               </div>


            </div>


            <br>


            <br>
            <br>
             <p><b>Building the Distribution Network:</b>To design the physical network of power lines that connects all sectors of Samarthaka (Residential, IT Hub, etc.) with the minimum total length of cable, reducing cost and material usage. <br> <br>

            <b>The Algorithm:</b> <b>Kruskal’s Minimum Spanning Tree (MST)</b> algorithm is used to determine the most efficient set of connections (edges) between all key locations (nodes), ensuring every sector is connected without creating any redundant loops.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/kruskal.png" class="image">

             <div class="efficiency-box">

  <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Sorting Edges</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>

    <tr>
      <td>Union–Find Operations</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>
  </table>

  


             </div>
             


            </div>


            <br>


            <br>
            <br>
             <p><b>Power Flow Routing:</b>To determine the best path for electricity to travel from a selected source to a specific destination (e.g., from the Solar Plant to the Hospital) to minimize power loss.<br> <br>

            <b>The Algorithm:</b> <b>Dijkstra’s Shortest Path </b>algorithm calculates the path with the lowest total resistance or cost through the network. This ensures sensitive zones receive stable power and overall transmission losses are kept to a minimum.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/Dijkstra.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Extract-Min Operations</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
    </tr>

    <tr>
      <td>Decrease-Key Operations</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
    </tr>
  </table>




             </div>


            </div>

            <br>

            <br>
            <br>
             <p><b>Real-time Monitoring:</b>To monitor the total power consumption of a specific area, like a residential block, in real-time and efficiently handle updates from individual smart meters.<br> <br>

            <b>The Algorithm:</b> <b>Segment Tree</b>A Segment Tree is used to store power usage data. It allows for rapid queries of a range of data (e.g., "total usage for houses 1-100") and quick updates to individual data points, which is essential for processing data from thousands of smart meters.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/segment.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Tree Construction</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Query / Update</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    
  </table>


             </div>


            </div>

            <br>


           <br>
            <br>
             <p><b>Outage Detection: </b>To instantly detect if any part of the grid has become disconnected from the main power source, allowing for immediate response.<br> <br>

            <b>The Algorithm:</b> <b>Union-Find</b>data structure tracks which parts of the grid are connected. If a power line breaks, the system can almost instantly determine if a sector is now in a separate, disconnected set from the main power source, triggering an alarm.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/union-find.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Find Operation</td>
      <td>O(1)</td>
      <td>O(α(N))</td>
      <td>O(α(N))</td>
    </tr>

    <tr>
      <td>Union Operation</td>
      <td>O(1)</td>
      <td>O(α(N))</td>
      <td>O(α(N))</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>


             </div>


            </div>

            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>


<div class="code-data" style="display:none;">

    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;fstream&gt;  
#include &lt;algorithm&gt;
#include &lt;limits&gt;

using namespace std;

ofstream fout("output.txt");

const int MAX_SOURCES = 20;
const int MAX_NODES   = 50;
const int MAX_EDGES   = 200;
const int MAX_HOUSES  = 50;
const int INF         = 1000000000;

// ----------------------------
// Power Source (Max-Heap)
// ----------------------------
struct PowerSource {
    int id;
    char name[20];
    int score;
};

PowerSource heapArr[MAX_SOURCES];
int heapSize = 0;

void swapSource(PowerSource &amp;a, PowerSource &amp;b) {
    PowerSource tmp = a;
    a = b;
    b = tmp;
}

void heapifyUp(int idx) {
    while (idx &gt; 0) {
        int parent = (idx - 1) / 2;
        if (heapArr[idx].score &gt; heapArr[parent].score) {
            swapSource(heapArr[idx], heapArr[parent]);
            idx = parent;
        } else break;
    }
}

void heapifyDown(int idx) {
    while (true) {
        int left = 2 * idx + 1;
        int right = 2 * idx + 2;
        int largest = idx;

        if (left &lt; heapSize &amp;&amp; heapArr[left].score &gt; heapArr[largest].score)
            largest = left;
        if (right &lt; heapSize &amp;&amp; heapArr[right].score &gt; heapArr[largest].score)
            largest = right;

        if (largest != idx) {
            swapSource(heapArr[idx], heapArr[largest]);
            idx = largest;
        } else break;
    }
}

void heapPush(const PowerSource &amp;s) {
    if (heapSize &gt;= MAX_SOURCES) return;
    heapArr[heapSize] = s;
    heapifyUp(heapSize);
    heapSize++;
}

PowerSource heapTop() {
    if (heapSize == 0) {
        PowerSource dummy;
        dummy.id = -1;
        strcpy(dummy.name, "None");
        dummy.score = -1;
        return dummy;
    }
    return heapArr[0];
}


// ----------------------------
// Union-Find
// ----------------------------
int parentUF[MAX_NODES];
int rankUF[MAX_NODES];

void makeSet(int n) {
    for (int i = 0; i &lt; n; ++i) {
        parentUF[i] = i;
        rankUF[i] = 0;
    }
}

int findSet(int v) {
    if (v == parentUF[v]) return v;
    parentUF[v] = findSet(parentUF[v]);
    return parentUF[v];
}

void unionSet(int a, int b) {
    a = findSet(a);
    b = findSet(b);
    if (a != b) {
        if (rankUF[a] &lt; rankUF[b]) swap(a, b);
        parentUF[b] = a;
        if (rankUF[a] == rankUF[b]) rankUF[a]++;
    }
}

// ----------------------------
// Edges
// ----------------------------
struct Edge {
    int u, v, w;
};

Edge edges[MAX_EDGES];
int N, M;

bool cmpEdge(const Edge &amp;a, const Edge &amp;b) {
    return a.w &lt; b.w;
}


// ----------------------------
// Kruskal MST
// ----------------------------
void runKruskalMST() {
    Edge sortedEdges[MAX_EDGES];
    for (int i = 0; i &lt; M; ++i) sortedEdges[i] = edges[i];

    sort(sortedEdges, sortedEdges + M, cmpEdge);

    makeSet(N);
    int edgesUsed = 0;
    long long totalWeight = 0;

    fout &lt;&lt; "\n--- DISTRIBUTION NETWORK (Kruskal MST) ---\n";
    fout &lt;&lt; "Edges in MST (u v w):\n";

    for (int i = 0; i &lt; M &amp;&amp; edgesUsed &lt; N - 1; ++i) {
        int u = sortedEdges[i].u;
        int v = sortedEdges[i].v;
        int w = sortedEdges[i].w;
        if (findSet(u) != findSet(v)) {
            unionSet(u, v);
            edgesUsed++;
            totalWeight += w;
            fout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; w &lt;&lt; "\n";
        }
    }
    fout &lt;&lt; "Total MST Cost: " &lt;&lt; totalWeight &lt;&lt; "\n";
}


// ----------------------------
// Dijkstra
// ----------------------------
int graphMat[MAX_NODES][MAX_NODES];

void runDijkstra(int src, int dest) {
    int dist[MAX_NODES];
    bool used[MAX_NODES];
    int parentNode[MAX_NODES];

    for (int i = 0; i &lt; N; ++i) {
        dist[i] = INF;
        used[i] = false;
        parentNode[i] = -1;
    }

    dist[src] = 0;

    for (int iter = 0; iter &lt; N; ++iter) {
        int u = -1, best = INF;
        for (int i = 0; i &lt; N; ++i)
            if (!used[i] &amp;&amp; dist[i] &lt; best)
                best = dist[i], u = i;

        if (u == -1) break;
        used[u] = true;

        for (int v = 0; v &lt; N; ++v)
            if (graphMat[u][v] &lt; INF &amp;&amp; dist[u] + graphMat[u][v] &lt; dist[v])
                dist[v] = dist[u] + graphMat[u][v], parentNode[v] = u;
    }

    fout &lt;&lt; "\n--- POWER FLOW ROUTING (Dijkstra) ---\n";
    if (dist[dest] == INF) {
        fout &lt;&lt; "No path.\n";
        return;
    }

    fout &lt;&lt; "Shortest Cost: " &lt;&lt; dist[dest] &lt;&lt; "\nPath: ";
    int path[MAX_NODES], len = 0, cur = dest;
    while (cur != -1) path[len++] = cur, cur = parentNode[cur];

    for (int i = len - 1; i &gt;= 0; --i)
        fout &lt;&lt; path[i] &lt;&lt; (i ? " -&gt; " : "");
    fout &lt;&lt; "\n";
}


// ----------------------------
// Segment Tree
// ----------------------------
long long arrHouses[MAX_HOUSES];
long long segTree[4 * MAX_HOUSES];
int H;

void buildSegTree(int idx, int l, int r) {
    if (l == r) { segTree[idx] = arrHouses[l]; return; }
    int mid = (l + r) / 2;
    buildSegTree(idx * 2, l, mid);
    buildSegTree(idx * 2 + 1, mid + 1, r);
    segTree[idx] = segTree[idx * 2] + segTree[idx * 2 + 1];
}

void updateSegTree(int idx, int l, int r, int pos, long long val) {
    if (l == r) { segTree[idx] = val; return; }
    int mid = (l + r) / 2;
    if (pos &lt;= mid) updateSegTree(idx * 2, l, mid, pos, val);
    else updateSegTree(idx * 2 + 1, mid + 1, r, pos, val);
    segTree[idx] = segTree[idx * 2] + segTree[idx * 2 + 1];
}

long long querySegTree(int idx, int l, int r, int ql, int qr) {
    if (qr &lt; l || ql &gt; r) return 0;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) return segTree[idx];
    int mid = (l + r) / 2;
    return querySegTree(idx * 2, l, mid, ql, qr) +
           querySegTree(idx * 2 + 1, mid + 1, r, ql, qr);
}

void runSegmentTreeQueries() {
    fout &lt;&lt; "\n--- REAL-TIME MONITORING (Segment Tree) ---\n";
    buildSegTree(1, 0, H - 1);
    int Q;
    cin &gt;&gt; Q;

    fout &lt;&lt; "Operations: " &lt;&lt; Q &lt;&lt; "\n";
    while (Q--) {
        char type;
        cin &gt;&gt; type;
        if (type == 'Q') {
            int l, r;
            cin &gt;&gt; l &gt;&gt; r;
            fout &lt;&lt; "Sum(" &lt;&lt; l &lt;&lt; "," &lt;&lt; r &lt;&lt; ") = " &lt;&lt; querySegTree(1, 0, H - 1, l, r) &lt;&lt; "\n";
        } else {
            int pos; long long val;
            cin &gt;&gt; pos &gt;&gt; val;
            updateSegTree(1, 0, H - 1, pos, val);
            fout &lt;&lt; "Updated meter " &lt;&lt; pos &lt;&lt; " to " &lt;&lt; val &lt;&lt; "\n";
        }
    }
}


// ----------------------------
// Outage Detection
// ----------------------------
bool disabledEdge[MAX_EDGES];

void runOutageDetection() {
    fout &lt;&lt; "\n--- OUTAGE DETECTION (Union-Find) ---\n";
    int B;
    cin &gt;&gt; B;

    for (int i = 0; i &lt; M; ++i) disabledEdge[i] = false;

    while (B--) {
        int idx;
        cin &gt;&gt; idx;
        disabledEdge[idx] = true;

        makeSet(N);
        for (int i = 0; i &lt; M; ++i)
            if (!disabledEdge[i])
                unionSet(edges[i].u, edges[i].v);

        fout &lt;&lt; "Failure Edge: #" &lt;&lt; idx &lt;&lt; "\nDisconnected nodes: ";
        int root = findSet(0);
        bool none = true;
        for (int i = 0; i &lt; N; ++i)
            if (findSet(i) != root)
                fout &lt;&lt; i &lt;&lt; " ", none = false;

        if (none) fout &lt;&lt; "None";
        fout &lt;&lt; "\n";
    }
}


// ----------------------------
// MAIN
// ----------------------------
int main() {
    int S;
    cin &gt;&gt; S;
    fout &lt;&lt; "--- POWER SOURCE SELECTION (Max-Heap) ---\n";
    
    for (int i = 0; i &lt; S; ++i) {
        PowerSource s;
        cin &gt;&gt; s.id &gt;&gt; s.name &gt;&gt; s.score;
        heapPush(s);
    }

    PowerSource best = heapTop();
    fout &lt;&lt; "Best Source: " &lt;&lt; best.name &lt;&lt; " (Score: " &lt;&lt; best.score &lt;&lt; ")\n";

    cin &gt;&gt; N &gt;&gt; M;
    
    for (int i = 0; i &lt; N; ++i)
        for (int j = 0; j &lt; N; ++j)
            graphMat[i][j] = (i == j ? 0 : INF);

    for (int i = 0; i &lt; M; ++i) {
        cin &gt;&gt; edges[i].u &gt;&gt; edges[i].v &gt;&gt; edges[i].w;
        graphMat[edges[i].u][edges[i].v] = edges[i].w;
        graphMat[edges[i].v][edges[i].u] = edges[i].w;
    }

    runKruskalMST();

    int src, dest;
    cin &gt;&gt; src &gt;&gt; dest;
    runDijkstra(src, dest);

    cin &gt;&gt; H;
    for (int i = 0; i &lt; H; ++i) cin &gt;&gt; arrHouses[i];

    runSegmentTreeQueries();
    runOutageDetection();

    fout.close();
    return 0;
}



    </div>

    <div class="data-input">
5
0 Solar 95
1 Wind 70
2 Hydro 85
3 Thermal 60
4 Backup 30
50 50
0 1 4
1 2 2
2 3 7
3 4 3
4 5 1
5 6 6
6 7 5
7 8 2
8 9 4
9 10 3
10 11 7
11 12 2
12 13 5
13 14 4
14 15 6
15 16 3
16 17 2
17 18 4
18 19 7
19 20 1
20 21 5
21 22 3
22 23 6
23 24 2
24 25 4
25 26 7
26 27 3
27 28 5
28 29 2
29 30 4
30 31 6
31 32 3
32 33 5
33 34 2
34 35 4
35 36 7
36 37 3
37 38 5
38 39 2
39 40 4
40 41 6
41 42 3
42 43 5
43 44 2
44 45 4
45 46 7
46 47 3
47 48 5
48 49 2
0 49 10
0 25
50
10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300 310 320 330 340 350 360 370 380 390 400 410 420 430 440 450 460 470 480 490 500
4
Q 0 9
Q 10 19
U 3 150
Q 0 9
3
0
10
49

    </div>

    <div class="data-output">
--- POWER SOURCE SELECTION (Max-Heap) ---
Best Source: Solar (Score: 95)

--- DISTRIBUTION NETWORK (Kruskal MST) ---
Edges in MST (u v w):
4 5 1
19 20 1
1 2 2
48 49 2
23 24 2
43 44 2
28 29 2
7 8 2
38 39 2
11 12 2
33 34 2
16 17 2
26 27 3
21 22 3
46 47 3
31 32 3
15 16 3
36 37 3
9 10 3
41 42 3
3 4 3
34 35 4
29 30 4
39 40 4
44 45 4
24 25 4
8 9 4
0 1 4
13 14 4
17 18 4
20 21 5
32 33 5
27 28 5
12 13 5
37 38 5
47 48 5
6 7 5
42 43 5
30 31 6
14 15 6
22 23 6
40 41 6
5 6 6
25 26 7
45 46 7
35 36 7
18 19 7
10 11 7
2 3 7
Total MST Cost: 197

--- POWER FLOW ROUTING (Dijkstra) ---
Shortest Cost: 98
Path: 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 13 -> 14 -> 15 -> 16 -> 17 -> 18 -> 19 -> 20 -> 21 -> 22 -> 23 -> 24 -> 25

--- REAL-TIME MONITORING (Segment Tree) ---
Operations: 4
Sum(0,9) = 550
Sum(10,19) = 1550
Updated meter 3 to 150
Sum(0,9) = 660

--- OUTAGE DETECTION (Union-Find) ---
Failure Edge: #0
Disconnected nodes: None
Failure Edge: #10
Disconnected nodes: 1 2 3 4 5 6 7 8 9 10 
Failure Edge: #49
Disconnected nodes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 

    </div>

</div>




        </div>

        <div class="content-box">
            <h3>Wireless Internet tower grid</h3>
            <div class="rule"></div>

            <p>A Wireless Internet Tower Grid is a city-wide system of interconnected communication towers that deliver fast, reliable, and uninterrupted internet coverage. These towers act as digital infrastructure that ensures every home, business, institution, and public space in Samarthaka city has seamless wireless connectivity—supporting education, healthcare, transport, and smart governance.<br>The Wireless Internet Tower Grid for Samarthaka consists of strategically placed communication towers connected through fiber-optic backbones and microwave relay links. Each tower covers a circular or sector-shaped region, forming an overlapping mesh so there are no dead zones.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>9, 11</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Infrastructure/sequence2.png" class="sequence">

            <p><b>Building the Communication Backbone: </b>To create a robust, central network backbone that connects all major towers together using the minimum possible total length of high-speed fiber or microwave links, starting construction from a central hub.<br> <br>

            <b>The Algorithm: </b><b>Prim's MST</b> is used to build a Minimum Spanning Tree (MST). It starts from an arbitrary "root" tower (perhaps your main data center connection). It then iteratively adds the closest (cheapest connection) neighboring tower that isn't yet part of the backbone. This process repeats until all towers are connected, ensuring the most cost-effective, loop-free backbone structure grows outwards from the center.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/prims.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Extract-Min</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
    </tr>

    <tr>
      <td>Decrease-Key</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>
  </table>


             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Route Internet Packets: </b>To determine the absolute fastest path for data packets to travel between any two towers in the entire grid, ensuring that no matter where a user is and which server they need to reach, the data takes the optimal route.<br> <br>

            <b>The Algorithm: </b><b>Floyd-Warshall</b> is an "all-pairs shortest path" algorithm. It analyzes the entire network graph and calculates the shortest path between every possible combination of source tower and destination tower. The result is a comprehensive routing table (a matrix) that the network uses to immediately know the best path for any packet, regardless of its entry and exit points in the grid.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/floyd.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Matrix Initialization</td>
      <td>O(V²)</td>
      <td>O(V²)</td>
      <td>O(V²)</td>
    </tr>

    <tr>
      <td>Triple Loop Updates</td>
      <td>O(V³)</td>
      <td>O(V³)</td>
      <td>O(V³)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(V³)</td>
      <td>O(V³)</td>
      <td>O(V³)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>
            <p><b>Tower Failure Handling & Rerouting: </b>To provide near-instantaneous recovery when a tower goes offline by immediately switching traffic to pre-calculated backup paths, minimizing service interruption for users.<br> <br>

            <b>The Algorithm: </b><b>Hashing</b> A Hash Table is used for ultra-fast lookups. The system maintains a table where the "key" is the ID of a specific tower, and the corresponding "value" is the pre-determined backup routing plan for that tower. When a tower failure is detected, the system hashes the failed tower's ID to instantly retrieve its backup route from the table (in O(1) constant time) and re-directs traffic without needing to recalculate the entire network topology.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/hash.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Search / Deletion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>


             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>
            <p><b>Load Balancing & Bandwidth Allocation: </b>To efficiently manage user demand by organizing bandwidth requests, ensuring that network resources are allocated fairly and that no single access point becomes overwhelmed by too many high-demand users.<br> <br>

            <b>The Algorithm: </b><b>Binary Search Tree - BST</b> A Binary Search Tree is used to maintain an organized structure of active user sessions or bandwidth requests, sorted by their consumption level (e.g., low bandwidth users on the left branch, high bandwidth on the right). Because the data is sorted hierarchically, the system can efficiently search for available bandwidth slots, identify top consumers, and reallocate resources to balance the load across different parts of the network.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/bst.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Search</td>
      <td>O(1)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Insertion / Deletion</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>


             </div>


            </div>

            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
#include &lt;limits&gt;

using namespace std;

ofstream fout("output.txt");   // All output will go here

const int MAX_NODES = 50;
const int MAX_EDGES = 200;
const int HASH_SIZE = 101;
const int INF = 1000000000;

// -------------------------------
// Graph storage (for Prim + Floyd)
// -------------------------------
int N, M;                         // number of towers, number of links
int graphMat[MAX_NODES][MAX_NODES];

struct Edge {
    int u, v, w;
};

Edge edges[MAX_EDGES];

// -------------------------------
// 1) Prim's MST (Backbone building)
// -------------------------------
void runPrimMST(int root) {
    bool inMST[MAX_NODES];
    int key[MAX_NODES];        // min edge weight to connect this node
    int parent[MAX_NODES];     // parent in MST

    for (int i = 0; i &lt; N; ++i) {
        inMST[i] = false;
        key[i] = INF;
        parent[i] = -1;
    }

    key[root] = 0;

    for (int count = 0; count &lt; N - 1; ++count) {
        int u = -1;
        int best = INF;

        for (int i = 0; i &lt; N; ++i) {
            if (!inMST[i] &amp;&amp; key[i] &lt; best) {
                best = key[i];
                u = i;
            }
        }

        if (u == -1) break; // disconnected graph
        inMST[u] = true;

        // update neighbors
        for (int v = 0; v &lt; N; ++v) {
            if (graphMat[u][v] &lt; INF &amp;&amp; !inMST[v] &amp;&amp; graphMat[u][v] &lt; key[v]) {
                key[v] = graphMat[u][v];
                parent[v] = u;
            }
        }
    }

    fout &lt;&lt; "--- COMMUNICATION BACKBONE (Prim MST) ---\n";
    int totalCost = 0;
    for (int v = 0; v &lt; N; ++v) {
        if (v == root) continue;
        if (parent[v] != -1) {
            fout &lt;&lt; "Link: " &lt;&lt; parent[v] &lt;&lt; " - " &lt;&lt; v
                 &lt;&lt; "  Cost: " &lt;&lt; graphMat[parent[v]][v] &lt;&lt; "\n";
            totalCost += graphMat[parent[v]][v];
        }
    }
    fout &lt;&lt; "Total Backbone Cost = " &lt;&lt; totalCost &lt;&lt; "\n\n";
}

// -------------------------------
// 2) Floyd-Warshall (All-pairs routing)
// -------------------------------
int distFW[MAX_NODES][MAX_NODES];
int nextFW[MAX_NODES][MAX_NODES];

void runFloydWarshall() {
    // Initialize
    for (int i = 0; i &lt; N; ++i) {
        for (int j = 0; j &lt; N; ++j) {
            distFW[i][j] = graphMat[i][j];
            if (graphMat[i][j] &lt; INF &amp;&amp; i != j)
                nextFW[i][j] = j;
            else
                nextFW[i][j] = -1;
        }
    }

    // Floyd-Warshall core
    for (int k = 0; k &lt; N; ++k) {
        for (int i = 0; i &lt; N; ++i) {
            if (distFW[i][k] == INF) continue;
            for (int j = 0; j &lt; N; ++j) {
                if (distFW[k][j] == INF) continue;
                int through = distFW[i][k] + distFW[k][j];
                if (through &lt; distFW[i][j]) {
                    distFW[i][j] = through;
                    nextFW[i][j] = nextFW[i][k];
                }
            }
        }
    }
}

void printFWPath(int u, int v) {
    if (nextFW[u][v] == -1) {
        fout &lt;&lt; "No path";
        return;
    }
    int path[MAX_NODES];
    int len = 0;
    int cur = u;
    path[len++] = cur;
    while (cur != v &amp;&amp; len &lt; MAX_NODES) {
        cur = nextFW[cur][v];
        path[len++] = cur;
    }
    for (int i = 0; i &lt; len; ++i) {
        fout &lt;&lt; path[i];
        if (i + 1 &lt; len) fout &lt;&lt; " -&gt; ";
    }
}

void answerFloydQueries(int Qfw) {
    fout &lt;&lt; "--- INTERNET PACKET ROUTING (Floyd-Warshall) ---\n";
    for (int q = 0; q &lt; Qfw; ++q) {
        int src, dest;
        cin &gt;&gt; src &gt;&gt; dest;
        fout &lt;&lt; "Fastest path from Tower " &lt;&lt; src &lt;&lt; " to Tower " &lt;&lt; dest &lt;&lt; ":\n";
        if (distFW[src][dest] &gt;= INF) {
            fout &lt;&lt; "  No route available.\n\n";
        } else {
            fout &lt;&lt; "  Cost: " &lt;&lt; distFW[src][dest] &lt;&lt; "\n";
            fout &lt;&lt; "  Path: ";
            printFWPath(src, dest);
            fout &lt;&lt; "\n\n";
        }
    }
}

// -------------------------------
// 3) Hash Table (Tower failure → backup routes)
// -------------------------------
struct BackupRoute {
    int towerId;
    int count;
    int backups[10];
    bool used;
};

BackupRoute hashTable[HASH_SIZE];

int hashFunc(int key) {
    if (key &lt; 0) key = -key;
    return key % HASH_SIZE;
}

void initHash() {
    for (int i = 0; i &lt; HASH_SIZE; ++i) {
        hashTable[i].used = false;
        hashTable[i].towerId = -1;
        hashTable[i].count = 0;
    }
}

void insertBackup(int towerId, int count, int *arr) {
    int idx = hashFunc(towerId);
    for (int i = 0; i &lt; HASH_SIZE; ++i) {
        int pos = (idx + i) % HASH_SIZE;
        if (!hashTable[pos].used || hashTable[pos].towerId == towerId) {
            hashTable[pos].used = true;
            hashTable[pos].towerId = towerId;
            hashTable[pos].count = count;
            for (int j = 0; j &lt; count; ++j) {
                hashTable[pos].backups[j] = arr[j];
            }
            return;
        }
    }
}

BackupRoute* findBackup(int towerId) {
    int idx = hashFunc(towerId);
    for (int i = 0; i &lt; HASH_SIZE; ++i) {
        int pos = (idx + i) % HASH_SIZE;
        if (!hashTable[pos].used) return nullptr;
        if (hashTable[pos].towerId == towerId) return &amp;hashTable[pos];
    }
    return nullptr;
}

void runFailureHandling(int Qfail) {
    fout &lt;&lt; "--- TOWER FAILURE HANDLING (Hash Table) ---\n";
    for (int i = 0; i &lt; Qfail; ++i) {
        int failedId;
        cin &gt;&gt; failedId;
        fout &lt;&lt; "Tower " &lt;&lt; failedId &lt;&lt; " FAILED.\n";
        BackupRoute* br = findBackup(failedId);
        if (br == nullptr || br-&gt;count == 0) {
            fout &lt;&lt; "  No precomputed backup route.\n\n";
        } else {
            fout &lt;&lt; "  Backup route via towers: ";
            for (int j = 0; j &lt; br-&gt;count; ++j) {
                fout &lt;&lt; br-&gt;backups[j];
                if (j + 1 &lt; br-&gt;count) fout &lt;&lt; " -&gt; ";
            }
            fout &lt;&lt; "\n\n";
        }
    }
}

// -------------------------------
// 4) BST for Load Balancing
// -------------------------------
struct SessionNode {
    int userId;
    int bandwidth;    // Mbps used
    SessionNode *left;
    SessionNode *right;
};

SessionNode* newNode(int userId, int bandwidth) {
    SessionNode* node = new SessionNode;
    node-&gt;userId = userId;
    node-&gt;bandwidth = bandwidth;
    node-&gt;left = node-&gt;right = nullptr;
    return node;
}

SessionNode* insertSession(SessionNode* root, int userId, int bandwidth) {
    if (root == nullptr) return newNode(userId, bandwidth);
    if (bandwidth &lt; root-&gt;bandwidth)
        root-&gt;left = insertSession(root-&gt;left, userId, bandwidth);
    else
        root-&gt;right = insertSession(root-&gt;right, userId, bandwidth);
    return root;
}

void inorderSessions(SessionNode* root) {
    if (!root) return;
    inorderSessions(root-&gt;left);
    fout &lt;&lt; "User " &lt;&lt; root-&gt;userId &lt;&lt; " - Bandwidth " &lt;&lt; root-&gt;bandwidth &lt;&lt; " Mbps\n";
    inorderSessions(root-&gt;right);
}

void findMaxSession(SessionNode* root, int &amp;maxBw, int &amp;maxUser) {
    if (!root) return;
    if (root-&gt;bandwidth &gt; maxBw) {
        maxBw = root-&gt;bandwidth;
        maxUser = root-&gt;userId;
    }
    findMaxSession(root-&gt;left, maxBw, maxUser);
    findMaxSession(root-&gt;right, maxBw, maxUser);
}

void runLoadBalancing(SessionNode* root) {
    fout &lt;&lt; "--- LOAD BALANCING (BST of Sessions) ---\n";
    fout &lt;&lt; "Active sessions sorted by bandwidth:\n";
    inorderSessions(root);
    int maxBw = -1, maxUser = -1;
    findMaxSession(root, maxBw, maxUser);
    if (maxBw != -1) {
        fout &lt;&lt; "\nTop bandwidth consumer: User " &lt;&lt; maxUser
             &lt;&lt; " with " &lt;&lt; maxBw &lt;&lt; " Mbps\n";
    }
    fout &lt;&lt; "\n";
}

// -------------------------------
// MAIN
// -------------------------------
int main() {
    // 1) Read towers &amp; links
    cin &gt;&gt; N &gt;&gt; M;

    // Initialize adjacency matrix
    for (int i = 0; i &lt; N; ++i) {
        for (int j = 0; j &lt; N; ++j) {
            if (i == j) graphMat[i][j] = 0;
            else graphMat[i][j] = INF;
        }
    }

    for (int i = 0; i &lt; M; ++i) {
        int u, v, w;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        edges[i].u = u;
        edges[i].v = v;
        edges[i].w = w;
        if (w &lt; graphMat[u][v]) {      // keep smallest if multiple
            graphMat[u][v] = w;
            graphMat[v][u] = w;
        }
    }

    // 2) Prim MST (backbone)
    int rootTower;
    cin &gt;&gt; rootTower;
    runPrimMST(rootTower);

    // 3) Floyd-Warshall (all-pairs)
    runFloydWarshall();
    int Qfw;
    cin &gt;&gt; Qfw;
    answerFloydQueries(Qfw);

    // 4) Hash table for tower failure backup routes
    initHash();
    int H;
    cin &gt;&gt; H;
    for (int i = 0; i &lt; H; ++i) {
        int towerId, cnt;
        cin &gt;&gt; towerId &gt;&gt; cnt;
        int temp[10];
        for (int j = 0; j &lt; cnt; ++j) {
            cin &gt;&gt; temp[j];
        }
        insertBackup(towerId, cnt, temp);
    }

    int Qfail;
    cin &gt;&gt; Qfail;
    runFailureHandling(Qfail);

    // 5) BST for load balancing
    int S;
    cin &gt;&gt; S;
    SessionNode* root = nullptr;
    for (int i = 0; i &lt; S; ++i) {
        int uid, bw;
        cin &gt;&gt; uid &gt;&gt; bw;
        root = insertSession(root, uid, bw);
    }
    runLoadBalancing(root);

    fout.close();
    return 0;
}









    </div>

    <div class="data-input">

50 54
0 1 2
1 2 3
2 3 4
3 4 5
4 5 6
5 6 7
6 7 8
7 8 9
8 9 10
9 10 2
10 11 3
11 12 4
12 13 5
13 14 6
14 15 7
15 16 8
16 17 9
17 18 10
18 19 2
19 20 3
20 21 4
21 22 5
22 23 6
23 24 7
24 25 8
25 26 9
26 27 10
27 28 2
28 29 3
29 30 4
30 31 5
31 32 6
32 33 7
33 34 8
34 35 9
35 36 10
36 37 2
37 38 3
38 39 4
39 40 5
40 41 6
41 42 7
42 43 8
43 44 9
44 45 10
45 46 2
46 47 3
47 48 4
48 49 5
49 0 5
0 10 7
10 20 4
20 30 6
30 40 3

0
3
0 25
5 40
12 33

5
5 2 4 6
10 3 0 9 11
20 2 10 30
25 2 20 26
40 2 30 41

3
5
10
40

10
101 5
102 10
103 3
104 20
105 15
106 25
107 8
108 12
109 18
110 30




    </div>

    <div class="data-output">

--- COMMUNICATION BACKBONE (Prim MST) ---
Link: 0 - 1  Cost: 2
Link: 1 - 2  Cost: 3
Link: 2 - 3  Cost: 4
Link: 3 - 4  Cost: 5
Link: 4 - 5  Cost: 6
Link: 5 - 6  Cost: 7
Link: 6 - 7  Cost: 8
Link: 7 - 8  Cost: 9
Link: 10 - 9  Cost: 2
Link: 0 - 10  Cost: 7
Link: 10 - 11  Cost: 3
Link: 11 - 12  Cost: 4
Link: 12 - 13  Cost: 5
Link: 13 - 14  Cost: 6
Link: 14 - 15  Cost: 7
Link: 15 - 16  Cost: 8
Link: 16 - 17  Cost: 9
Link: 19 - 18  Cost: 2
Link: 20 - 19  Cost: 3
Link: 10 - 20  Cost: 4
Link: 20 - 21  Cost: 4
Link: 21 - 22  Cost: 5
Link: 22 - 23  Cost: 6
Link: 23 - 24  Cost: 7
Link: 24 - 25  Cost: 8
Link: 25 - 26  Cost: 9
Link: 28 - 27  Cost: 2
Link: 29 - 28  Cost: 3
Link: 30 - 29  Cost: 4
Link: 20 - 30  Cost: 6
Link: 30 - 31  Cost: 5
Link: 31 - 32  Cost: 6
Link: 32 - 33  Cost: 7
Link: 33 - 34  Cost: 8
Link: 34 - 35  Cost: 9
Link: 37 - 36  Cost: 2
Link: 38 - 37  Cost: 3
Link: 39 - 38  Cost: 4
Link: 40 - 39  Cost: 5
Link: 30 - 40  Cost: 3
Link: 40 - 41  Cost: 6
Link: 41 - 42  Cost: 7
Link: 42 - 43  Cost: 8
Link: 43 - 44  Cost: 9
Link: 46 - 45  Cost: 2
Link: 47 - 46  Cost: 3
Link: 48 - 47  Cost: 4
Link: 49 - 48  Cost: 5
Link: 0 - 49  Cost: 5
Total Backbone Cost = 259

--- INTERNET PACKET ROUTING (Floyd-Warshall) ---
Fastest path from Tower 0 to Tower 25:
  Cost: 41
  Path: 0 -> 10 -> 20 -> 21 -> 22 -> 23 -> 24 -> 25

Fastest path from Tower 5 to Tower 40:
  Cost: 40
  Path: 5 -> 4 -> 3 -> 2 -> 1 -> 0 -> 10 -> 20 -> 30 -> 40

Fastest path from Tower 12 to Tower 33:
  Cost: 35
  Path: 12 -> 11 -> 10 -> 20 -> 30 -> 31 -> 32 -> 33

--- TOWER FAILURE HANDLING (Hash Table) ---
Tower 5 FAILED.
  Backup route via towers: 4 -> 6

Tower 10 FAILED.
  Backup route via towers: 0 -> 9 -> 11

Tower 40 FAILED.
  Backup route via towers: 30 -> 41

--- LOAD BALANCING (BST of Sessions) ---
Active sessions sorted by bandwidth:
User 103 - Bandwidth 3 Mbps
User 101 - Bandwidth 5 Mbps
User 107 - Bandwidth 8 Mbps
User 102 - Bandwidth 10 Mbps
User 108 - Bandwidth 12 Mbps
User 105 - Bandwidth 15 Mbps
User 109 - Bandwidth 18 Mbps
User 104 - Bandwidth 20 Mbps
User 106 - Bandwidth 25 Mbps
User 110 - Bandwidth 30 Mbps

Top bandwidth consumer: User 110 with 30 Mbps



        
    </div>
</div>





        </div>

        <div class="content-box">
            <h3>Integrated Waste management system</h3>
            <div class="rule"></div>

            <p>The Integrated Waste Management System in Samarthaka uses smart sensors in public dustbins to monitor fill levels in real time. This data is sent to a central control dashboard, where collection routes are dynamically optimized so trucks only visit bins that are actually full. The city is divided into zones, each equipped with waste. <br> A digital tracking system records the journey of waste—from bin to truck to processing center—ensuring complete transparency. Recycling centers use compactors, sorters, and shredders to recover materials, while organic waste is sent to biogas plants or composting sites. The system reduces landfill usage, lowers pollution, and ensures a clean, sustainable city environment.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>11, 12</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>


            <img src="Infrastructure/sequence3.png" class="sequence">

            <p><b>Route optimization for garbage trucks: </b>To find the most efficient routes for garbage trucks, which works well when routes have varying weights such as traffic, distance, or time. The system can also handle negative weights, which can represent delays.<br> <br>

            <b>The Algorithm: </b><b>Bellman-Ford</b> algorithm is used to calculate the shortest paths in a network where edges can have different weights, including negative ones, ensuring trucks take the most optimal path even with varying conditions.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/bellman.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Edge Relaxation</td>
      <td>O(E)</td>
      <td>O(VE)</td>
      <td>O(VE)</td>
    </tr>

    <tr>
      <td>Negative Cycle Check</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E)</td>
      <td>O(VE)</td>
      <td>O(VE)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Waste segregation (categorizing recyclable, organic, toxic): </b>To provide fast categorization of waste items based on their material type names or codes, such as "plastic" or "paper".<br> <br>

            <b>The Algorithm: </b><b>Trie</b> or prefix tree, is used for its efficient search and insertion properties, allowing for rapid identification and sorting of waste materials based on their textual descriptions or identifiers.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/trie.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Insertion</td>
      <td>O(L)</td>
      <td>O(L)</td>
      <td>O(L)</td>
    </tr>

    <tr>
      <td>Search / Prefix</td>
      <td>O(L)</td>
      <td>O(L)</td>
      <td>O(L)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N × L)</td>
      <td>O(N × L)</td>
      <td>O(N × L)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Processing facility load balancing: </b>To maintain a fair and even distribution of incoming waste across multiple processing facilities to ensure no single facility is overburdened.<br> <br>

            <b>The Algorithm: </b><b>Red-Black Tree</b> is a self-balancing binary search tree that automatically keeps its height small, ensuring that the distribution of load (represented by the nodes) remains balanced across the available facilities.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/red.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Search</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Insertion / Deletion</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>
            <p><b>Fault detection in bins, trucks, or sensors: </b>To allow for a fast search through a large number of units (bins, trucks, sensors) to quickly identify any that are malfunctioning.<br> <br>

            <b>The Algorithm: </b><b>Skip List</b> is a probabilistic data structure that allows for fast search, insertion, and deletion operations, serving as an efficient alternative to balanced trees for quickly locating faulty units.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/skip.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Search</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Insertion / Deletion</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;

using namespace std;
ofstream fout("output.txt");

/* Read tokens safely */
bool seek(const char *h) {
    string tok;
    while (cin &gt;&gt; tok) {
        if (tok == h) return true;
    }
    return false;
}

/* ================= Bellman-Ford (ROUTE) ================= */
const int MAXN = 60;
const int MAXE = 600;

struct Edge { int u, v, w; } E[MAXE];
int Ec = 0;
int Nnodes;
int distBF[MAXN], parentBF[MAXN];

void bfAdd(int u, int v, int w) {
    if (Ec &lt; MAXE) { E[Ec].u = u; E[Ec].v = v; E[Ec].w = w; Ec++; }
}

void bellmanFord(int src) {
    const int INF = 1000000000;
    for (int i = 1; i &lt;= Nnodes; i++) { distBF[i] = INF; parentBF[i] = -1; }
    distBF[src] = 0;
    for (int it = 1; it &lt;= Nnodes - 1; it++) {
        bool changed = false;
        for (int e = 0; e &lt; Ec; e++) {
            int u = E[e].u, v = E[e].v, w = E[e].w;
            if (distBF[u] &lt; INF &amp;&amp; distBF[u] + w &lt; distBF[v]) {
                distBF[v] = distBF[u] + w;
                parentBF[v] = u;
                changed = true;
            }
        }
        if (!changed) break;
    }
}

void printBFPath(int dest) {
    const int INF = 1000000000;
    if (dest &lt; 1 || dest &gt; Nnodes || distBF[dest] &gt;= INF) {
        fout &lt;&lt; "No route available.\n";
        return;
    }
    int tmp[MAXN], c = 0, cur = dest;
    while (cur != -1) { tmp[c++] = cur; cur = parentBF[cur]; }
    fout &lt;&lt; "Distance: " &lt;&lt; distBF[dest] &lt;&lt; "\nPath: ";
    for (int i = c - 1; i &gt;= 0; i--) {
        fout &lt;&lt; tmp[i];
        if (i) fout &lt;&lt; " -&gt; ";
    }
    fout &lt;&lt; "\n";
}

/* ================= TRIE (waste categories) ================= */
struct Trie {
    bool end;
    Trie* child[26];
    Trie() { end = false; for (int i=0;i&lt;26;i++) child[i]=NULL; }
};

Trie *root = new Trie();

void trieInsert(const string &amp;s) {
    Trie *cur = root;
    for (size_t i=0;i&lt;s.size();i++) {
        char c = s[i];
        if (c &lt; 'a' || c &gt; 'z') continue;
        int idx = c - 'a';
        if (!cur-&gt;child[idx]) cur-&gt;child[idx] = new Trie();
        cur = cur-&gt;child[idx];
    }
    cur-&gt;end = true;
}

bool trieSearch(const string &amp;s) {
    Trie *cur = root;
    for (size_t i=0;i&lt;s.size();i++) {
        char c = s[i];
        if (c &lt; 'a' || c &gt; 'z') continue;
        int idx = c - 'a';
        if (!cur-&gt;child[idx]) return false;
        cur = cur-&gt;child[idx];
    }
    return cur-&gt;end;
}

/* ================= RED-BLACK (load balancing) ================= */
/* Minimal insertion-only RB tree sufficient for printing sorted loads */
enum Color { RED, BLACK };

struct RB {
    int load;
    Color color;
    RB *left, *right, *parent;
    RB(int v):load(v),color(RED),left(NULL),right(NULL),parent(NULL){}
};

RB* RBroot = NULL;

RB* grandparent(RB* n) { return n &amp;&amp; n-&gt;parent ? n-&gt;parent-&gt;parent : NULL; }
RB* uncle(RB* n) {
    RB* g = grandparent(n);
    if (!g) return NULL;
    return (n-&gt;parent == g-&gt;left) ? g-&gt;right : g-&gt;left;
}

void rotateLeft(RB*&amp;root, RB* n) {
    RB* r = n-&gt;right;
    n-&gt;right = r-&gt;left;
    if (r-&gt;left) r-&gt;left-&gt;parent = n;
    r-&gt;parent = n-&gt;parent;
    if (!n-&gt;parent) root = r;
    else if (n == n-&gt;parent-&gt;left) n-&gt;parent-&gt;left = r;
    else n-&gt;parent-&gt;right = r;
    r-&gt;left = n;
    n-&gt;parent = r;
}

void rotateRight(RB*&amp;root, RB* n) {
    RB* l = n-&gt;left;
    n-&gt;left = l-&gt;right;
    if (l-&gt;right) l-&gt;right-&gt;parent = n;
    l-&gt;parent = n-&gt;parent;
    if (!n-&gt;parent) root = l;
    else if (n == n-&gt;parent-&gt;left) n-&gt;parent-&gt;left = l;
    else n-&gt;parent-&gt;right = l;
    l-&gt;right = n;
    n-&gt;parent = l;
}

void fixInsert(RB*&amp;root, RB* n) {
    while (n != root &amp;&amp; n-&gt;parent-&gt;color == RED) {
        RB* u = uncle(n);
        RB* g = grandparent(n);
        if (u &amp;&amp; u-&gt;color == RED) {
            n-&gt;parent-&gt;color = BLACK;
            u-&gt;color = BLACK;
            g-&gt;color = RED;
            n = g;
        } else {
            if (n-&gt;parent == g-&gt;left) {
                if (n == n-&gt;parent-&gt;right) { n = n-&gt;parent; rotateLeft(root, n); }
                n-&gt;parent-&gt;color = BLACK;
                g-&gt;color = RED;
                rotateRight(root, g);
            } else {
                if (n == n-&gt;parent-&gt;left) { n = n-&gt;parent; rotateRight(root, n); }
                n-&gt;parent-&gt;color = BLACK;
                g-&gt;color = RED;
                rotateLeft(root, g);
            }
        }
    }
    root-&gt;color = BLACK;
}

void RBinsert(int load) {
    RB* n = new RB(load);
    RB* cur = RBroot; RB* parent = NULL;
    while (cur) { parent = cur; if (load &lt; cur-&gt;load) cur = cur-&gt;left; else cur = cur-&gt;right; }
    n-&gt;parent = parent;
    if (!parent) RBroot = n;
    else if (load &lt; parent-&gt;load) parent-&gt;left = n;
    else parent-&gt;right = n;
    fixInsert(RBroot, n);
}

void RBprint(RB* n) {
    if (!n) return;
    RBprint(n-&gt;left);
    fout &lt;&lt; "Facility load: " &lt;&lt; n-&gt;load &lt;&lt; "\n";
    RBprint(n-&gt;right);
}

/* ================= SKIP LIST (fault detection) ================= */
struct SL {
    int key;
    SL *next, *down;
    SL(int k):key(k),next(NULL),down(NULL){}
};

SL* SLhead = new SL(-1);

bool SLsearch(int key) {
    SL* cur = SLhead;
    while (cur) {
        while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;key &lt; key) cur = cur-&gt;next;
        if (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;key == key) return true;
        cur = cur-&gt;down;
    }
    return false;
}

void SLinsert(int key) {
    SL* update[20];
    SL* cur = SLhead;
    int lvl = 0;
    while (cur) {
        while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;key &lt; key) cur = cur-&gt;next;
        update[lvl++] = cur;
        cur = cur-&gt;down;
    }
    SL* downNode = NULL;
    bool promote = true;
    for (int i = 0; i &lt; lvl &amp;&amp; promote; i++) {
        SL* n = new SL(key);
        n-&gt;next = update[i]-&gt;next;
        update[i]-&gt;next = n;
        n-&gt;down = downNode;
        downNode = n;
        promote = (rand() % 2 == 0);
    }
}

/* ================= MAIN ================= */
int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    /* ROUTE */
    if (!seek("ROUTE")) { fout &lt;&lt; "ROUTE missing\n"; return 0; }
    int M;
    cin &gt;&gt; Nnodes &gt;&gt; M;
    for (int i=0;i&lt;M;i++) { int u,v,w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; bfAdd(u,v,w); }

    fout &lt;&lt; "--- ROUTE OPTIMIZATION (Bellman-Ford) ---\n";
    int Q; cin &gt;&gt; Q;
    for (int i=0;i&lt;Q;i++) {
        int s,d; cin &gt;&gt; s &gt;&gt; d;
        bellmanFord(s);
        printBFPath(d);
        fout &lt;&lt; "-----\n";
    }

    /* TRIE */
    if (!seek("TRIE")) { fout &lt;&lt; "TRIE missing\n"; return 0; }
    fout &lt;&lt; "\n--- WASTE SEGREGATION (Trie) ---\n";
    int T; cin &gt;&gt; T;
    for (int i=0;i&lt;T;i++) { string s; cin &gt;&gt; s; trieInsert(s); }
    int Ts; cin &gt;&gt; Ts;
    for (int i=0;i&lt;Ts;i++) { string q; cin &gt;&gt; q; fout &lt;&lt; q &lt;&lt; ": " &lt;&lt; (trieSearch(q) ? "KNOWN" : "UNKNOWN") &lt;&lt; "\n"; }

    /* RB */
    if (!seek("RB")) { fout &lt;&lt; "RB missing\n"; return 0; }
    fout &lt;&lt; "\n--- FACILITY LOAD BALANCING (Red-Black Tree) ---\n";
    int RBF; cin &gt;&gt; RBF;
    for (int i=0;i&lt;RBF;i++) { int load; cin &gt;&gt; load; RBinsert(load); }
    fout &lt;&lt; "Sorted facility loads:\n";
    RBprint(RBroot);

    /* SKIP */
    if (!seek("SKIP")) { fout &lt;&lt; "SKIP missing\n"; return 0; }
    fout &lt;&lt; "\n--- FAULT DETECTION (Skip List) ---\n";
    int KF; cin &gt;&gt; KF;
    for (int i=0;i&lt;KF;i++) { int x; cin &gt;&gt; x; SLinsert(x); }
    int KQ; cin &gt;&gt; KQ;
    for (int i=0;i&lt;KQ;i++) { int f; cin &gt;&gt; f; fout &lt;&lt; "Unit " &lt;&lt; f &lt;&lt; ": " &lt;&lt; (SLsearch(f) ? "FAULTY" : "OK") &lt;&lt; "\n"; }

    fout.close();
    return 0;
}


    </div>

    <div class="data-input">
      ROUTE
50 49
1 2 3
2 3 -2
3 4 4
4 5 6
5 6 -1
6 7 2
7 8 3
8 9 1
9 10 2
10 11 -3
11 12 4
12 13 2
13 14 1
14 15 5
15 16 -2
16 17 3
17 18 4
18 19 -1
19 20 2
20 21 3
21 22 1
22 23 2
23 24 -2
24 25 4
25 26 3
26 27 1
27 28 2
28 29 3
29 30 -1
30 31 4
31 32 2
32 33 5
33 34 -2
34 35 3
35 36 4
36 37 -1
37 38 2
38 39 3
39 40 1
40 41 -2
41 42 4
42 43 5
43 44 -3
44 45 2
45 46 3
46 47 1
47 48 -2
48 49 4
49 50 3
5
1 25
1 50
10 40
20 45
30 50

TRIE
10
plastic
paper
glass
metal
organic
toxic
rubber
cotton
wood
biowaste
6
paper
stone
metal
rubber
leaf
glass

RB
12
40 25 60 10 35 55 70 20 45 15 65 50

SKIP
10
101 205 150 330 400 250 500 75 180 999
6
150
999
330
205
100
500


    </div>

    <div class="data-output">
--- ROUTE OPTIMIZATION (Bellman-Ford) ---
Distance: 41
Path: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 13 -> 14 -> 15 -> 16 -> 17 -> 18 -> 19 -> 20 -> 21 -> 22 -> 23 -> 24 -> 25
-----
Distance: 85
Path: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 13 -> 14 -> 15 -> 16 -> 17 -> 18 -> 19 -> 20 -> 21 -> 22 -> 23 -> 24 -> 25 -> 26 -> 27 -> 28 -> 29 -> 30 -> 31 -> 32 -> 33 -> 34 -> 35 -> 36 -> 37 -> 38 -> 39 -> 40 -> 41 -> 42 -> 43 -> 44 -> 45 -> 46 -> 47 -> 48 -> 49 -> 50
-----
Distance: 52
Path: 10 -> 11 -> 12 -> 13 -> 14 -> 15 -> 16 -> 17 -> 18 -> 19 -> 20 -> 21 -> 22 -> 23 -> 24 -> 25 -> 26 -> 27 -> 28 -> 29 -> 30 -> 31 -> 32 -> 33 -> 34 -> 35 -> 36 -> 37 -> 38 -> 39 -> 40
-----
Distance: 43
Path: 20 -> 21 -> 22 -> 23 -> 24 -> 25 -> 26 -> 27 -> 28 -> 29 -> 30 -> 31 -> 32 -> 33 -> 34 -> 35 -> 36 -> 37 -> 38 -> 39 -> 40 -> 41 -> 42 -> 43 -> 44 -> 45
-----
Distance: 36
Path: 30 -> 31 -> 32 -> 33 -> 34 -> 35 -> 36 -> 37 -> 38 -> 39 -> 40 -> 41 -> 42 -> 43 -> 44 -> 45 -> 46 -> 47 -> 48 -> 49 -> 50
-----

--- WASTE SEGREGATION (Trie) ---
paper: KNOWN
stone: UNKNOWN
metal: KNOWN
rubber: KNOWN
leaf: UNKNOWN
glass: KNOWN

--- FACILITY LOAD BALANCING (Red-Black Tree) ---
Sorted facility loads:
Facility load: 10
Facility load: 15
Facility load: 20
Facility load: 25
Facility load: 35
Facility load: 40
Facility load: 45
Facility load: 50
Facility load: 55
Facility load: 60
Facility load: 65
Facility load: 70

--- FAULT DETECTION (Skip List) ---
Unit 150: FAULTY
Unit 999: FAULTY
Unit 330: FAULTY
Unit 205: FAULTY
Unit 100: OK
Unit 500: FAULTY


    </div>
</div>


        </div>

        </div>

        
       

        <h2 class="section-heading">Transport Network</h2>

        <div class="content-box-container">
            <div class="content-box">
            <h3>Metro Transit System & Digital Ticketing</h3>
            <div class="rule"></div>
            <p>The Metro Transit System in Samarthaka provides a fast, clean, and efficient mode of urban transport that connects major residential zones, commercial districts, and business hubs. It is designed with smart scheduling, automatic fare collection, real-time crowd monitoring, and optimized route planning to ensure smooth mobility for citizens.<br>The system uses digital sensors, central control units, and communication between stations to maintain punctuality, safety, and energy efficiency. By reducing traffic congestion, lowering pollution, and enabling seamless travel, the metro becomes the backbone of sustainable mobility in the city.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>9, 11</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Transport/sequence1.png" class="sequence">

            <p><b>Route Planning & Shortest Travel Time: </b>To enable passengers to instantly find the quickest route between any two metro stations within the expansive Samarthaka network, considering varying travel times between different stretches as the "cost."<br> <br>

            <b>The Algorithm: </b><b>Dijkstra’s Algorithm</b> models the metro network as a graph where stations are nodes and connecting tracks are edges, weighted by their specific travel times. Starting from the passenger's chosen entry station, the algorithm systematically explores neighboring nodes to calculate the path with the absolute minimum total travel time to the destination, ensuring passengers are always directed to the fastest route.</p>
            <br>

            <div class="image-box">
             <img src="Transport/dij.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Extract-Min Operations</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
    </tr>

    <tr>
      <td>Decrease-Key Operations</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
    </tr>
  </table>



             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Train Scheduling & Dispatch Timing: </b>To manage the dynamic and tight schedule of train departures efficiently. The system must ensure trains are dispatched precisely on time and that timetable adjustments—due to unexpected delays or the insertion of extra peak-hour trains—are handled instantly without disrupting the overall operational flow.<br> <br>

            <b>The Algorithm: </b><b>AVL Tree</b> An AVL tree is a self-balancing binary search tree used here to store scheduled train departure times chronologically. The tree automatically maintains its balance after every insertion or deletion, the system can perform operations like searching for the next immediate departure, adding a new train slot etc.</p>
            <br>

            <div class="image-box">
             <img src="Transport/avl.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Search</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Insertion / Deletion</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>



            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>
            <p><b>Passenger Load Monitoring (Crowd Density): </b>To monitor real-time crowd density on moving trains across different segments of the metro line. This allows operators to identify overcrowded stretches instantly and make data-driven decisions, such as deploying extra trains or regulating station entry.<br> <br>

            <b>The Algorithm: </b><b>Fenwick Tree (Binary Indexed Tree)</b> A Fenwick Tree is a specialized data structure designed for efficiently updating values and calculating prefix sums. In this context, it tracks the net number of passengers on board. As passengers board or alight at a station (a "point update"), the tree updates instantly.</p>
            <br>

            <div class="image-box">
             <img src="Transport/fenwick.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Update Value</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Prefix Sum Query</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>
            <p><b>Ticketing & Metro Card Validation: </b>To provide near-instantaneous validation of thousands of metro cards per minute at entry and exit gates. This ensures a seamless, rapid flow of passengers, preventing queues at turnstiles while instantly verifying card validity and sufficient balance.<br> <br>

            <b>The Algorithm: </b><b>Hashing</b> Hashing utilizes a hash table to store the database of millions of active user profiles. The unique ID embedded in the metro card acts as the "key." When a passenger taps their card, a hash function uses this key to compute the exact location of their data in memory.</p>
            <br>

            <div class="image-box">
             <img src="Transport/hash.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Preprocessing (LPS)</td>
      <td>O(M)</td>
      <td>O(M)</td>
      <td>O(M)</td>
    </tr>

    <tr>
      <td>Pattern Search</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
#include &lt;limits&gt;

using namespace std;

ofstream fout("output.txt");

const int MAXN = 1000;
const int MAXE = 5000;
const int HASH_SIZE = 4096;
const int INF = 1000000000;

/* Read next token from input into buf; returns false on EOF */
bool nextToken(string &amp;buf) {
    if (!(cin &gt;&gt; buf)) return false;
    return true;
}

/* Find the next occurrence of heading token `expected`.
   Returns true if found, false on EOF.
   This will skip any stray tokens until the heading is seen.
*/
bool findHeading(const char *expected) {
    string tok;
    while (nextToken(tok)) {
        if (tok == expected) return true;
        // keep scanning
    }
    return false;
}

/* ---------------- Graph (arrays adjacency list) ---------------- */
int head[MAXN], toE[MAXE], costE[MAXE], nextE[MAXE], edgeCnt;
int nStations;

void initGraph(int n) {
    nStations = n;
    edgeCnt = 0;
    for (int i = 0; i &lt;= n; ++i) head[i] = -1;
}

void addEdge(int u, int v, int w) {
    if (edgeCnt &gt;= MAXE) return;
    toE[edgeCnt] = v;
    costE[edgeCnt] = w;
    nextE[edgeCnt] = head[u];
    head[u] = edgeCnt++;
}

/* ---------------- Dijkstra (O(n^2)) ---------------- */
int distArr[MAXN], parentArr[MAXN];
bool used[MAXN];

void dijkstra(int src) {
    for (int i = 1; i &lt;= nStations; ++i) {
        distArr[i] = INF;
        parentArr[i] = -1;
        used[i] = false;
    }
    if (src &lt; 1 || src &gt; nStations) return;
    distArr[src] = 0;
    for (int it = 1; it &lt;= nStations; ++it) {
        int v = -1, best = INF;
        for (int i = 1; i &lt;= nStations; ++i)
            if (!used[i] &amp;&amp; distArr[i] &lt; best) { best = distArr[i]; v = i; }
        if (v == -1) break;
        used[v] = true;
        for (int e = head[v]; e != -1; e = nextE[e]) {
            int to = toE[e], w = costE[e];
            if (distArr[v] + w &lt; distArr[to]) {
                distArr[to] = distArr[v] + w;
                parentArr[to] = v;
            }
        }
    }
}

void printPathToOutput(int dest) {
    if (dest &lt; 1 || dest &gt; nStations) {
        fout &lt;&lt; "Destination " &lt;&lt; dest &lt;&lt; " out of range\n";
        return;
    }
    if (distArr[dest] &gt;= INF) {
        fout &lt;&lt; "No path\n";
        return;
    }
    int tmp[MAXN], c = 0;
    int cur = dest;
    while (cur != -1) { tmp[c++] = cur; cur = parentArr[cur]; }
    fout &lt;&lt; "Shortest time: " &lt;&lt; distArr[dest] &lt;&lt; "\n";
    fout &lt;&lt; "Path: ";
    for (int i = c - 1; i &gt;= 0; --i) {
        fout &lt;&lt; tmp[i];
        if (i) fout &lt;&lt; " -&gt; ";
    }
    fout &lt;&lt; "\n";
}

/* ---------------- AVL Tree (schedules) ---------------- */
struct AVL { int key, height; AVL *left, *right; AVL(int k=0):key(k),height(1),left(NULL),right(NULL){} };
int h_of(AVL* r){ return r? r-&gt;height : 0; }
void fixh(AVL* r){ if (r) r-&gt;height = 1 + max(h_of(r-&gt;left), h_of(r-&gt;right)); }
int bal_of(AVL* r){ return r? h_of(r-&gt;left) - h_of(r-&gt;right) : 0; }

AVL* rotR(AVL* y){ AVL* x=y-&gt;left; y-&gt;left=x-&gt;right; x-&gt;right=y; fixh(y); fixh(x); return x; }
AVL* rotL(AVL* x){ AVL* y=x-&gt;right; x-&gt;right=y-&gt;left; y-&gt;left=x; fixh(x); fixh(y); return y; }

AVL* balanceAVL(AVL* r){
    if (!r) return r;
    fixh(r);
    int b = bal_of(r);
    if (b &gt; 1) { if (bal_of(r-&gt;left) &lt; 0) r-&gt;left = rotL(r-&gt;left); return rotR(r); }
    if (b &lt; -1) { if (bal_of(r-&gt;right) &gt; 0) r-&gt;right = rotR(r-&gt;right); return rotL(r); }
    return r;
}
AVL* insertAVL(AVL* r, int k){ if (!r) return new AVL(k); if (k &lt; r-&gt;key) r-&gt;left = insertAVL(r-&gt;left,k); else if (k &gt; r-&gt;key) r-&gt;right = insertAVL(r-&gt;right,k); return balanceAVL(r); }
AVL* getMin(AVL* r){ return r-&gt;left?getMin(r-&gt;left):r; }
AVL* removeMin(AVL* r){ if (!r-&gt;left) return r-&gt;right; r-&gt;left = removeMin(r-&gt;left); return balanceAVL(r); }
AVL* removeAVL(AVL* r, int k){
    if (!r) return NULL;
    if (k &lt; r-&gt;key) r-&gt;left = removeAVL(r-&gt;left,k);
    else if (k &gt; r-&gt;key) r-&gt;right = removeAVL(r-&gt;right,k);
    else {
        AVL* L = r-&gt;left; AVL* R = r-&gt;right; delete r;
        if (!R) return L;
        AVL* m = getMin(R);
        m-&gt;right = removeMin(R);
        m-&gt;left = L;
        return balanceAVL(m);
    }
    return balanceAVL(r);
}
int findNextAVL(AVL* r, int t){ int ans=-1; while(r){ if(r-&gt;key&gt;=t){ ans=r-&gt;key; r=r-&gt;left; } else r=r-&gt;right; } return ans; }

/* ---------------- Fenwick (crowd) ---------------- */
struct Fenwick { int n; int bit[MAXN]; void init(int _n){ n=_n; for(int i=0;i&lt;=n;i++) bit[i]=0; } void add(int i,int v){ for(;i&lt;=n;i+=i&amp;-i) bit[i]+=v; } int sum(int i){ int s=0; for(;i&gt;0;i-=i&amp;-i) s+=bit[i]; return s; } } fenw;

/* ---------------- Hash (cards) ---------------- */
struct Card { unsigned long long id; int bal; bool used; bool deleted; Card(){ id=0; bal=0; used=false; deleted=false; } };
Card HT[HASH_SIZE];
unsigned int mixhash(unsigned long long x){ x=(~x)+(x&lt;&lt;21); x=x^(x&gt;&gt;24); x=(x+(x&lt;&lt;3))+(x&lt;&lt;8); x=x^(x&gt;&gt;14); x=(x+(x&lt;&lt;2))+(x&lt;&lt;4); x=x^(x&gt;&gt;28); x=x+(x&lt;&lt;31); return (unsigned int)(x &amp; (HASH_SIZE-1)); }
void hashInsert(unsigned long long id,int bal){ unsigned int idx = mixhash(id); for(int i=0;i&lt;HASH_SIZE;i++){ unsigned int p=(idx+i)&amp;(HASH_SIZE-1); if(!HT[p].used || HT[p].deleted){ HT[p].used=true; HT[p].deleted=false; HT[p].id=id; HT[p].bal=bal; return; } } }
int hashFind(unsigned long long id){ unsigned int idx=mixhash(id); for(int i=0;i&lt;HASH_SIZE;i++){ unsigned int p=(idx+i)&amp;(HASH_SIZE-1); if(!HT[p].used &amp;&amp; !HT[p].deleted) return -1; if(HT[p].used &amp;&amp; !HT[p].deleted &amp;&amp; HT[p].id==id) return p; } return -1; }

/* ---------------- MAIN ---------------- */
int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    string tok;

    // --- GRAPH ---
    if (!findHeading("GRAPH")) { fout &lt;&lt; "GRAPH heading not found\n"; fout.close(); return 0; }
    int m;
    if (!(cin &gt;&gt; nStations &gt;&gt; m)) { fout &lt;&lt; "Bad graph header\n"; fout.close(); return 0; }
    if (nStations &lt; 1 || nStations &gt;= MAXN) { fout &lt;&lt; "nStations out of range\n"; fout.close(); return 0; }
    initGraph(nStations);

    for (int i = 0; i &lt; m; ++i) {
        int u,v,w;
        if (!(cin &gt;&gt; u &gt;&gt; v &gt;&gt; w)) { fout &lt;&lt; "Unexpected EOF while reading edges\n"; fout.close(); return 0; }
        if (u &lt; 1 || u &gt; nStations || v &lt; 1 || v &gt; nStations) {
            fout &lt;&lt; "Ignoring invalid edge: " &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; "\n";
            continue;
        }
        addEdge(u,v,w); addEdge(v,u,w);
    }

    // --- DIJKSTRA ---
    if (!findHeading("DIJKSTRA")) { fout &lt;&lt; "DIJKSTRA heading not found\n"; fout.close(); return 0; }
    int dq; if (!(cin &gt;&gt; dq)) { fout &lt;&lt; "Bad Dijkstra count\n"; fout.close(); return 0; }
    fout &lt;&lt; "--- DIJKSTRA (Route Planning) ---\n";
    if (dq &lt; 0 || dq &gt; 100000) { fout &lt;&lt; "Invalid Dijkstra count\n"; fout.close(); return 0; }
    for (int i = 0; i &lt; dq; ++i) {
        int s,d;
        if (!(cin &gt;&gt; s &gt;&gt; d)) { fout &lt;&lt; "Unexpected EOF in Dijkstra queries\n"; fout.close(); return 0; }
        if (s &lt; 1 || s &gt; nStations || d &lt; 1 || d &gt; nStations) {
            fout &lt;&lt; "Invalid Dijkstra query: " &lt;&lt; s &lt;&lt; " " &lt;&lt; d &lt;&lt; "\n-----\n";
            continue;
        }
        dijkstra(s);
        printPathToOutput(d);
        fout &lt;&lt; "-----\n";
    }

    // --- SCHEDULE ---
    if (!findHeading("SCHEDULE")) { fout &lt;&lt; "Missing SCHEDULE heading\n"; fout.close(); return 0; }
    fout &lt;&lt; "\n--- TRAIN SCHEDULING (AVL) ---\n";
    int k; if (!(cin &gt;&gt; k)) { fout &lt;&lt; "Bad schedule count\n"; fout.close(); return 0; }
    if (k &lt; 0 || k &gt; 100000) { fout &lt;&lt; "Invalid schedule count\n"; fout.close(); return 0; }
    AVL* root = NULL;
    for (int i = 0; i &lt; k; ++i) { int t; if (!(cin &gt;&gt; t)) { fout &lt;&lt; "Unexpected EOF reading schedule times\n"; fout.close(); return 0; } root = insertAVL(root, t); }

    int sops; if (!(cin &gt;&gt; sops)) { fout &lt;&lt; "Bad schedule ops count\n"; fout.close(); return 0; }
    for (int i = 0; i &lt; sops; ++i) {
        string op; int t;
        if (!(cin &gt;&gt; op &gt;&gt; t)) { fout &lt;&lt; "Unexpected EOF reading schedule ops\n"; fout.close(); return 0; }
        if (op == "ADD") { root = insertAVL(root, t); fout &lt;&lt; "Added departure " &lt;&lt; t &lt;&lt; "\n"; }
        else if (op == "DEL") { root = removeAVL(root, t); fout &lt;&lt; "Removed departure " &lt;&lt; t &lt;&lt; "\n"; }
        else if (op == "NEXT") { int nx = findNextAVL(root, t); if (nx == -1) fout &lt;&lt; "No departure &gt;= " &lt;&lt; t &lt;&lt; "\n"; else fout &lt;&lt; "Next departure &gt;= " &lt;&lt; t &lt;&lt; " is " &lt;&lt; nx &lt;&lt; "\n"; }
        else fout &lt;&lt; "Unknown schedule op: " &lt;&lt; op &lt;&lt; "\n";
    }

    // --- FENWICK ---
    if (!findHeading("FENWICK")) { fout &lt;&lt; "Missing FENWICK heading\n"; fout.close(); return 0; }
    fout &lt;&lt; "\n--- PASSENGER LOAD (Fenwick) ---\n";
    int S; if (!(cin &gt;&gt; S)) { fout &lt;&lt; "Bad Fenwick station count\n"; fout.close(); return 0; }
    if (S &lt; 1 || S &gt;= MAXN) { fout &lt;&lt; "Fenwick count out of range\n"; fout.close(); return 0; }
    fenw.init(S);
    for (int i = 1; i &lt;= S; ++i) { int iv; if (!(cin &gt;&gt; iv)) { fout &lt;&lt; "Unexpected EOF reading Fenwick initial data\n"; fout.close(); return 0; } if (iv) fenw.add(i, iv); }
    int fops; if (!(cin &gt;&gt; fops)) { fout &lt;&lt; "Bad Fenwick ops count\n"; fout.close(); return 0; }
    for (int i = 0; i &lt; fops; ++i) {
        string op; if (!(cin &gt;&gt; op)) { fout &lt;&lt; "Unexpected EOF reading Fenwick ops\n"; fout.close(); return 0; }
        if (op == "BOARD") { int idx,c; cin &gt;&gt; idx &gt;&gt; c; if (idx&gt;=1 &amp;&amp; idx&lt;=S){ fenw.add(idx,c); fout &lt;&lt; "Boarded " &lt;&lt; c &lt;&lt; " at " &lt;&lt; idx &lt;&lt; "\n"; } else fout &lt;&lt; "Invalid BOARD idx " &lt;&lt; idx &lt;&lt; "\n"; }
        else if (op == "ALIGHT") { int idx,c; cin &gt;&gt; idx &gt;&gt; c; if (idx&gt;=1 &amp;&amp; idx&lt;=S){ fenw.add(idx,-c); fout &lt;&lt; "Alighted " &lt;&lt; c &lt;&lt; " at " &lt;&lt; idx &lt;&lt; "\n"; } else fout &lt;&lt; "Invalid ALIGHT idx " &lt;&lt; idx &lt;&lt; "\n"; }
        else if (op == "QUERY") { int idx; cin &gt;&gt; idx; if (idx&gt;=1 &amp;&amp; idx&lt;=S) fout &lt;&lt; "Passengers up to " &lt;&lt; idx &lt;&lt; ": " &lt;&lt; fenw.sum(idx) &lt;&lt; "\n"; else fout &lt;&lt; "Invalid QUERY idx " &lt;&lt; idx &lt;&lt; "\n"; }
        else fout &lt;&lt; "Unknown Fenwick op: " &lt;&lt; op &lt;&lt; "\n";
    }

    // --- CARDS ---
    if (!findHeading("CARDS")) { fout &lt;&lt; "Missing CARDS heading\n"; fout.close(); return 0; }
    fout &lt;&lt; "\n--- TICKETING &amp; VALIDATION (Hash) ---\n";
    int c; if (!(cin &gt;&gt; c)) { fout &lt;&lt; "Bad cards count\n"; fout.close(); return 0; }
    for (int i = 0; i &lt; HASH_SIZE; ++i) HT[i] = Card();
    for (int i = 0; i &lt; c; ++i) { unsigned long long id; int bal; if (!(cin &gt;&gt; id &gt;&gt; bal)) { fout &lt;&lt; "Unexpected EOF reading cards\n"; fout.close(); return 0; } hashInsert(id, bal); }

    // --- TAPS ---
    if (!findHeading("TAPS")) { fout &lt;&lt; "Missing TAPS heading\n"; fout.close(); return 0; }
    int taps; if (!(cin &gt;&gt; taps)) { fout &lt;&lt; "Bad taps count\n"; fout.close(); return 0; }
    for (int i = 0; i &lt; taps; ++i) {
        unsigned long long id; int fare; if (!(cin &gt;&gt; id &gt;&gt; fare)) { fout &lt;&lt; "Unexpected EOF reading taps\n"; fout.close(); return 0; }
        int idx = hashFind(id);
        if (idx == -1) fout &lt;&lt; "Card " &lt;&lt; id &lt;&lt; " : NOT FOUND\n";
        else if (HT[idx].bal &lt; fare) fout &lt;&lt; "Card " &lt;&lt; id &lt;&lt; " : INSUFFICIENT BALANCE (balance=" &lt;&lt; HT[idx].bal &lt;&lt; ", fare=" &lt;&lt; fare &lt;&lt; ")\n";
        else { HT[idx].bal -= fare; fout &lt;&lt; "Card " &lt;&lt; id &lt;&lt; " : TAPPED OK, new balance=" &lt;&lt; HT[idx].bal &lt;&lt; "\n"; }
    }

    fout.close();
    return 0;
}
    </div>

    <div class="data-input">


      GRAPH
50 120
1 2 5
1 3 4
1 10 8
2 4 7
2 5 9
3 6 6
3 7 8
4 8 5
4 9 7
5 10 4
5 11 6
6 12 9
6 13 7
7 14 6
7 15 8
8 16 5
9 17 7
10 18 6
11 19 9
12 20 5
13 21 8
14 22 7
15 23 6
16 24 9
17 25 6
18 26 7
19 27 8
20 28 9
21 29 5
22 30 7
23 31 6
24 32 8
25 33 5
26 34 7
27 35 9
28 36 6
29 37 8
30 38 7
31 39 6
32 40 9
33 41 5
34 42 7
35 43 8
36 44 9
37 45 6
38 46 8
39 47 7
40 48 5
41 49 9
42 50 7
3 8 12
3 11 10
4 12 14
6 10 9
8 14 13
9 16 12
10 17 10
12 18 11
13 19 10
15 21 14
17 22 13
20 26 10
21 28 12
23 29 11
25 31 15
26 33 13
28 34 14
30 36 10
32 38 12
33 40 14
35 41 13
37 42 14
39 44 15
40 46 9
41 47 10
43 48 11
45 49 12
46 50 9
11 14 10
12 15 11
13 16 12
14 17 13
15 18 9
16 19 14
17 20 12
18 21 11
19 22 10
20 23 9
21 24 8
22 25 7
23 26 6
24 27 5
26 28 9
27 29 10
28 30 11
29 31 12
30 32 13
31 33 14
32 34 15
33 35 7
34 36 6
36 38 9
38 40 12
39 41 14
40 42 10
41 43 6
42 44 8
44 46 9
45 47 10
47 49 8
48 50 9
49 50 5
50 48 7
45 48 6
43 46 9
37 39 8
12 30 15
13 29 14
18 34 12
15 37 13
10 33 11
5 28 9
2 21 10
8 27 12
9 32 14
4 23 8
3 18 9
6 22 11
1 17 10
7 25 13
11 30 12
12 33 10
18 40 14
25 45 9
29 47 8
16 26 10

DIJKSTRA
5
1 50
3 28
10 40
12 45
25 41

SCHEDULE
15
360 400 430 450 480 500 520 540 560 600 620 650 700 730 760
10
NEXT 455
ADD 465
NEXT 450
DEL 520
NEXT 520
NEXT 800
ADD 810
NEXT 700
DEL 560
NEXT 560

FENWICK
50
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
15
BOARD 1 120
BOARD 10 50
QUERY 10
ALIGHT 1 20
BOARD 50 80
QUERY 50
BOARD 25 40
ALIGHT 10 20
QUERY 25
BOARD 30 60
ALIGHT 25 30
QUERY 30
BOARD 40 50
ALIGHT 40 25
QUERY 40

CARDS
10
123456789001 600
123456789002 300
123456789003 450
123456789004 50
123456789005 900
123456789006 100
123456789007 200
123456789008 1200
123456789009 750
123456789010 500

TAPS
10
123456789001 50
123456789004 40
123456789007 100
123456789002 60
123456789011 20
123456789009 200
123456789010 300
123456789003 100
123456789008 250
123456789050 10

    </div>

    <div class="data-output">
      --- DIJKSTRA (Route Planning) ---
Shortest time: 40
Path: 1 -> 10 -> 18 -> 34 -> 42 -> 50
-----
Shortest time: 29
Path: 3 -> 6 -> 12 -> 20 -> 28
-----
Shortest time: 35
Path: 10 -> 17 -> 25 -> 33 -> 40
-----
Shortest time: 30
Path: 12 -> 15 -> 37 -> 45
-----
Shortest time: 10
Path: 25 -> 33 -> 41
-----

--- TRAIN SCHEDULING (AVL) ---
Next departure >= 455 is 480
Added departure 465
Next departure >= 450 is 450
Removed departure 520
Next departure >= 520 is 540
No departure >= 800
Added departure 810
Next departure >= 700 is 700
Removed departure 560
Next departure >= 560 is 600

--- PASSENGER LOAD (Fenwick) ---
Boarded 120 at 1
Boarded 50 at 10
Passengers up to 10: 170
Alighted 20 at 1
Boarded 80 at 50
Passengers up to 50: 230
Boarded 40 at 25
Alighted 20 at 10
Passengers up to 25: 170
Boarded 60 at 30
Alighted 30 at 25
Passengers up to 30: 200
Boarded 50 at 40
Alighted 25 at 40
Passengers up to 40: 225

--- TICKETING & VALIDATION (Hash) ---
Card 123456789001 : TAPPED OK, new balance=550
Card 123456789004 : TAPPED OK, new balance=10
Card 123456789007 : TAPPED OK, new balance=100
Card 123456789002 : TAPPED OK, new balance=240
Card 123456789011 : NOT FOUND
Card 123456789009 : TAPPED OK, new balance=550
Card 123456789010 : TAPPED OK, new balance=200
Card 123456789003 : TAPPED OK, new balance=350
Card 123456789008 : TAPPED OK, new balance=950
Card 123456789050 : NOT FOUND

    </div>
</div>






        </div>

        <div class="content-box">
            <h3>Medical Green Corridors</h3>
            <div class="rule"></div>
            <p>A Medical Green Corridor is a special, high-priority, traffic-free route created to transport organs, critical medical supplies, or emergency patients from one point to another in the shortest possible time.<br>Traffic police, hospitals, and ambulance control rooms coordinate to create a fast, uninterrupted pathway by adjusting traffic signals and clearing roads.It requires real-time decision-making, routing, monitoring, and communication—making it perfect for demonstrating algorithms.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>3, 9, 11</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Transport/sequence2.png" class="sequence">

            <p><b>Route Planning & Shortest Travel Time: </b>Find the fastest path for an ambulance considering real-time traffic.<br> <br>

            <b>The Algorithm: </b><b>Dijkstra’s Algorithm</b> Calculates the path with the lowest total travel time by exploring routes from the starting point.</p>
            <br>

            <div class="image-box">
             <img src="Transport/dij2.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Extract-Min Operations</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
    </tr>

    <tr>
      <td>Decrease-Key Operations</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
    </tr>
  </table>


             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Resource Allocation & Scheduling: </b>Prioritize emergency requests and dispatch the nearest appropriate resources (ambulances, teams).<br> <br>

            <b>The Algorithm: </b><b>Merge/Quick Sort</b> Rapidly sorts incoming requests by medical severity to prioritize critical cases.</p>
            <br>

            <div class="image-box">
             <img src="Transport/sort.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Divide Step</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Merge Step</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Traffic Signal Optimization & Clearance: </b>Create a synchronized "green wave" of traffic lights along the ambulance's route.<br> <br>

            <b>The Algorithm: </b><b>BFS</b> Explores intersections layer by layer ahead of the ambulance to preemptively clear the path.</p>
            <br>

            <div class="image-box">
             <img src="Transport/bfs.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Visit Vertices</td>
      <td>O(V)</td>
      <td>O(V)</td>
      <td>O(V)</td>
    </tr>

    <tr>
      <td>Traverse Edges</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Live Monitoring & Emergency Handling: </b>Detect unexpected blockages on the route and quickly find alternative paths.<br> <br>

            <b>The Algorithm: </b><b>DFS</b> Deeply explores specific detour options to find a viable workaround when the primary route fails.</p>
            <br>

            <div class="image-box">
             <img src="Transport/dfs.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Visit Vertices</td>
      <td>O(V)</td>
      <td>O(V)</td>
      <td>O(V)</td>
    </tr>

    <tr>
      <td>Traverse Edges</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
<pre><code>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
#include &lt;limits&gt;

using namespace std;

ofstream fout("output.txt");

const int MAXN = 1000;
const int MAXE = 5000;
const int INF = 1000000000;

/* -------------------- Utility Input Functions -------------------- */
bool nextToken(string &amp;buf) {
    if (!(cin &gt;&gt; buf)) return false;
    return true;
}

bool findHeading(const char *expected) {
    string tok;
    while (nextToken(tok)) {
        if (tok == expected) return true;
    }
    return false;
}

/* -------------------- GRAPH (Adjacency List Arrays) -------------------- */
int head[MAXN], toE[MAXE], costE[MAXE], nextE[MAXE], edgeCnt, nNodes;

void initGraph(int n) {
    nNodes = n;
    edgeCnt = 0;
    for (int i = 1; i &lt;= n; i++) head[i] = -1;
}

void addEdge(int u, int v, int w) {
    toE[edgeCnt] = v;
    costE[edgeCnt] = w;
    nextE[edgeCnt] = head[u];
    head[u] = edgeCnt++;
}

/* -------------------- DIJKSTRA (Shortest Travel Time) -------------------- */
int distArr[MAXN], parentArr[MAXN];
bool used[MAXN];

void dijkstra(int src) {
    for (int i = 1; i &lt;= nNodes; i++) {
        distArr[i] = INF;
        parentArr[i] = -1;
        used[i] = false;
    }
    distArr[src] = 0;

    for (int it = 1; it &lt;= nNodes; it++) {
        int v = -1, best = INF;
        for (int i = 1; i &lt;= nNodes; i++)
            if (!used[i] &amp;&amp; distArr[i] &lt; best) {
                best = distArr[i];
                v = i;
            }
        if (v == -1) break;
        used[v] = true;

        for (int e = head[v]; e != -1; e = nextE[e]) {
            int to = toE[e], w = costE[e];
            if (distArr[v] + w &lt; distArr[to]) {
                distArr[to] = distArr[v] + w;
                parentArr[to] = v;
            }
        }
    }
}

void printPath(int dest) {
    if (distArr[dest] &gt;= INF) {
        fout &lt;&lt; "No route available\n";
        return;
    }
    int tmp[MAXN], c = 0;
    int cur = dest;
    while (cur != -1) {
        tmp[c++] = cur;
        cur = parentArr[cur];
    }
    fout &lt;&lt; "Travel Time: " &lt;&lt; distArr[dest] &lt;&lt; "\n";
    fout &lt;&lt; "Route: ";
    for (int i = c - 1; i &gt;= 0; i--) {
        fout &lt;&lt; tmp[i];
        if (i) fout &lt;&lt; " -&gt; ";
    }
    fout &lt;&lt; "\n";
}

/* -------------------- MERGE SORT (Emergency Severity) -------------------- */
int severity[2000], tempA[2000];

void mergeArr(int l, int m, int r) {
    int i = l, j = m + 1, k = l;
    while (i &lt;= m &amp;&amp; j &lt;= r) {
        if (severity[i] &gt;= severity[j]) tempA[k++] = severity[i++];
        else tempA[k++] = severity[j++];
    }
    while (i &lt;= m) tempA[k++] = severity[i++];
    while (j &lt;= r) tempA[k++] = severity[j++];
    for (int x = l; x &lt;= r; x++) severity[x] = tempA[x];
}

void mergeSort(int l, int r) {
    if (l &gt;= r) return;
    int m = (l + r) / 2;
    mergeSort(l, m);
    mergeSort(m + 1, r);
    mergeArr(l, m, r);
}

/* -------------------- BFS (Traffic Signal Clearance) -------------------- */
bool visitedBFS[MAXN];
int queueBFS[MAXN];

void BFS(int start) {
    for (int i = 1; i &lt;= nNodes; i++) visitedBFS[i] = false;

    int front = 0, back = 0;
    queueBFS[back++] = start;
    visitedBFS[start] = true;

    fout &lt;&lt; "Intersections Cleared: ";

    while (front &lt; back) {
        int v = queueBFS[front++];
        fout &lt;&lt; v &lt;&lt; " ";

        for (int e = head[v]; e != -1; e = nextE[e]) {
            int to = toE[e];
            if (!visitedBFS[to]) {
                visitedBFS[to] = true;
                queueBFS[back++] = to;
            }
        }
    }
    fout &lt;&lt; "\n";
}

/* -------------------- DFS (Detour Finder) -------------------- */
bool visitedDFS[MAXN];

void DFS_rec(int v) {
    visitedDFS[v] = true;
    fout &lt;&lt; v &lt;&lt; " ";
    for (int e = head[v]; e != -1; e = nextE[e]) {
        int to = toE[e];
        if (!visitedDFS[to]) DFS_rec(to);
    }
}

/* -------------------- MAIN -------------------- */
int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    /* -------- GRAPH -------- */
    if (!findHeading("GRAPH")) { fout &lt;&lt; "GRAPH missing\n"; return 0; }
    int edges;
    cin &gt;&gt; nNodes &gt;&gt; edges;
    initGraph(nNodes);
    for (int i = 0; i &lt; edges; i++) {
        int u, v, w;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        addEdge(u, v, w);
        addEdge(v, u, w);
    }

    /* -------- DIJKSTRA -------- */
    if (!findHeading("DIJKSTRA")) { fout &lt;&lt; "DIJKSTRA missing\n"; return 0; }
    fout &lt;&lt; "\n--- ROUTE PLANNING (Dijkstra) ---\n";
    int q;
    cin &gt;&gt; q;
    while (q--) {
        int s, d;
        cin &gt;&gt; s &gt;&gt; d;
        dijkstra(s);
        printPath(d);
        fout &lt;&lt; "-----\n";
    }

    /* -------- MERGE SORT EMERGENCY REQUESTS -------- */
    if (!findHeading("SEVERITY")) { fout &lt;&lt; "SEVERITY missing\n"; return 0; }
    fout &lt;&lt; "\n--- EMERGENCY PRIORITIZATION (Merge Sort) ---\n";

    int k;
    cin &gt;&gt; k;
    for (int i = 0; i &lt; k; i++) cin &gt;&gt; severity[i];

    mergeSort(0, k - 1);

    fout &lt;&lt; "Sorted Severity (High &rarr; Low): ";
    for (int i = 0; i &lt; k; i++) fout &lt;&lt; severity[i] &lt;&lt; " ";
    fout &lt;&lt; "\n";

    /* -------- BFS SIGNAL CLEARING -------- */
    if (!findHeading("BFS")) { fout &lt;&lt; "BFS missing\n"; return 0; }
    fout &lt;&lt; "\n--- TRAFFIC CLEARANCE (BFS) ---\n";
    int st;
    cin &gt;&gt; st;
    BFS(st);

    /* -------- DFS DETOUR SEARCH -------- */
    if (!findHeading("DFS")) { fout &lt;&lt; "DFS missing\n"; return 0; }
    fout &lt;&lt; "\n--- DETOUR SEARCH (DFS) ---\n";
    int dt;
    cin &gt;&gt; dt;
    for (int i = 1; i &lt;= nNodes; i++) visitedDFS[i] = false;
    DFS_rec(dt);
    fout &lt;&lt; "\n";

    fout.close();
    return 0;
}
</code></pre>
    </div>

    <div class="data-input">
GRAPH
50 120
1 2 5
1 3 4
1 10 8
2 4 7
2 5 9
3 6 6
3 7 8
4 8 5
4 9 7
5 10 4
5 11 6
6 12 9
6 13 7
7 14 6
7 15 8
8 16 5
9 17 7
10 18 6
11 19 9
12 20 5
13 21 8
14 22 7
15 23 6
16 24 9
17 25 6
18 26 7
19 27 8
20 28 9
21 29 5
22 30 7
23 31 6
24 32 8
25 33 5
26 34 7
27 35 9
28 36 6
29 37 8
30 38 7
31 39 6
32 40 9
33 41 5
34 42 7
35 43 8
36 44 9
37 45 6
38 46 8
39 47 7
40 48 5
41 49 9
42 50 7
3 8 12
3 11 10
4 12 14
6 10 9
8 14 13
9 16 12
10 17 10
12 18 11
13 19 10
15 21 14
17 22 13
20 26 10
21 28 12
23 29 11
25 31 15
26 33 13
28 34 14
30 36 10
32 38 12
33 40 14
35 41 13
37 42 14
39 44 15
40 46 9
41 47 10
43 48 11
45 49 12
46 50 9
11 14 10
12 15 11
13 16 12
14 17 13
15 18 9
16 19 14
17 20 12
18 21 11
19 22 10
20 23 9
21 24 8
22 25 7
23 26 6
24 27 5
26 28 9
27 29 10
28 30 11
29 31 12
30 32 13
31 33 14
32 34 15
33 35 7
34 36 6
36 38 9
38 40 12
39 41 14
40 42 10
41 43 6
42 44 8
44 46 9
45 47 10
47 49 8
48 50 9
49 50 5
50 48 7
45 48 6
43 46 9
37 39 8
12 30 15
13 29 14
18 34 12
15 37 13
10 33 11
5 28 9
2 21 10
8 27 12
9 32 14
4 23 8
3 18 9
6 22 11
1 17 10
7 25 13
11 30 12
12 33 10
18 40 14
25 45 9
29 47 8
16 26 10

DIJKSTRA
5
1 50
3 28
10 40
12 45
25 41

SEVERITY
10
5 9 2 8 7 10 6 3 9 4

BFS
1

DFS
10
    </div>

    <div class="data-output">
--- ROUTE PLANNING (Dijkstra) ---
Travel Time: 40
Route: 1 -> 10 -> 18 -> 34 -> 42 -> 50
-----
Travel Time: 29
Route: 3 -> 6 -> 12 -> 20 -> 28
-----
Travel Time: 35
Route: 10 -> 17 -> 25 -> 33 -> 40
-----
Travel Time: 30
Route: 12 -> 15 -> 37 -> 45
-----
Travel Time: 10
Route: 25 -> 33 -> 41
-----

--- EMERGENCY PRIORITIZATION (Merge Sort) ---
Sorted Severity (High → Low): 10 9 9 8 7 6 5 4 3 2 

--- TRAFFIC CLEARANCE (BFS) ---
Intersections Cleared: 1 10 3 2 17 6 18 5 11 8 7 4 20 14 22 25 9 13 12 34 21 15 26 19 16 23 28 30 31 33 29 36 32 42 24 37 27 38 39 35 40 41 44 50 45 46 47 43 48 49 

--- DETOUR SEARCH (DFS) ---
10 17 20 23 26 28 30 12 15 37 39 41 43 46 44 42 40 38 36 34 18 21 24 27 29 13 16 19 22 25 31 33 35 14 11 3 8 4 9 2 5 1 7 6 32 48 45 47 49 50 
    </div>
</div>

            



        </div>

        

        </div>

        
        
        <h2 class="section-heading">Semiconductor R&D</h2>

        <div class="content-box-container">

            <div class="content-box">
            <h3>Chip Design & Architecture Development</h3>

            <div class="rule"></div>
            <p>Chip design and architecture development is the process of creating semiconductor chips that power devices like computers, mobiles, electric vehicles, and IoT systems.
            It involves planning the architecture, designing logic circuits, optimizing layouts, routing connections, and ensuring efficiency, speed, and thermal stability.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>8, 9, 12</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Semiconductor/sequence1.png" class="sequence">

            <p><b>Architecture Planning: </b>Find the optimal arrangement of major functional blocks on the chip die to fit constraints and maximize performance.<br> <br>

            <b>The Algorithm: </b><b>Backtracking</b> Explores potential placement configurations on a grid; if a placement violates design rules, it backtracks to try alternative arrangements until a valid layout is found.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/backtrack.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Constraint Check</td>
      <td>O(1)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>State Space Traversal</td>
      <td>O(N)</td>
      <td>O(b^N)</td>
      <td>O(b^N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N)</td>
      <td>O(b^N)</td>
      <td>O(b^N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Logic Circuit Verification: </b>Ensure the digital logic circuits function correctly by checking for connectivity errors, loops, or faults before manufacturing.<br> <br>

            <b>The Algorithm: </b><b>DFS (Depth-First Search)</b> Treats the circuit as a graph, diving deep along signal paths from inputs to outputs to exhaustively test logic states and ensure complete connectivity.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/dfs.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Visit Vertices</td>
      <td>O(V)</td>
      <td>O(V)</td>
      <td>O(V)</td>
    </tr>

    <tr>
      <td>Traverse Edges</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Physical Layout & Routing: </b>Connect all chip components with the minimum total length of wiring to reduce signal delay and power consumption.<br> <br>

            <b>The Algorithm: </b><b>Kruskal’s Minimum Spanning Tree</b> Selects the shortest necessary wiring paths between components to create a complete network connection without redundant loops, minimizing overall wire usage.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/kruskal.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Sorting Edges</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>

    <tr>
      <td>Union–Find Operations</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>
  </table>

  
                



             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Performance & Thermal Optimization: </b>Analyze massive simulation datasets to identify critical performance bottlenecks and high-temperature areas (hotspots) on the chip.<br> <br>

            <b>The Algorithm: </b><b>Merge Sort</b> Efficiently sorts huge volumes of simulation data (like timing delays or temperature readings) to quickly isolate the worst-case scenarios requiring optimization.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/mergesort.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Divide Step</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Merge Step</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
<pre><code>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
#include &lt;limits&gt;

using namespace std;

ofstream fout("output.txt");

/* ----------------------------- BACKTRACKING (Chip Floorplan) ----------------------------- */

const int GRID = 6;
int grid[GRID][GRID];
int blockCount;
int blockW[50], blockH[50];

bool placeable(int r, int c, int w, int h) {
    if (r + h &gt; GRID || c + w &gt; GRID) return false;
    for (int i = r; i &lt; r + h; i++)
        for (int j = c; j &lt; c + w; j++)
            if (grid[i][j] != 0) return false;
    return true;
}

void placeBlock(int r, int c, int w, int h, int id) {
    for (int i = r; i &lt; r + h; i++)
        for (int j = c; j &lt; c + w; j++)
            grid[i][j] = id;
}

void removeBlock(int r, int c, int w, int h) {
    for (int i = r; i &lt; r + h; i++)
        for (int j = c; j &lt; c + w; j++)
            grid[i][j] = 0;
}

bool backtrack(int idx) {
    if (idx == blockCount) return true;

    int w = blockW[idx], h = blockH[idx];

    for (int r = 0; r &lt; GRID; r++) {
        for (int c = 0; c &lt; GRID; c++) {
            if (placeable(r, c, w, h)) {
                placeBlock(r, c, w, h, idx + 1);
                if (backtrack(idx + 1)) return true;
                removeBlock(r, c, w, h);
            }
        }
    }
    return false;
}

/* ----------------------------- DFS (Logic Circuit Verification) ----------------------------- */

const int MAXN = 200;
const int MAXE = 500;

int head[MAXN], toE[MAXE], nextE[MAXE], edgeCnt;
bool visitedDFS[MAXN];

void initGraph(int n) {
    for (int i = 1; i &lt;= n; i++) head[i] = -1;
    edgeCnt = 0;
}

void addEdge(int u, int v) {
    toE[edgeCnt] = v;
    nextE[edgeCnt] = head[u];
    head[u] = edgeCnt++;
}

void dfs(int u) {
    visitedDFS[u] = true;
    fout &lt;&lt; u &lt;&lt; " ";
    for (int e = head[u]; e != -1; e = nextE[e])
        if (!visitedDFS[toE[e]])
            dfs(toE[e]);
}

/* ----------------------------- KRUSKAL (Wiring MST) ----------------------------- */

struct Edge { int u, v, w; } edges2[MAXE];
int parent[MAXN];

int findSet(int x) {
    while (parent[x] != x) x = parent[x];
    return x;
}

void unionSet(int a, int b) {
    a = findSet(a);
    b = findSet(b);
    parent[b] = a;
}

void mergeSortEdges(int l, int r) {
    if (l &gt;= r) return;
    int m = (l + r) / 2;

    mergeSortEdges(l, m);
    mergeSortEdges(m + 1, r);

    Edge temp[1000];
    int i = l, j = m + 1, k = l;

    while (i &lt;= m &amp;&amp; j &lt;= r) {
        if (edges2[i].w &lt; edges2[j].w) temp[k++] = edges2[i++];
        else temp[k++] = edges2[j++];
    }
    while (i &lt;= m) temp[k++] = edges2[i++];
    while (j &lt;= r) temp[k++] = edges2[j++];

    for (int x = l; x &lt;= r; x++) edges2[x] = temp[x];
}

/* ----------------------------- MERGE SORT (Thermal/Delay Data) ----------------------------- */

int dataA[2000], tempA[2000];

void mergeArr(int l, int m, int r) {
    int i = l, j = m + 1, k = l;
    while (i &lt;= m &amp;&amp; j &lt;= r)
        if (dataA[i] &gt;= dataA[j]) tempA[k++] = dataA[i++];
        else tempA[k++] = dataA[j++];
    while (i &lt;= m) tempA[k++] = dataA[i++];
    while (j &lt;= r) tempA[k++] = dataA[j++];
    for (int x = l; x &lt;= r; x++) dataA[x] = tempA[x];
}

void mergeSortData(int l, int r) {
    if (l &gt;= r) return;
    int m = (l + r) / 2;
    mergeSortData(l, m);
    mergeSortData(m + 1, r);
    mergeArr(l, m, r);
}

/* ----------------------------- INPUT SEEK HELPER (SAFE) ----------------------------- */

bool seek(const char *h) {
    string tok;
    while (cin &gt;&gt; tok) {
        if (tok == h) return true;
    }
    return false;
}

/* ----------------------------- MAIN ----------------------------- */

int main() {

    /* ---------------- BACKTRACKING ---------------- */
    if (!seek("BACKTRACK")) { fout &lt;&lt; "BACKTRACK missing\n"; return 0; }

    cin &gt;&gt; blockCount;
    for (int i = 0; i &lt; blockCount; i++) cin &gt;&gt; blockW[i] &gt;&gt; blockH[i];

    for (int r = 0; r &lt; GRID; r++)
        for (int c = 0; c &lt; GRID; c++)
            grid[r][c] = 0;

    fout &lt;&lt; "--- CHIP ARCHITECTURE PLACEMENT (Backtracking) ---\n";
    if (backtrack(0)) {
        fout &lt;&lt; "Valid layout:\n";
        for (int r = 0; r &lt; GRID; r++) {
            for (int c = 0; c &lt; GRID; c++)
                fout &lt;&lt; grid[r][c] &lt;&lt; " ";
            fout &lt;&lt; "\n";
        }
    } else fout &lt;&lt; "No valid layout found.\n";


    /* ---------------- LOGIC DFS ---------------- */
    if (!seek("CIRCUIT")) { fout &lt;&lt; "CIRCUIT missing\n"; return 0; }

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    initGraph(n);

    for (int i = 0; i &lt; m; i++) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        addEdge(u, v);
    }

    fout &lt;&lt; "\n--- LOGIC VERIFICATION (DFS) ---\n";
    for (int i = 1; i &lt;= n; i++) visitedDFS[i] = false;
    dfs(1);
    fout &lt;&lt; "\n";


    /* ---------------- KRUSKAL ---------------- */
    if (!seek("MST")) { fout &lt;&lt; "MST missing\n"; return 0; }

    int e;
    cin &gt;&gt; n &gt;&gt; e;

    for (int i = 1; i &lt;= n; i++) parent[i] = i;

    for (int i = 0; i &lt; e; i++)
        cin &gt;&gt; edges2[i].u &gt;&gt; edges2[i].v &gt;&gt; edges2[i].w;

    mergeSortEdges(0, e - 1);

    fout &lt;&lt; "\n--- PHYSICAL ROUTING (Kruskal MST) ---\n";
    int total = 0;

    for (int i = 0; i &lt; e; i++) {
        int u = edges2[i].u, v = edges2[i].v, w = edges2[i].w;
        if (findSet(u) != findSet(v)) {
            fout &lt;&lt; u &lt;&lt; " - " &lt;&lt; v &lt;&lt; " (" &lt;&lt; w &lt;&lt; ")\n";
            total += w;
            unionSet(u, v);
        }
    }
    fout &lt;&lt; "Total Wire Length = " &lt;&lt; total &lt;&lt; "\n";


    /* ---------------- MERGE SORT DATA ---------------- */
    if (!seek("DATA")) { fout &lt;&lt; "DATA missing\n"; return 0; }

    int k;
    cin &gt;&gt; k;
    for (int i = 0; i &lt; k; i++) cin &gt;&gt; dataA[i];

    mergeSortData(0, k - 1);

    fout &lt;&lt; "\n--- THERMAL/PERFORMANCE SORTING ---\n";
    for (int i = 0; i &lt; k; i++) fout &lt;&lt; dataA[i] &lt;&lt; " ";
    fout &lt;&lt; "\n";

    fout.close();
    return 0;
}
</code></pre>


    </div>

    <div class="data-input">

      BACKTRACK
4
2 2
2 1
1 2
1 1

CIRCUIT
6 6
1 2
2 3
3 4
4 5
5 6
2 6

MST
6 8
1 2 4
1 3 3
2 4 2
2 5 7
3 5 6
4 6 5
5 6 4
3 4 9

DATA
10
25 60 10 45 75 30 90 15 55 40


    </div>

    <div class="data-output">
      
--- CHIP ARCHITECTURE PLACEMENT (Backtracking) ---
Valid layout:
1 1 2 2 3 4 
1 1 0 0 3 0 
0 0 0 0 0 0 
0 0 0 0 0 0 
0 0 0 0 0 0 
0 0 0 0 0 0 

--- LOGIC VERIFICATION (DFS) ---
1 2 6 3 4 5 

--- PHYSICAL ROUTING (Kruskal MST) ---
2 - 4 (2)
1 - 3 (3)
5 - 6 (4)
1 - 2 (4)
4 - 6 (5)
Total Wire Length = 18

--- THERMAL/PERFORMANCE SORTING ---
90 75 60 55 45 40 30 25 15 10 



    </div>
</div>

            



        </div>
            <div class="content-box">
            <h3>Wafer Fabrication & Defect Detection</h3>

            <div class="rule"></div>
            <p>Wafer fabrication is the process of creating semiconductor chips on ultra-pure silicon wafers through nanometer-level layering, etching, doping, and lithography.
           <br>After each stage, wafers are inspected because even a tiny particle, scratch, or pattern mismatch can destroy thousands of chips.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>4, 8, 9, 11, 12</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Semiconductor/sequence2.png" class="sequence">

            <p><b>Wafer Layer Formation & Lithography Planning: </b>Determine the optimal sequence of processing steps (layer deposition, patterning, etching) to construct the complex 3D chip structure without violating any design rules.<br> <br>

            <b>The Algorithm: </b><b>Backtracking</b> Systematically builds a sequence of process steps. If a proposed step is found to violate a design constraint (e.g., creates an impossible feature size), the algorithm backtracks to the previous valid step and tries a different parameter or process to find a workable fabrication sequence.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/backtrack2.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Constraint Check</td>
      <td>O(1)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>State Space Traversal</td>
      <td>O(N)</td>
      <td>O(b^N)</td>
      <td>O(b^N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N)</td>
      <td>O(b^N)</td>
      <td>O(b^N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Optical Inspection & Image-Based Defect Detection: </b>Rapidly identify visual anomalies like particles, scratches, or pattern irregularities on the wafer surface by comparing high-resolution images against a known good reference.<br> <br>

            <b>The Algorithm: </b><b>KMP Pattern Matching</b> Adapted for 2D image data, this algorithm efficiently searches for the expected reference pattern within the captured image of the wafer. By avoiding redundant comparisons, it quickly locates mismatches, flagging them as potential defects for further review.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/kmp.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Preprocessing (LPS)</td>
      <td>O(M)</td>
      <td>O(M)</td>
      <td>O(M)</td>
    </tr>

    <tr>
      <td>Pattern Search</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Electrical Testing & Circuit Path Validation: </b>Verify the electrical integrity of the fabricated paths, ensuring that critical signals can travel between points with the correct resistance and that there are no open or short circuits.<br> <br>

            <b>The Algorithm: </b><b>Dijkstra’s Algorithm</b> Models the chip's electrical network as a graph where nodes are test points and edges are connections weighted by resistance. It calculates the path of least resistance between probes; deviations from the expected value indicate a physical defect in the circuit path.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/dij.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Extract-Min Operations</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
    </tr>

    <tr>
      <td>Decrease-Key Operations</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
    </tr>
  </table>


             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Yield Analysis, Classification & Defect Mapping: </b>Process massive datasets of collected defects to categorize them, map their physical locations on the wafer, and identify systematic manufacturing problems to improve overall yield.<br> <br>

            <b>The Algorithm: </b><b>Merge Sort</b>A highly efficient and stable sorting algorithm used to organize millions of defect records by various criteria (e.g., size, location, type). This sorted data allows for quick grouping, statistical analysis, and the generation of detailed defect maps to pinpoint problem areas.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/merge2.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Divide Step</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Merge Step</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;

using namespace std;

ofstream fout("output.txt");

/* ---------------- SAFE SEEK ---------------- */
bool seek(const char *h) {
    string tok;
    while (cin &gt;&gt; tok) {
        if (tok == h) return true;
    }
    return false;
}

/* ---------------- BACKTRACKING: Wafer Layer Formation ----------------
   Simple model:
   - sequence length L (number of steps)
   - for each step i there are options (feature sizes)
   - design rule: sizes must be non-increasing (cannot increase feature shrink)
   - backtrack picks one size per step satisfying rule
---------------------------------------------------------------------*/
const int MAXSTEPS = 30;
int Lsteps;
int optCount[MAXSTEPS];
int options[MAXSTEPS][20]; // up to 20 options per step
int chosen[MAXSTEPS];

bool backtrack_steps(int idx) {
    if (idx == Lsteps) return true;
    for (int j = 0; j &lt; optCount[idx]; j++) {
        int s = options[idx][j];
        // design rule: non-increasing sizes
        if (idx &gt; 0 &amp;&amp; s &gt; chosen[idx-1]) continue;
        chosen[idx] = s;
        if (backtrack_steps(idx + 1)) return true;
        // else try next option
    }
    return false;
}

/* ---------------- 2D KMP (adapted) : Image-based defect detection -------------
   - image H x W of chars
   - pattern ph x pw of chars
   - use KMP to find occurrences of first pattern row in each image row
   - for each match column, verify subsequent rows match immediately (fast check)
----------------------------------------------------------------------------*/
const int MAXH = 200;
const int MAXW = 200;
string image[MAXH];
string patternRows[MAXH];

int lpsArr[2020];

void buildLPS(const string &amp;pat, int lps[]) {
    int n = pat.size();
    lps[0] = 0;
    int len = 0;
    int i = 1;
    while (i &lt; n) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) len = lps[len - 1];
            else { lps[i] = 0; i++; }
        }
    }
}

void kmpSearchRow(const string &amp;text, const string &amp;pat, int lps[], int positions[], int &amp;posCount) {
    posCount = 0;
    int n = text.size(), m = pat.size();
    if (m &gt; n) return;
    int i = 0, j = 0;
    while (i &lt; n) {
        if (text[i] == pat[j]) { i++; j++; }
        if (j == m) { positions[posCount++] = i - j; j = lps[j - 1]; }
        else if (i &lt; n &amp;&amp; text[i] != pat[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
}

/* ---------------- DIJKSTRA: Electrical path least resistance ----------------
   adjacency using arrays
----------------------------------------------------------------------------*/
const int MAXN = 500;
const int MAXE = 2000;
int head[MAXN], toE[MAXE], costE[MAXE], nextE[MAXE], edgeCnt;
int nNodes;

void initGraph(int n) {
    nNodes = n;
    edgeCnt = 0;
    for (int i = 1; i &lt;= n; i++) head[i] = -1;
}

void addEdge(int u, int v, int w) {
    toE[edgeCnt] = v;
    costE[edgeCnt] = w;
    nextE[edgeCnt] = head[u];
    head[u] = edgeCnt++;
}

const int INF = 1000000000;
int distArr[MAXN], parentArr[MAXN];
bool used[MAXN];

void dijkstra(int src) {
    for (int i = 1; i &lt;= nNodes; i++) {
        distArr[i] = INF; parentArr[i] = -1; used[i] = false;
    }
    distArr[src] = 0;
    for (int it = 1; it &lt;= nNodes; it++) {
        int v = -1, best = INF;
        for (int i = 1; i &lt;= nNodes; i++)
            if (!used[i] &amp;&amp; distArr[i] &lt; best) { best = distArr[i]; v = i; }
        if (v == -1) break;
        used[v] = true;
        for (int e = head[v]; e != -1; e = nextE[e]) {
            int to = toE[e], w = costE[e];
            if (distArr[v] + w &lt; distArr[to]) {
                distArr[to] = distArr[v] + w;
                parentArr[to] = v;
            }
        }
    }
}

void printPathDij(int dest) {
    if (distArr[dest] &gt;= INF) { fout &lt;&lt; "No electrical path\n"; return; }
    int tmp[1000], c = 0;
    int cur = dest;
    while (cur != -1) { tmp[c++] = cur; cur = parentArr[cur]; }
    fout &lt;&lt; "Least resistance: " &lt;&lt; distArr[dest] &lt;&lt; "\n";
    fout &lt;&lt; "Path: ";
    for (int i = c - 1; i &gt;= 0; i--) {
        fout &lt;&lt; tmp[i];
        if (i) fout &lt;&lt; " -&gt; ";
    }
    fout &lt;&lt; "\n";
}

/* ---------------- MERGE SORT: Defect records sorting ----------------
   records: id, x, y, size, severity
-------------------------------------------------------------------------*/
struct DefRec { long long id; int x; int y; int size; int severity; };
DefRec defects[2000], tmpDef[2000];

void mergeDefs(int l, int m, int r) {
    int i = l, j = m + 1, k = l;
    while (i &lt;= m &amp;&amp; j &lt;= r) {
        // sort by severity desc, then size desc
        if (defects[i].severity &gt; defects[j].severity ||
            (defects[i].severity == defects[j].severity &amp;&amp; defects[i].size &gt;= defects[j].size))
            tmpDef[k++] = defects[i++];
        else tmpDef[k++] = defects[j++];
    }
    while (i &lt;= m) tmpDef[k++] = defects[i++];
    while (j &lt;= r) tmpDef[k++] = defects[j++];
    for (int t = l; t &lt;= r; t++) defects[t] = tmpDef[t];
}

void mergeSortDefs(int l, int r) {
    if (l &gt;= r) return;
    int m = (l + r) / 2;
    mergeSortDefs(l, m);
    mergeSortDefs(m + 1, r);
    mergeDefs(l, m, r);
}

/* --------------------------- MAIN --------------------------- */
int main() {
    /* ---------- BACKTRACK ---------- */
    if (!seek("BACKTRACK")) { fout &lt;&lt; "BACKTRACK missing\n"; return 0; }
    cin &gt;&gt; Lsteps;
    if (Lsteps &lt; 1 || Lsteps &gt; MAXSTEPS) { fout &lt;&lt; "Invalid Lsteps\n"; return 0; }
    for (int i = 0; i &lt; Lsteps; i++) {
        cin &gt;&gt; optCount[i];
        if (optCount[i] &lt; 1) { fout &lt;&lt; "Invalid options\n"; return 0; }
        for (int j = 0; j &lt; optCount[i]; j++) cin &gt;&gt; options[i][j];
    }
    fout &lt;&lt; "--- WAFER PROCESS SEQUENCE (Backtracking) ---\n";
    if (backtrack_steps(0)) {
        fout &lt;&lt; "Valid process sequence (feature sizes per step): ";
        for (int i = 0; i &lt; Lsteps; i++) fout &lt;&lt; chosen[i] &lt;&lt; (i+1==Lsteps? "\n":" ");
    } else fout &lt;&lt; "No valid fabrication sequence found.\n";

    /* ---------- KMP2D IMAGE MATCH ---------- */
    if (!seek("KMP2D")) { fout &lt;&lt; "KMP2D missing\n"; return 0; }
    int H, W; cin &gt;&gt; H &gt;&gt; W;
    if (H &lt; 1 || W &lt; 1 || H &gt; MAXH || W &gt; MAXW) { fout &lt;&lt; "Bad image dims\n"; return 0; }
    for (int i = 0; i &lt; H; i++) cin &gt;&gt; image[i];

    int ph, pw; cin &gt;&gt; ph &gt;&gt; pw;
    for (int i = 0; i &lt; ph; i++) cin &gt;&gt; patternRows[i];

    fout &lt;&lt; "\n--- OPTICAL INSPECTION (2D KMP adapted) ---\n";
    bool foundAny = false;
    int posCols[1024];
    for (int row = 0; row &lt;= H - ph; row++) {
        // find matches of patternRows[0] in image[row]
        buildLPS(patternRows[0], lpsArr);
        int posCount = 0;
        kmpSearchRow(image[row], patternRows[0], lpsArr, posCols, posCount);
        for (int p = 0; p &lt; posCount; p++) {
            int col = posCols[p];
            bool ok = true;
            for (int r = 1; r &lt; ph &amp;&amp; ok; r++) {
                // compare substring image[row + r].substr(col, pw) with patternRows[r]
                for (int c = 0; c &lt; pw; c++) {
                    if (image[row + r][col + c] != patternRows[r][c]) { ok = false; break; }
                }
            }
            if (!ok) {
                // mismatch at this location =&gt; defect region
                fout &lt;&lt; "Defect at approx location (row " &lt;&lt; row &lt;&lt; ", col " &lt;&lt; col &lt;&lt; ")\n";
                foundAny = true;
            }
        }
    }
    if (!foundAny) fout &lt;&lt; "No visual defects detected by pattern mismatch.\n";

    /* ---------- DIJKSTRA (Electrical Testing) ---------- */
    if (!seek("CIRCUIT")) { fout &lt;&lt; "CIRCUIT missing\n"; return 0; }
    int m; cin &gt;&gt; nNodes &gt;&gt; m;
    initGraph(nNodes);
    for (int i = 0; i &lt; m; i++) {
        int u, v, r; cin &gt;&gt; u &gt;&gt; v &gt;&gt; r; // r = resistance
        addEdge(u, v, r);
        addEdge(v, u, r);
    }
    fout &lt;&lt; "\n--- ELECTRICAL PATHS (Dijkstra) ---\n";
    int q; cin &gt;&gt; q;
    for (int i = 0; i &lt; q; i++) {
        int s, d; cin &gt;&gt; s &gt;&gt; d;
        dijkstra(s);
        printPathDij(d);
        fout &lt;&lt; "-----\n";
    }

    /* ---------- DEFECT RECORDS (Merge Sort) ---------- */
    if (!seek("DEFECTS")) { fout &lt;&lt; "DEFECTS missing\n"; return 0; }
    int K; cin &gt;&gt; K;
    if (K &lt; 0 || K &gt; 2000) { fout &lt;&lt; "Invalid K\n"; return 0; }
    for (int i = 0; i &lt; K; i++) {
        cin &gt;&gt; defects[i].id &gt;&gt; defects[i].x &gt;&gt; defects[i].y &gt;&gt; defects[i].size &gt;&gt; defects[i].severity;
    }
    mergeSortDefs(0, K - 1);
    fout &lt;&lt; "\n--- DEFECTS SORTED (severity desc, size desc) ---\n";
    for (int i = 0; i &lt; K; i++) {
        fout &lt;&lt; "ID:" &lt;&lt; defects[i].id &lt;&lt; " loc(" &lt;&lt; defects[i].x &lt;&lt; "," &lt;&lt; defects[i].y &lt;&lt; ") size:" &lt;&lt; defects[i].size &lt;&lt; " sev:" &lt;&lt; defects[i].severity &lt;&lt; "\n";
    }

    fout.close();
    return 0;
}


    </div>

    <div class="data-input">
      BACKTRACK
5
3 100 90 80
2 90 80
3 80 70 60
2 60 55
2 55 50

KMP2D
10 12
000000000000
000011110000
000011110000
000011110000
000000000000
000100010000
000100010000
000100010000
000000000000
000000000000
3 4
0111
0111
0111

CIRCUIT
6 8
1 2 5
2 3 2
3 4 3
4 5 4
5 6 6
1 3 7
2 6 10
3 5 1
3
1 6
2 5
4 6

DEFECTS
8
100001 10 20 5 3
100002 12 18 3 5
100003 8 25 6 2
100004 40 50 10 9
100005 39 49 8 9
100006 20 22 2 1
100007 11 19 4 5
100008 5 6 12 7


    </div>

    <div class="data-output">

--- WAFER PROCESS SEQUENCE (Backtracking) ---
Valid process sequence (feature sizes per step): 100 90 80 60 55

--- OPTICAL INSPECTION (2D KMP adapted) ---
Defect at approx location (row 2, col 3)
Defect at approx location (row 3, col 3)

--- ELECTRICAL PATHS (Dijkstra) ---
Least resistance: 14
Path: 1 -> 3 -> 5 -> 6
-----
Least resistance: 3
Path: 2 -> 3 -> 5
-----
Least resistance: 10
Path: 4 -> 5 -> 6
-----

--- DEFECTS SORTED (severity desc, size desc) ---
ID:100004 loc(40,50) size:10 sev:9
ID:100005 loc(39,49) size:8 sev:9
ID:100008 loc(5,6) size:12 sev:7
ID:100007 loc(11,19) size:4 sev:5
ID:100002 loc(12,18) size:3 sev:5
ID:100001 loc(10,20) size:5 sev:3
ID:100003 loc(8,25) size:6 sev:2
ID:100006 loc(20,22) size:2 sev:1


    </div>
</div>

            





        </div>

        

        </div>
         
       

        <h2 class="section-heading">Cultural Hub</h2>

        <div class="content-box-container">

             <div class="content-box">
            <h3>Intelligent Event Scheduling & Space Optimization</h3>
            <div class="rule"></div>
             <p>Intelligent Event Scheduling & Space Optimization is a smart-city system that automatically manages events, venues, spaces, time slots, resources, and crowd flow.
             It ensures, no overlapping events,maximum utilization of public spaces,efficient crowd movement, optimal use of auditoriums, halls, parks, and convention centers, automatic conflict resolution and rescheduling</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p> 8, 9, 11, 12, 16</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="CulturalHub/sequence1.png" class="sequence">

            <p><b>Event Request & Time Slot Matching: </b>Rapidly search available time slots to match incoming event requests with suitable openings.<br> <br>

            <b>The Algorithm: </b><b>Binary Search Tree</b> Organizes time slots hierarchically, allowing the system to search, insert, or confirm venue availability for a specific time range with high efficiency (O(log n)).</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/bst.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Search</td>
      <td>O(1)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Insertion / Deletion</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>

            <p><b>Conflict Detection & Resource Linking: </b>Instantly determine if required resources (like A/V equipment or specific rooms) are already in use to prevent double-booking.<br> <br>

            <b>The Algorithm: </b><b>Union–Find</b>Tracks elements partitioned into disjoint sets. It quickly checks if a requested resource is already "united" with another active event, signaling a conflict.</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/union-find.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Find Operation</td>
      <td>O(1)</td>
      <td>O(α(N))</td>
      <td>O(α(N))</td>
    </tr>

    <tr>
      <td>Union Operation</td>
      <td>O(1)</td>
      <td>O(α(N))</td>
      <td>O(α(N))</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>

            <p><b>Venue Allocation & Space Optimization: </b>Connect events to the most appropriate venues while minimizing wasted capacity or travel distance between related sessions.<br> <br>

            <b>The Algorithm: </b><b>Kruskal's algorithm</b> treats events and venues as a graph, selecting the "edges" (allocations) with the lowest "cost" (best fit/closest distance) first to build an efficient allocation network without cycles or redundancies.</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/kruskal.png" class="image">

             <div class="efficiency-box">


                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Sorting Edges</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>

    <tr>
      <td>Union–Find Operations</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>
  </table>

  


                
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>

            <p><b>Final Schedule Ordering & Publication: </b>compile all confirmed bookings into a single, chronologically sorted master schedule for public view.<br> <br>

            <b>The Algorithm: </b><b>Merge Sort</b> efficiently organizes the complete list of finalized event data into time order, ensuring a stable and predictably sorted schedule ready for publishing.</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/merge.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Divide Step</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Merge Step</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;

using namespace std;
ofstream fout("output.txt");

/* ---------------- SAFE SEEK ---------------- */
bool seek(const char *h) {
    string tok;
    while (cin &gt;&gt; tok) {
        if (tok == h) return true;
    }
    return false;
}

/* ---------------- BST for Time Slots ----------------
   Store slots keyed by start time.
   Node arrays (no dynamic new) used to avoid pointers.
-----------------------------------------------------*/
const int MAXSLOTS = 500;
int slotStart[MAXSLOTS], slotEnd[MAXSLOTS], slotIdArr[MAXSLOTS];
int leftChild[MAXSLOTS], rightChild[MAXSLOTS];
int nodeCnt = 0;
int root = -1;

int newNode(int s, int e, int id) {
    int idx = nodeCnt++;
    slotStart[idx] = s;
    slotEnd[idx] = e;
    slotIdArr[idx] = id;
    leftChild[idx] = -1;
    rightChild[idx] = -1;
    return idx;
}

void bstInsert(int &amp;r, int s, int e, int id) {
    if (r == -1) { r = newNode(s, e, id); return; }
    if (s &lt; slotStart[r]) bstInsert(leftChild[r], s, e, id);
    else bstInsert(rightChild[r], s, e, id);
}

/* Search for a slot that can contain [qs, qe]:
   Strategy: traverse according to start key. If node.start &lt;= qs and node.end &gt;= qe =&gt; match.
   Search left when node.start &gt; qs (earlier starts might fit). Otherwise search right if current node doesn't fit.
*/
int bstFindSlot(int r, int qs, int qe) {
    int cur = r;
    while (cur != -1) {
        if (slotStart[cur] &lt;= qs &amp;&amp; slotEnd[cur] &gt;= qe) return cur;
        if (slotStart[cur] &gt; qs) cur = leftChild[cur];
        else cur = rightChild[cur];
    }
    return -1;
}

/* Remove a node by id index (simple approach):
   We'll mark removed flag and keep node but set its range to impossible so it won't match future searches.
*/
bool removed[MAXSLOTS];

void bstRemoveMark(int idx) {
    if (idx &gt;= 0 &amp;&amp; idx &lt; nodeCnt) {
        removed[idx] = true;
        // make impossible
        slotStart[idx] = 1000000000;
        slotEnd[idx] = -1000000000;
    }
}

/* ---------------- Union-Find for Resources ---------------- */
const int MAXRES = 500;
int parentRes[MAXRES], rankRes[MAXRES];
int resAssignedSet[MAXRES]; // 0 = unused, booking id if used

void initRes(int n) {
    for (int i = 1; i &lt;= n; i++) { parentRes[i] = i; rankRes[i] = 0; resAssignedSet[i] = 0; }
}

int findRes(int x) {
    int rootx = x;
    while (parentRes[rootx] != rootx) rootx = parentRes[rootx];
    // path compression
    int cur = x;
    while (cur != rootx) {
        int nxt = parentRes[cur];
        parentRes[cur] = rootx;
        cur = nxt;
    }
    return rootx;
}

void unionRes(int a, int b) {
    a = findRes(a); b = findRes(b);
    if (a == b) return;
    if (rankRes[a] &lt; rankRes[b]) parentRes[a] = b;
    else if (rankRes[b] &lt; rankRes[a]) parentRes[b] = a;
    else { parentRes[b] = a; rankRes[a]++; }
}

/* After unioning resources for a booking, mark set as used by booking id */
void markResSetUsed(int anyRes, int bookingId) {
    int r = findRes(anyRes);
    resAssignedSet[r] = bookingId;
}

int getResSetOwner(int anyRes) {
    int r = findRes(anyRes);
    return resAssignedSet[r];
}

/* ---------------- KRUSKAL-LIKE ALLOCATION ----------------
   We'll treat edges event-&gt;venue with cost. Sort edges by cost and greedily assign event if event not assigned and venue not used.
-------------------------------------------------------*/
struct Edge { int eventId; int venueId; int cost; };
Edge edgesArr[2000];
Edge tmpEdges[2000];

void mergeEdges(int l, int m, int r) {
    int i = l, j = m+1, k = l;
    while (i &lt;= m &amp;&amp; j &lt;= r) {
        if (edgesArr[i].cost &lt;= edgesArr[j].cost) tmpEdges[k++] = edgesArr[i++];
        else tmpEdges[k++] = edgesArr[j++];
    }
    while (i &lt;= m) tmpEdges[k++] = edgesArr[i++];
    while (j &lt;= r) tmpEdges[k++] = edgesArr[j++];
    for (int x = l; x &lt;= r; x++) edgesArr[x] = tmpEdges[x];
}

void mergeSortEdges(int l, int r) {
    if (l &gt;= r) return;
    int m = (l + r) / 2;
    mergeSortEdges(l, m);
    mergeSortEdges(m+1, r);
    mergeEdges(l, m, r);
}

/* ---------------- MERGE SORT SCHEDULE ---------------- */
struct Booking { int bookingId; int start; int end; int slotIdx; int venueId; };
Booking bookings[2000], tmpBookings[2000];

void mergeBookings(int l, int m, int r) {
    int i = l, j = m+1, k = l;
    while (i &lt;= m &amp;&amp; j &lt;= r) {
        if (bookings[i].start &lt;= bookings[j].start) tmpBookings[k++] = bookings[i++]; else tmpBookings[k++] = bookings[j++];
    }
    while (i &lt;= m) tmpBookings[k++] = bookings[i++];
    while (j &lt;= r) tmpBookings[k++] = bookings[j++];
    for (int x = l; x &lt;= r; x++) bookings[x] = tmpBookings[x];
}

void mergeSortBookings(int l, int r) {
    if (l &gt;= r) return;
    int m = (l + r) / 2;
    mergeSortBookings(l, m);
    mergeSortBookings(m+1, r);
    mergeBookings(l, m, r);
}

/* --------------------------- MAIN --------------------------- */
int main() {
    /*********** SLOTS section ***********/
    if (!seek("SLOTS")) { fout &lt;&lt; "SLOTS missing\n"; return 0; }
    int nSlots; cin &gt;&gt; nSlots;
    if (nSlots &lt; 0 || nSlots &gt; MAXSLOTS) { fout &lt;&lt; "Bad nSlots\n"; return 0; }
    nodeCnt = 0; root = -1;
    for (int i = 0; i &lt; nSlots; i++) {
        int sid, s, e; cin &gt;&gt; sid &gt;&gt; s &gt;&gt; e;
        // sid: arbitrary id, but we keep slotIdArr= sid
        bstInsert(root, s, e, sid);
    }
    fout &lt;&lt; "--- TIME SLOTS (BST) ---\n";
    fout &lt;&lt; "Inserted " &lt;&lt; nSlots &lt;&lt; " slots into BST\n";

    /*********** RESOURCES &amp; REQUESTS section ***********/
    if (!seek("RESOURCES")) { fout &lt;&lt; "RESOURCES missing\n"; return 0; }
    int R; cin &gt;&gt; R;
    if (R &lt; 0 || R &gt; MAXRES-1) { fout &lt;&lt; "Bad resources\n"; return 0; }
    initRes(R);
    fout &lt;&lt; "\n--- RESOURCES (Union-Find) ---\n";
    fout &lt;&lt; "Resources count: " &lt;&lt; R &lt;&lt; "\n";

    if (!seek("REQUESTS")) { fout &lt;&lt; "REQUESTS missing\n"; return 0; }
    int Q; cin &gt;&gt; Q;
    int bookingCounter = 0;
    int bookingArrIdx = 0;
    bool eventAssigned[1000]; for (int i=0;i&lt;1000;i++) eventAssigned[i]=false;
    for (int qi = 0; qi &lt; Q; qi++) {
        int reqId, qs, qe, rcount; cin &gt;&gt; reqId &gt;&gt; qs &gt;&gt; qe &gt;&gt; rcount;
        int ress[50];
        for (int j = 0; j &lt; rcount; j++) cin &gt;&gt; ress[j];

        fout &lt;&lt; "\nRequest " &lt;&lt; reqId &lt;&lt; " wants [" &lt;&lt; qs &lt;&lt; "," &lt;&lt; qe &lt;&lt; "] using " &lt;&lt; rcount &lt;&lt; " resources\n";

        int foundIdx = bstFindSlot(root, qs, qe);
        if (foundIdx == -1 || removed[foundIdx]) {
            fout &lt;&lt; "  No available time slot found\n";
            continue;
        }
        if (removed[foundIdx]) { fout &lt;&lt; "  Slot already used\n"; continue; }

        // Check resources via union-find: if any resource set already has owner =&gt; conflict
        bool conflict = false;
        for (int j = 0; j &lt; rcount; j++) {
            int r = ress[j];
            if (r &lt; 1 || r &gt; R) { conflict = true; break; }
            int owner = getResSetOwner(r);
            if (owner != 0) { conflict = true; break; }
        }
        if (conflict) {
            fout &lt;&lt; "  Conflict: one or more resources already in use\n";
            continue;
        }

        // Reserve slot: mark removed
        bstRemoveMark(foundIdx);

        // Union all resources together and assign owner = reqId
        if (rcount &gt; 0) {
            int base = ress[0];
            for (int j = 1; j &lt; rcount; j++) unionRes(base, ress[j]);
            markResSetUsed(base, reqId);
        }

        // record provisional booking (slot index = slotIdArr[foundIdx])
        bookingCounter++;
        bookings[bookingArrIdx].bookingId = reqId;
        bookings[bookingArrIdx].start = slotStart[foundIdx]; // note: slotStart was set to huge when removed, but we saved before removal; to ensure we have original start we must capture earlier — so instead use stored slotIdArr as mapping: we'll output slotId and not rely on start. To avoid confusion we will store use qs as start for schedule.
        bookings[bookingArrIdx].start = qs;
        bookings[bookingArrIdx].end = qe;
        bookings[bookingArrIdx].slotIdx = slotIdArr[foundIdx];
        bookings[bookingArrIdx].venueId = -1; // venue assigned later by Kruskal
        bookingArrIdx++;
        eventAssigned[reqId] = true;

        fout &lt;&lt; "  Booked slot id=" &lt;&lt; slotIdArr[foundIdx] &lt;&lt; " for request " &lt;&lt; reqId &lt;&lt; "\n";
    }

    /*********** KRUSKAL-like allocation (event -&gt; venue edges) ***********/
    if (!seek("KRUSKAL")) { fout &lt;&lt; "KRUSKAL missing\n"; return 0; }
    int E, V; // E = number of events known, V = venues
    cin &gt;&gt; E &gt;&gt; V;
    int mEdges; cin &gt;&gt; mEdges;
    if (mEdges &lt; 0 || mEdges &gt; 2000) { fout &lt;&lt; "Bad mEdges\n"; return 0; }
    for (int i = 0; i &lt; mEdges; i++) cin &gt;&gt; edgesArr[i].eventId &gt;&gt; edgesArr[i].venueId &gt;&gt; edgesArr[i].cost;
    mergeSortEdges(0, mEdges - 1);

    // track assignment
    bool eventTaken[1000]; for (int i=0;i&lt;1000;i++) eventTaken[i]=false;
    bool venueUsed[1000]; for (int i=0;i&lt;1000;i++) venueUsed[i]=false;

    fout &lt;&lt; "\n--- VENUE ALLOCATION (Kruskal-like) ---\n";
    int allocations = 0;
    for (int i = 0; i &lt; mEdges; i++) {
        int ev = edgesArr[i].eventId;
        int vn = edgesArr[i].venueId;
        int c = edgesArr[i].cost;
        if (ev &lt; 0 || ev &gt;= 1000 || vn &lt; 0 || vn &gt;= 1000) continue;
        if (!eventAssigned[ev]) continue; // only allocate for booked events
        if (!eventTaken[ev] &amp;&amp; !venueUsed[vn]) {
            eventTaken[ev] = true;
            venueUsed[vn] = true;
            allocations++;
            // find booking entry and set venue
            for (int b = 0; b &lt; bookingArrIdx; b++) {
                if (bookings[b].bookingId == ev &amp;&amp; bookings[b].venueId == -1) {
                    bookings[b].venueId = vn;
                    break;
                }
            }
            fout &lt;&lt; "  Allocated event " &lt;&lt; ev &lt;&lt; " -&gt; venue " &lt;&lt; vn &lt;&lt; " (cost " &lt;&lt; c &lt;&lt; ")\n";
        }
    }
    fout &lt;&lt; "  Total allocations: " &lt;&lt; allocations &lt;&lt; "\n";

    /*********** FINAL SCHEDULE ORDERING (Merge Sort) ***********/
    if (!seek("PUBLISH")) { fout &lt;&lt; "PUBLISH missing\n"; return 0; }
    int B = bookingArrIdx;
    if (B == 0) {
        fout &lt;&lt; "\n--- FINAL SCHEDULE ---\nNo confirmed bookings\n";
        fout.close();
        return 0;
    }

    // sort bookings by start time
    mergeSortBookings(0, B-1);

    fout &lt;&lt; "\n--- FINAL SCHEDULE (chronological) ---\n";
    for (int i = 0; i &lt; B; i++) {
        fout &lt;&lt; "Booking ID: " &lt;&lt; bookings[i].bookingId &lt;&lt; " start:" &lt;&lt; bookings[i].start
             &lt;&lt; " end:" &lt;&lt; bookings[i].end &lt;&lt; " slotId:" &lt;&lt; bookings[i].slotIdx
             &lt;&lt; " venue:" &lt;&lt; (bookings[i].venueId==-1? -1:bookings[i].venueId) &lt;&lt; "\n";
    }

    fout.close();
    return 0;
}

    </div>

    <div class="data-input">
SLOTS
6
101 900 1030
102 1030 1200
103 1200 1330
104 1400 1530
105 0900 0930
106 1600 1730

RESOURCES
6

REQUESTS
5
1 900 930 2 1 2
2 1000 1130 1 3
3 1200 1300 2 4 5
4 1400 1500 1 2
5 1600 1700 1 6

KRUSKAL
5 4
8
1 1 5
1 2 8
2 1 3
2 3 6
3 2 2
3 4 4
4 3 1
5 4 2

PUBLISH

    </div>

    <div class="data-output">
--- TIME SLOTS (BST) ---
Inserted 6 slots into BST

--- RESOURCES (Union-Find) ---
Resources count: 6

Request 1 wants [900,930] using 2 resources
  Booked slot id=101 for request 1

Request 2 wants [1000,1130] using 1 resources
  No available time slot found

Request 3 wants [1200,1300] using 2 resources
  No available time slot found

Request 4 wants [1400,1500] using 1 resources
  No available time slot found

Request 5 wants [1600,1700] using 1 resources
  No available time slot found

--- VENUE ALLOCATION (Kruskal-like) ---
  Allocated event 1 -> venue 1 (cost 5)
  Total allocations: 1

--- FINAL SCHEDULE (chronological) ---
Booking ID: 1 start:900 end:930 slotId:101 venue:1

    </div>
</div>

            


        </div>

        <div class="content-box">
            <h3>Smart Visitor Flow Prediction & Crowd Management</h3>
            <div class="rule"></div>
            <p>Smart Visitor Flow Prediction & Crowd Management helps Samarthaka monitor how people move through parks, events, markets, stations, temples, sports zones, and public spaces. The system analyzes visitor patterns, predicts where crowds will form, and guides people safely using dynamic routing and smart alerts.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>3, 9, 11, 12, 16</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="CulturalHub/sequence2.png" class="sequence">

            <p><b>Real-Time Visitor Data Collection: </b>To instantly log and track the entry, movements, and exit of tens of thousands of individual visitors across city checkpoints in real-time.<br> <br>

            <b>The Algorithm: </b><b>Hashing</b> uses a hash table to map unique visitor identifiers (like ticket IDs or RFID tags) directly to their location records.</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/hash.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Search / Deletion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>

            <p><b>Zone Density Monitoring & Updates: </b>To continuously calculate and update the total number of people present within specific defined zones (like a market square or a street segment) to detect overcrowding instantly.<br> <br>

            <b>The Algorithm: </b><b>Segment tree</b> stores visitor counts in a hierarchical tree structure representing spatial intervals. This allows the system to rapidly update counts as individuals move and instantaneously query the total density over any range of contiguous zones (O(log n)).</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/segment.png" class="image">

             <div class="efficiency-box">

                 <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Tree Construction</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Query / Update</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    
  </table>


             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>

            <p><b>Safe Path Prediction & Crowd Flow Routing: </b>To determine congestion-free routes to guide crowds during peak times or emergencies, adapting to rapidly changing street conditions.<br> <br>

            <b>The Algorithm: </b><b>Bellman-Ford</b> calculates the shortest (safest/fastest) paths from a source to various destinations. It is chosen here for its ability to handle complex graphs where edge weights (congestion levels) change dynamically, ensuring that visitors aren't routed into areas where movement has become impossible</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/bellman.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Edge Relaxation</td>
      <td>O(E)</td>
      <td>O(VE)</td>
      <td>O(VE)</td>
    </tr>

    <tr>
      <td>Negative Cycle Check</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E)</td>
      <td>O(VE)</td>
      <td>O(VE)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>

            <p><b>Priority-Based Crowd Management Actions: </b>To efficiently manage a queue of required interventions—such as deploying staff, opening overflow exits, or issuing alerts—by addressing the most critical situations first.<br> <br>

            <b>The Algorithm: </b><b>Heap / Priority Queue </b>Organizes all necessary crowd control actions based on an urgency score. A Max-Heap ensures that the highest-priority task (e.g., a zone exceeding safe capacity) is always at the top for immediate execution.</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/heap.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>
    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Deletion (Extract-Max)</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Updating Priority</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Retrieving Max</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
  </table>

             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;

using namespace std;
ofstream fout("output.txt");

/* ---------------- SAFE SEEK ---------------- */
bool seek(const char *h) {
    string tok;
    while (cin &gt;&gt; tok) {
        if (tok == h) return true;
    }
    return false;
}

/* ---------------- HASH (visitor id -&gt; zone) ----------------
   Open addressing, linear probing.
-----------------------------------------------------------*/
const int HASH_SIZE = 8192; // power of two
struct HNode { unsigned long long id; int zone; bool used; bool deleted; };
HNode H[HASH_SIZE];

unsigned int mixhash(unsigned long long x) {
    x = (~x) + (x &lt;&lt; 18);
    x = x ^ (x &gt;&gt; 31);
    x = x * 21;
    x = x ^ (x &gt;&gt; 11);
    x = x + (x &lt;&lt; 6);
    x = x ^ (x &gt;&gt; 22);
    return (unsigned int)(x &amp; (HASH_SIZE - 1));
}

void hashInit() {
    for (int i = 0; i &lt; HASH_SIZE; i++) { H[i].id = 0; H[i].zone = 0; H[i].used = false; H[i].deleted = false; }
}

int hashFindIndex(unsigned long long id) {
    unsigned int idx = mixhash(id);
    for (int i = 0; i &lt; HASH_SIZE; i++) {
        unsigned int p = (idx + i) &amp; (HASH_SIZE - 1);
        if (!H[p].used &amp;&amp; !H[p].deleted) return -1;
        if (H[p].used &amp;&amp; !H[p].deleted &amp;&amp; H[p].id == id) return p;
    }
    return -1;
}

int hashInsertOrUpdate(unsigned long long id, int zone) {
    unsigned int idx = mixhash(id);
    int firstDel = -1;
    for (int i = 0; i &lt; HASH_SIZE; i++) {
        unsigned int p = (idx + i) &amp; (HASH_SIZE - 1);
        if (!H[p].used) {
            if (firstDel != -1) p = firstDel;
            H[p].used = true; H[p].deleted = false; H[p].id = id; H[p].zone = zone;
            return p;
        }
        if (H[p].deleted &amp;&amp; firstDel == -1) firstDel = p;
        if (H[p].used &amp;&amp; !H[p].deleted &amp;&amp; H[p].id == id) {
            H[p].zone = zone;
            return p;
        }
    }
    // table full
    return -1;
}

bool hashRemove(unsigned long long id) {
    int idx = hashFindIndex(id);
    if (idx == -1) return false;
    H[idx].used = false; H[idx].deleted = true;
    return true;
}

/* ---------------- SEGMENT TREE (zone counts) ----------------
   Zones numbered 1..Z
-----------------------------------------------------------*/
const int MAXZ = 1024;
int Z;
int seg[4 * MAXZ];

void segBuild(int idx, int l, int r) {
    if (l == r) { seg[idx] = 0; return; }
    int m = (l + r) &gt;&gt; 1;
    segBuild(idx&lt;&lt;1, l, m);
    segBuild(idx&lt;&lt;1|1, m+1, r);
    seg[idx] = seg[idx&lt;&lt;1] + seg[idx&lt;&lt;1|1];
}

void segAdd(int idx, int l, int r, int pos, int delta) {
    if (pos &lt; l || pos &gt; r) return;
    if (l == r) { seg[idx] += delta; return; }
    int m = (l + r) &gt;&gt; 1;
    if (pos &lt;= m) segAdd(idx&lt;&lt;1, l, m, pos, delta);
    else segAdd(idx&lt;&lt;1|1, m+1, r, pos, delta);
    seg[idx] = seg[idx&lt;&lt;1] + seg[idx&lt;&lt;1|1];
}

int segQuery(int idx, int l, int r, int ql, int qr) {
    if (qr &lt; l || ql &gt; r) return 0;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) return seg[idx];
    int m = (l + r) &gt;&gt; 1;
    return segQuery(idx&lt;&lt;1, l, m, ql, qr) + segQuery(idx&lt;&lt;1|1, m+1, r, ql, qr);
}

/* ---------------- BELLMAN-FORD (safe/fast path with dynamic weights) -------------
   nodes 1..N, edges list (directed)
-------------------------------------------------------------------------------*/
const int MAXN = 500;
const int MAXE = 2000;
struct Edge { int u, v; int w; } edges[MAXE];
int edgeCnt = 0;
int BFdist[MAXN], BFparent[MAXN];

void bfInit(int n) {
    edgeCnt = 0;
    for (int i = 1; i &lt;= n; i++) { BFdist[i] = 0; BFparent[i] = -1; }
}

void bfAddEdge(int u, int v, int w) {
    if (edgeCnt &gt;= MAXE) return;
    edges[edgeCnt].u = u; edges[edgeCnt].v = v; edges[edgeCnt].w = w; edgeCnt++;
}

bool bellmanFord(int n, int src) {
    const int INF = 1000000000;
    for (int i = 1; i &lt;= n; i++) { BFdist[i] = INF; BFparent[i] = -1; }
    BFdist[src] = 0;
    for (int it = 1; it &lt;= n-1; it++) {
        bool any = false;
        for (int e = 0; e &lt; edgeCnt; e++) {
            int u = edges[e].u, v = edges[e].v, w = edges[e].w;
            if (BFdist[u] &lt; INF &amp;&amp; BFdist[u] + w &lt; BFdist[v]) {
                BFdist[v] = BFdist[u] + w;
                BFparent[v] = u;
                any = true;
            }
        }
        if (!any) break;
    }
    // we ignore negative cycles (not expected in congestion model)
    return true;
}

void printBFPath(int dest) {
    const int INF = 1000000000;
    if (BFdist[dest] &gt;= INF) { fout &lt;&lt; "No path to " &lt;&lt; dest &lt;&lt; "\n"; return; }
    int tmp[MAXN]; int c = 0;
    int cur = dest;
    while (cur != -1) { tmp[c++] = cur; cur = BFparent[cur]; }
    fout &lt;&lt; "Distance: " &lt;&lt; BFdist[dest] &lt;&lt; " Path: ";
    for (int i = c-1; i &gt;= 0; i--) {
        fout &lt;&lt; tmp[i];
        if (i) fout &lt;&lt; " -&gt; ";
    }
    fout &lt;&lt; "\n";
}

/* ---------------- MAX-HEAP (priority actions) ----------------
   Stores (urgency, actionId, description)
-----------------------------------------------------------*/
const int MAXA = 2000;
int heapSize = 0;
int heapUrg[MAXA];
int heapId[MAXA];
string heapDesc[MAXA];

void heapSwap(int i, int j) {
    int tUrg = heapUrg[i]; heapUrg[i] = heapUrg[j]; heapUrg[j] = tUrg;
    int tId = heapId[i]; heapId[i] = heapId[j]; heapId[j] = tId;
    string tD = heapDesc[i]; heapDesc[i] = heapDesc[j]; heapDesc[j] = tD;
}

void heapPush(int urgency, int id, const string &amp;desc) {
    int cur = ++heapSize;
    heapUrg[cur] = urgency; heapId[cur] = id; heapDesc[cur] = desc;
    while (cur &gt; 1) {
        int p = cur &gt;&gt; 1;
        if (heapUrg[p] &gt;= heapUrg[cur]) break;
        heapSwap(p, cur);
        cur = p;
    }
}

bool heapPop(int &amp;urg, int &amp;id, string &amp;desc) {
    if (heapSize == 0) return false;
    urg = heapUrg[1]; id = heapId[1]; desc = heapDesc[1];
    heapSwap(1, heapSize);
    heapSize--;
    int cur = 1;
    while (true) {
        int l = cur&lt;&lt;1, r = l+1, mx = cur;
        if (l &lt;= heapSize &amp;&amp; heapUrg[l] &gt; heapUrg[mx]) mx = l;
        if (r &lt;= heapSize &amp;&amp; heapUrg[r] &gt; heapUrg[mx]) mx = r;
        if (mx == cur) break;
        heapSwap(cur, mx);
        cur = mx;
    }
    return true;
}

/* --------------------------- MAIN --------------------------- */
int main() {
    // HASH initial visitors
    if (!seek("HASH")) { fout &lt;&lt; "HASH missing\n"; return 0; }
    hashInit();
    int initCount; cin &gt;&gt; initCount;
    fout &lt;&lt; "--- VISITOR REGISTRY (Hash) ---\n";
    for (int i = 0; i &lt; initCount; i++) {
        unsigned long long vid; int zone;
        cin &gt;&gt; vid &gt;&gt; zone;
        hashInsertOrUpdate(vid, zone);
        fout &lt;&lt; "Inserted visitor " &lt;&lt; vid &lt;&lt; " at zone " &lt;&lt; zone &lt;&lt; "\n";
    }

    // SEGMENT: zones count, build tree and load counts from hash
    if (!seek("SEGMENT")) { fout &lt;&lt; "SEGMENT missing\n"; return 0; }
    cin &gt;&gt; Z;
    if (Z &lt; 1 || Z &gt;= MAXZ) { fout &lt;&lt; "Bad zone count\n"; return 0; }
    segBuild(1, 1, Z);
    // populate counts from hash table
    for (int i = 0; i &lt; HASH_SIZE; i++) {
        if (H[i].used &amp;&amp; !H[i].deleted) {
            int z = H[i].zone;
            if (z &gt;=1 &amp;&amp; z &lt;= Z) segAdd(1,1,Z,z,1);
        }
    }
    fout &lt;&lt; "\n--- ZONE DENSITY (Segment Tree) ---\n";
    fout &lt;&lt; "Zones = " &lt;&lt; Z &lt;&lt; "\n";
    // print initial counts
    for (int i = 1; i &lt;= Z; i++) {
        int c = segQuery(1,1,Z,i,i);
        fout &lt;&lt; "Zone " &lt;&lt; i &lt;&lt; " count=" &lt;&lt; c &lt;&lt; "\n";
    }

    // MOVES: simulate movements (id -&gt; newZone)
    if (!seek("MOVES")) { fout &lt;&lt; "MOVES missing\n"; return 0; }
    int M; cin &gt;&gt; M;
    fout &lt;&lt; "\n--- MOVEMENTS (updates &amp; zone queries) ---\n";
    for (int i = 0; i &lt; M; i++) {
        unsigned long long vid; int newZ; cin &gt;&gt; vid &gt;&gt; newZ;
        int idx = hashFindIndex(vid);
        if (idx == -1) {
            // new visitor enters
            hashInsertOrUpdate(vid, newZ);
            if (newZ &gt;=1 &amp;&amp; newZ &lt;= Z) segAdd(1,1,Z,newZ,1);
            fout &lt;&lt; "Visitor " &lt;&lt; vid &lt;&lt; " ENTER at zone " &lt;&lt; newZ &lt;&lt; "\n";
        } else {
            int oldZ = H[idx].zone;
            H[idx].zone = newZ;
            if (oldZ &gt;=1 &amp;&amp; oldZ &lt;= Z) segAdd(1,1,Z,oldZ,-1);
            if (newZ &gt;=1 &amp;&amp; newZ &lt;= Z) segAdd(1,1,Z,newZ,1);
            fout &lt;&lt; "Visitor " &lt;&lt; vid &lt;&lt; " MOVED " &lt;&lt; oldZ &lt;&lt; " -&gt; " &lt;&lt; newZ &lt;&lt; "\n";
        }
        // after each move, demonstrate a query: total in neighborhood [max(1,newZ-1), min(Z,newZ+1)]
        int ql = newZ-1; if (ql &lt; 1) ql = 1;
        int qr = newZ+1; if (qr &gt; Z) qr = Z;
        int total = segQuery(1,1,Z,ql,qr);
        fout &lt;&lt; "  Neighborhood [" &lt;&lt; ql &lt;&lt; "," &lt;&lt; qr &lt;&lt; "] total=" &lt;&lt; total &lt;&lt; "\n";
    }

    // BELL: graph, edges and queries
    if (!seek("BELL")) { fout &lt;&lt; "BELL missing\n"; return 0; }
    int N, E; cin &gt;&gt; N &gt;&gt; E;
    if (N &lt; 1 || N &gt;= MAXN || E &lt; 0 || E &gt;= MAXE) { fout &lt;&lt; "Bad graph\n"; return 0; }
    edgeCnt = 0;
    for (int i = 0; i &lt; E; i++) {
        int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        bfAddEdge(u, v, w);
    }
    int Q; cin &gt;&gt; Q;
    fout &lt;&lt; "\n--- PATH PREDICTION (Bellman-Ford) ---\n";
    for (int i = 0; i &lt; Q; i++) {
        int src, dest; cin &gt;&gt; src &gt;&gt; dest;
        bellmanFord(N, src);
        fout &lt;&lt; "From " &lt;&lt; src &lt;&lt; " to " &lt;&lt; dest &lt;&lt; " -&gt; ";
        printBFPath(dest);
    }

    // ACTIONS: push actions to heap, then process top K
    if (!seek("ACTIONS")) { fout &lt;&lt; "ACTIONS missing\n"; return 0; }
    int A; cin &gt;&gt; A;
    fout &lt;&lt; "\n--- ACTIONS (Max-Heap) ---\n";
    for (int i = 0; i &lt; A; i++) {
        int aid, urg; string desc;
        cin &gt;&gt; aid &gt;&gt; urg &gt;&gt; desc;
        heapPush(urg, aid, desc);
        fout &lt;&lt; "Pushed action " &lt;&lt; aid &lt;&lt; " urgency=" &lt;&lt; urg &lt;&lt; " '" &lt;&lt; desc &lt;&lt; "'\n";
    }
    int toPop; cin &gt;&gt; toPop;
    fout &lt;&lt; "\nProcessing top " &lt;&lt; toPop &lt;&lt; " actions:\n";
    for (int i = 0; i &lt; toPop; i++) {
        int urg, id; string desc;
        if (!heapPop(urg, id, desc)) break;
        fout &lt;&lt; "Execute action " &lt;&lt; id &lt;&lt; " urgency=" &lt;&lt; urg &lt;&lt; " desc='" &lt;&lt; desc &lt;&lt; "'\n";
    }

    fout.close();
    return 0;
}

    </div>

    <div class="data-input">
HASH
12
10001 3
10002 3
10003 2
10004 5
10005 1
10006 8
10007 8
10008 9
10009 10
10010 2
10011 4
10012 3

SEGMENT
10

MOVES
6
10002 4
10013 2
10007 7
10005 2
10001 4
10014 5

BELL
10 12
1 2 3
2 3 2
3 4 5
1 5 10
5 6 1
6 7 2
7 8 2
8 9 3
9 10 1
2 8 7
4 9 4
3 9 6
3
1 10
2 7
5 3

ACTIONS
6
501 90 OpenOverflow
502 75 DeployStaff
503 95 CloseEntryGate
504 60 IssueAlert
505 80 ReRoute
506 50 Monitor
3

    </div>

    <div class="data-output">

--- VISITOR REGISTRY (Hash) ---
Inserted visitor 10001 at zone 3
Inserted visitor 10002 at zone 3
Inserted visitor 10003 at zone 2
Inserted visitor 10004 at zone 5
Inserted visitor 10005 at zone 1
Inserted visitor 10006 at zone 8
Inserted visitor 10007 at zone 8
Inserted visitor 10008 at zone 9
Inserted visitor 10009 at zone 10
Inserted visitor 10010 at zone 2
Inserted visitor 10011 at zone 4
Inserted visitor 10012 at zone 3

--- ZONE DENSITY (Segment Tree) ---
Zones = 10
Zone 1 count=1
Zone 2 count=2
Zone 3 count=3
Zone 4 count=1
Zone 5 count=1
Zone 6 count=0
Zone 7 count=0
Zone 8 count=2
Zone 9 count=1
Zone 10 count=1

--- MOVEMENTS (updates & zone queries) ---
Visitor 10002 MOVED 3 -> 4
  Neighborhood [3,5] total=5
Visitor 10013 ENTER at zone 2
  Neighborhood [1,3] total=6
Visitor 10007 MOVED 8 -> 7
  Neighborhood [6,8] total=2
Visitor 10005 MOVED 1 -> 2
  Neighborhood [1,3] total=6
Visitor 10001 MOVED 3 -> 4
  Neighborhood [3,5] total=5
Visitor 10014 ENTER at zone 5
  Neighborhood [4,6] total=5

--- PATH PREDICTION (Bellman-Ford) ---
From 1 to 10 -> Distance: 12 Path: 1 -> 2 -> 3 -> 9 -> 10
From 2 to 7 -> No path to 7
From 5 to 3 -> No path to 3

--- ACTIONS (Max-Heap) ---
Pushed action 501 urgency=90 'OpenOverflow'
Pushed action 502 urgency=75 'DeployStaff'
Pushed action 503 urgency=95 'CloseEntryGate'
Pushed action 504 urgency=60 'IssueAlert'
Pushed action 505 urgency=80 'ReRoute'
Pushed action 506 urgency=50 'Monitor'

Processing top 3 actions:
Execute action 503 urgency=95 desc='CloseEntryGate'
Execute action 501 urgency=90 desc='OpenOverflow'
Execute action 505 urgency=80 desc='ReRoute'


    </div>
</div>

            


        </div>

        </div>
       
       
        
        <h2 class="section-heading">Sports Academy</h2>

        <div class="content-box-container">
             <div class="content-box">
            <h3>AI-Driven Athlete Performance Analytics</h3>
            <div class="rule"></div>
             <p>AI-Driven Athlete Performance Analytics helps Samarthaka’s sports academies monitor athletes more intelligently by analysing speed, stamina, reaction time, training patterns, and injury risks. The system collects sensor data, identifies patterns, compares performance over time, and gives personalized improvement suggestions.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>3, 4, 9, 8, 11</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Sports/sequence1.png" class="sequence">

            <p><b>Data Collection & Instant Retrieval: </b>Instantly store and retrieve massive volumes of individual athlete data, such as biometric readings and historical stats, using unique identifiers.<br> <br>

            <b>The Algorithm: </b><b>Hashing</b> uses a hash table to map a unique key (e.g., athlete ID) directly to the memory location of their data record, allowing for near-instantaneous access ($O(1)$ average time) regardless of database size.</p>
            <br>

            <div class="image-box">
             <img src="Sports/hash.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Search / Deletion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>

            <p><b>Tracking Real-Time Performance Changes: </b>Continuously monitor and update cumulative performance metrics in real-time, such as total distance covered or aggregate training load during a session.<br> <br>

            <b>The Algorithm: </b><b>Fenwick Tree - Binary Indexed Tree</b>Efficiently updates individual data points (e.g., adding distance from a new lap) and instantly calculates cumulative totals (prefix sums) up to the current moment in logarithmic time.</p>
            <br>

            <div class="image-box">
             <img src="Sports/fen.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Update Value</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Prefix Sum Query</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>

            <p><b>Pattern Recognition in Movements & Training Cycles: </b>Identify specific, recurring sequences in sensor data or training logs that indicate optimal performance states, fatigue patterns, or potential injury risks.<br> <br>

            <b>The Algorithm: </b><b>KMP - Knuth–Morris–Pratt</b> Treats streams of movement data or training sequences as text strings, efficiently searching for specific "pattern" sequences within the larger dataset without redundant comparisons to quickly flag notable events.</p>
            <br>

            <div class="image-box">
             <img src="Sports/KMP.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Preprocessing (LPS)</td>
      <td>O(M)</td>
      <td>O(M)</td>
      <td>O(M)</td>
    </tr>

    <tr>
      <td>Pattern Search</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>

            <p><b>Athlete Ranking & Report Generation: </b>Compile comprehensive performance reports and generate leaderboards by ordering athletes based on aggregated scores or specific metrics.<br> <br>

            <b>The Algorithm: </b><b>Merge Sort</b>A highly efficient, stable sorting algorithm that systematically divides the dataset of athlete scores, sorts sub-lists, and merges them back together to produce a perfectly ordered ranking list for analysis.</p>
            <br>

            <div class="image-box">
             <img src="Sports/merge.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Divide Step</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Merge Step</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;

using namespace std;
ofstream fout("output.txt");

/* ---------------- SAFE SEEK ---------------- */
bool seek(const char *h) {
    string tok;
    while (cin &gt;&gt; tok) {
        if (tok == h) return true;
    }
    return false;
}

/* ---------------- HASH TABLE (Athlete Records) ---------------- */
const int HASH_SIZE = 4096;

struct Athlete {
    unsigned long long id;
    int metric;       // example: base performance metric
    bool used, deleted;
};
Athlete H[HASH_SIZE];

unsigned int mixhash(unsigned long long x) {
    x = (~x) + (x &lt;&lt; 21);
    x = x ^ (x &gt;&gt; 24);
    x = (x + (x &lt;&lt; 3)) + (x &lt;&lt; 8);
    x = x ^ (x &gt;&gt; 14);
    x = (x + (x &lt;&lt; 2)) + (x &lt;&lt; 4);
    x = x ^ (x &gt;&gt; 28);
    x = x + (x &lt;&lt; 31);
    return (unsigned int)(x &amp; (HASH_SIZE - 1));
}

void initHash() {
    for (int i = 0; i &lt; HASH_SIZE; i++) {
        H[i].id = 0;
        H[i].metric = 0;
        H[i].used = false;
        H[i].deleted = false;
    }
}

int hashFind(unsigned long long id) {
    unsigned int idx = mixhash(id);
    for (int i = 0; i &lt; HASH_SIZE; i++) {
        unsigned int p = (idx + i) &amp; (HASH_SIZE - 1);
        if (!H[p].used &amp;&amp; !H[p].deleted) return -1;
        if (H[p].used &amp;&amp; !H[p].deleted &amp;&amp; H[p].id == id) return p;
    }
    return -1;
}

int hashInsert(unsigned long long id, int metric) {
    unsigned int idx = mixhash(id);
    int firstDel = -1;

    for (int i = 0; i &lt; HASH_SIZE; i++) {
        unsigned int p = (idx + i) &amp; (HASH_SIZE - 1);

        if (!H[p].used) {
            if (firstDel != -1) p = firstDel;
            H[p].used = true;
            H[p].deleted = false;
            H[p].id = id;
            H[p].metric = metric;
            return p;
        }
        if (H[p].deleted &amp;&amp; firstDel == -1) firstDel = p;

        if (H[p].used &amp;&amp; !H[p].deleted &amp;&amp; H[p].id == id) {
            H[p].metric = metric;
            return p;
        }
    }
    return -1;
}

/* ---------------- FENWICK TREE (Real-time Performance Updates) ---------------- */
const int MAXA = 2000;
int BIT[MAXA], Nbit;

void fenwInit(int n) {
    Nbit = n;
    for (int i = 1; i &lt;= Nbit; i++) BIT[i] = 0;
}

void fenwAdd(int i, int v) {
    for (; i &lt;= Nbit; i += (i &amp; -i)) BIT[i] += v;
}

int fenwSum(int i) {
    int s = 0;
    for (; i &gt; 0; i -= (i &amp; -i)) s += BIT[i];
    return s;
}

/* ---------------- KMP PATTERN MATCHING ---------------- */
int lps[2000];

void buildLPS(const string &amp;pat) {
    int n = pat.size();
    lps[0] = 0;
    int len = 0, i = 1;

    while (i &lt; n) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) len = lps[len - 1];
            else { lps[i] = 0; i++; }
        }
    }
}

void KMPsearch(const string &amp;txt, const string &amp;pat) {
    int n = txt.size(), m = pat.size();
    buildLPS(pat);

    int i = 0, j = 0;
    while (i &lt; n) {
        if (txt[i] == pat[j]) { i++; j++; }
        if (j == m) {
            fout &lt;&lt; " Pattern found at index " &lt;&lt; (i - j) &lt;&lt; "\n";
            j = lps[j - 1];
        } else if (i &lt; n &amp;&amp; txt[i] != pat[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }
}

/* ---------------- MERGE SORT (Athlete Rankings) ---------------- */
struct RankRec {
    unsigned long long id;
    int score;
};
RankRec A[2000], tmpA[2000];

void mergeArr(int l, int m, int r) {
    int i = l, j = m + 1, k = l;

    while (i &lt;= m &amp;&amp; j &lt;= r) {
        if (A[i].score &gt;= A[j].score) tmpA[k++] = A[i++];
        else tmpA[k++] = A[j++];
    }
    while (i &lt;= m) tmpA[k++] = A[i++];
    while (j &lt;= r) tmpA[k++] = A[j++];

    for (int x = l; x &lt;= r; x++) A[x] = tmpA[x];
}

void mergeSort(int l, int r) {
    if (l &gt;= r) return;
    int m = (l + r) / 2;
    mergeSort(l, m);
    mergeSort(m + 1, r);
    mergeArr(l, m, r);
}

/* --------------------------- MAIN --------------------------- */
int main() {
    /* HASHING SECTION */
    if (!seek("HASH")) { fout &lt;&lt; "HASH missing\n"; return 0; }
    initHash();

    int Hn; cin &gt;&gt; Hn;
    fout &lt;&lt; "--- ATHLETE REGISTRY (Hash Table) ---\n";
    for (int i = 0; i &lt; Hn; i++) {
        unsigned long long id; int metric;
        cin &gt;&gt; id &gt;&gt; metric;
        hashInsert(id, metric);
        fout &lt;&lt; "Inserted athlete " &lt;&lt; id &lt;&lt; " metric=" &lt;&lt; metric &lt;&lt; "\n";
    }

    /* FENWICK SECTION */
    if (!seek("FENWICK")) { fout &lt;&lt; "FENWICK missing\n"; return 0; }
    int Fn; cin &gt;&gt; Fn;
    fenwInit(Fn);

    fout &lt;&lt; "\n--- REAL-TIME PERFORMANCE (Fenwick Tree) ---\n";

    for (int i = 1; i &lt;= Fn; i++) {
        int v; cin &gt;&gt; v;
        fenwAdd(i, v);
    }

    int Fq; cin &gt;&gt; Fq;
    while (Fq--) {
        int idx; cin &gt;&gt; idx;
        fout &lt;&lt; "Total up to " &lt;&lt; idx &lt;&lt; " = " &lt;&lt; fenwSum(idx) &lt;&lt; "\n";
    }

    /* KMP SECTION */
    if (!seek("KMP")) { fout &lt;&lt; "KMP missing\n"; return 0; }
    string txt, pat;
    cin &gt;&gt; txt &gt;&gt; pat;

    fout &lt;&lt; "\n--- PATTERN RECOGNITION (KMP) ---\n";
    KMPsearch(txt, pat);

    /* RANKINGS (MERGE SORT) */
    if (!seek("RANK")) { fout &lt;&lt; "RANK missing\n"; return 0; }
    int Rn; cin &gt;&gt; Rn;

    fout &lt;&lt; "\n--- ATHLETE RANKINGS (Merge Sort) ---\n";

    for (int i = 0; i &lt; Rn; i++) cin &gt;&gt; A[i].id &gt;&gt; A[i].score;
    mergeSort(0, Rn - 1);

    for (int i = 0; i &lt; Rn; i++)
        fout &lt;&lt; A[i].id &lt;&lt; " score=" &lt;&lt; A[i].score &lt;&lt; "\n";

    fout.close();
    return 0;
}

    </div>

    <div class="data-input">
HASH
5
101 85
102 90
103 75
104 88
105 92

FENWICK
10
5 3 7 2 4 6 1 9 8 5
3
5
8
10

KMP
ABCDABCDABEEABCDABCDABF
ABCDAB

RANK
6
101 1500
105 1780
104 1600
102 1700
103 1550
110 1490

    </div>

    <div class="data-output">

      --- ATHLETE REGISTRY (Hash Table) ---
Inserted athlete 101 metric=85
Inserted athlete 102 metric=90
Inserted athlete 103 metric=75
Inserted athlete 104 metric=88
Inserted athlete 105 metric=92

--- REAL-TIME PERFORMANCE (Fenwick Tree) ---
Total up to 5 = 21
Total up to 8 = 37
Total up to 10 = 50

--- PATTERN RECOGNITION (KMP) ---
 Pattern found at index 0
 Pattern found at index 4
 Pattern found at index 12
 Pattern found at index 16

--- ATHLETE RANKINGS (Merge Sort) ---
105 score=1780
102 score=1700
104 score=1600
103 score=1550
101 score=1500
110 score=1490


    </div>
</div>

            






        </div>

        </div>
       

       
       


        <a href="../index.html" class="back-btn">← Back to Team</a>

    </div>


    <!-- /* Code tab */ -->

    <!-- Popup Modal -->
        

    <div id="codeModal" class="modal-overlay">
  <div class="code-window">
    <div class="window-header">
      <div class="dots-container">
        <span class="dot red" onclick="closeCode()"></span>
        <span class="dot yellow"></span>
        <span class="dot green"></span>
      </div>
      <div class="tabs-container">
        <button class="tab-btn active" onclick="switchTab(event, 'cpp')">Solution.cpp</button>
        <button class="tab-btn" onclick="switchTab(event, 'input')">Input.txt</button>
        <button class="tab-btn" onclick="switchTab(event, 'output')">Output.txt</button>
      </div>
    </div>
    <div class="code-body">
      <div id="cpp" class="code-content active-content"><pre><code></code></pre></div>
      <div id="input" class="code-content"><pre><code></code></pre></div>
      <div id="output" class="code-content"><pre><code></code></pre></div>
    </div>
  </div>
</div>




      


    <script src="ishi.js"></script>

</body>
</html>
