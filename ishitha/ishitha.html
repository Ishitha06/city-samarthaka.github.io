<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ishitha – Contributions</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="ishi.css"> <!-- your updated css file -->
    
</head>

<body>

    <div class="page-wrapper">

        <h1 class="page-title">ISHITHA S</h1>
        <p class="subtitle">Detailed Contribution Breakdown</p>

        <h2 class="section-heading">Infrastructure</h2>

        <div class="content-box-container">

            <div class="content-box">
            <h3>Automated power grid monitoring & control</h3>
            <div class="rule"></div>

            <p>An automated power grid monitoring and control system is a smart infrastructure solution that continuously observes the flow of electricity across the grid and takes automatic actions to maintain stability. It uses sensors, communication networks, and intelligent algorithms to detect faults, balance loads, and optimize energy distribution. Instead of relying on manual checks, the system responds instantly to changes in voltage, current, frequency, or equipment health. <br></p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>Primary: 7 (7.1,7.2,7.3) <br> Secondary: 9,11,13</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>
            <br>
            <br>
            <img src="Infrastructure/powerGrid-flow.png" class="sequence">

            <p><b>Power Source Selection:</b> To dynamically select the most efficient or cost-effective power source available. This could be the Solar Plant during a sunny day, or a traditional power plant when demand is high. <br> <br>

            <b>The Algorithm:</b> A <b>Max-Heap</b> data structure is used to maintain a prioritized list of available power sources. The source at the "top" of the heap is always the best current option, allowing for instant selection.</p>
            <br>

            <div class="image-box">

              <img src="Infrastructure/max-heap.png" class="image">

               <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>
    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Deletion (Extract-Max)</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Updating Priority</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Retrieving Max</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
  </table>
               </div>


            </div>


            <br>


            <br>
            <br>
             <p><b>Building the Distribution Network:</b>To design the physical network of power lines that connects all sectors of Samarthaka (Residential, IT Hub, etc.) with the minimum total length of cable, reducing cost and material usage. <br> <br>

            <b>The Algorithm:</b> <b>Kruskal’s Minimum Spanning Tree (MST)</b> algorithm is used to determine the most efficient set of connections (edges) between all key locations (nodes), ensuring every sector is connected without creating any redundant loops.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/kruskal.png" class="image">

             <div class="efficiency-box">

  <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Sorting Edges</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>

    <tr>
      <td>Union–Find Operations</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>
  </table>

  


             </div>
             


            </div>


            <br>


            <br>
            <br>
             <p><b>Power Flow Routing:</b>To determine the best path for electricity to travel from a selected source to a specific destination (e.g., from the Solar Plant to the Hospital) to minimize power loss.<br> <br>

            <b>The Algorithm:</b> <b>Dijkstra’s Shortest Path </b>algorithm calculates the path with the lowest total resistance or cost through the network. This ensures sensitive zones receive stable power and overall transmission losses are kept to a minimum.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/Dijkstra.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Extract-Min Operations</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
    </tr>

    <tr>
      <td>Decrease-Key Operations</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
    </tr>
  </table>




             </div>


            </div>

            <br>

            <br>
            <br>
             <p><b>Real-time Monitoring:</b>To monitor the total power consumption of a specific area, like a residential block, in real-time and efficiently handle updates from individual smart meters.<br> <br>

            <b>The Algorithm:</b> <b>Segment Tree</b>A Segment Tree is used to store power usage data. It allows for rapid queries of a range of data (e.g., "total usage for houses 1-100") and quick updates to individual data points, which is essential for processing data from thousands of smart meters.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/segment.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Tree Construction</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Query / Update</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    
  </table>


             </div>


            </div>

            <br>


           <br>
            <br>
             <p><b>Outage Detection: </b>To instantly detect if any part of the grid has become disconnected from the main power source, allowing for immediate response.<br> <br>

            <b>The Algorithm:</b> <b>Union-Find</b>data structure tracks which parts of the grid are connected. If a power line breaks, the system can almost instantly determine if a sector is now in a separate, disconnected set from the main power source, triggering an alarm.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/union-find.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Find Operation</td>
      <td>O(1)</td>
      <td>O(α(N))</td>
      <td>O(α(N))</td>
    </tr>

    <tr>
      <td>Union Operation</td>
      <td>O(1)</td>
      <td>O(α(N))</td>
      <td>O(α(N))</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>


             </div>


            </div>

            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>


<div class="code-data" style="display:none;">

    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;fstream&gt;  
#include &lt;algorithm&gt;
#include &lt;limits&gt;

using namespace std;

ofstream fout("output.txt");

const int MAX_SOURCES = 20;
const int MAX_NODES   = 50;
const int MAX_EDGES   = 200;
const int MAX_HOUSES  = 50;
const int INF         = 1000000000;

// ----------------------------
// Power Source (Max-Heap)
// ----------------------------
struct PowerSource {
    int id;
    char name[20];
    int score;
};

PowerSource heapArr[MAX_SOURCES];
int heapSize = 0;

void swapSource(PowerSource &amp;a, PowerSource &amp;b) {
    PowerSource tmp = a;
    a = b;
    b = tmp;
}

void heapifyUp(int idx) {
    while (idx &gt; 0) {
        int parent = (idx - 1) / 2;
        if (heapArr[idx].score &gt; heapArr[parent].score) {
            swapSource(heapArr[idx], heapArr[parent]);
            idx = parent;
        } else break;
    }
}

void heapifyDown(int idx) {
    while (true) {
        int left = 2 * idx + 1;
        int right = 2 * idx + 2;
        int largest = idx;

        if (left &lt; heapSize &amp;&amp; heapArr[left].score &gt; heapArr[largest].score)
            largest = left;
        if (right &lt; heapSize &amp;&amp; heapArr[right].score &gt; heapArr[largest].score)
            largest = right;

        if (largest != idx) {
            swapSource(heapArr[idx], heapArr[largest]);
            idx = largest;
        } else break;
    }
}

void heapPush(const PowerSource &amp;s) {
    if (heapSize &gt;= MAX_SOURCES) return;
    heapArr[heapSize] = s;
    heapifyUp(heapSize);
    heapSize++;
}

PowerSource heapTop() {
    if (heapSize == 0) {
        PowerSource dummy;
        dummy.id = -1;
        strcpy(dummy.name, "None");
        dummy.score = -1;
        return dummy;
    }
    return heapArr[0];
}


// ----------------------------
// Union-Find
// ----------------------------
int parentUF[MAX_NODES];
int rankUF[MAX_NODES];

void makeSet(int n) {
    for (int i = 0; i &lt; n; ++i) {
        parentUF[i] = i;
        rankUF[i] = 0;
    }
}

int findSet(int v) {
    if (v == parentUF[v]) return v;
    parentUF[v] = findSet(parentUF[v]);
    return parentUF[v];
}

void unionSet(int a, int b) {
    a = findSet(a);
    b = findSet(b);
    if (a != b) {
        if (rankUF[a] &lt; rankUF[b]) swap(a, b);
        parentUF[b] = a;
        if (rankUF[a] == rankUF[b]) rankUF[a]++;
    }
}

// ----------------------------
// Edges
// ----------------------------
struct Edge {
    int u, v, w;
};

Edge edges[MAX_EDGES];
int N, M;

bool cmpEdge(const Edge &amp;a, const Edge &amp;b) {
    return a.w &lt; b.w;
}


// ----------------------------
// Kruskal MST
// ----------------------------
void runKruskalMST() {
    Edge sortedEdges[MAX_EDGES];
    for (int i = 0; i &lt; M; ++i) sortedEdges[i] = edges[i];

    sort(sortedEdges, sortedEdges + M, cmpEdge);

    makeSet(N);
    int edgesUsed = 0;
    long long totalWeight = 0;

    fout &lt;&lt; "\n--- DISTRIBUTION NETWORK (Kruskal MST) ---\n";
    fout &lt;&lt; "Edges in MST (u v w):\n";

    for (int i = 0; i &lt; M &amp;&amp; edgesUsed &lt; N - 1; ++i) {
        int u = sortedEdges[i].u;
        int v = sortedEdges[i].v;
        int w = sortedEdges[i].w;
        if (findSet(u) != findSet(v)) {
            unionSet(u, v);
            edgesUsed++;
            totalWeight += w;
            fout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; w &lt;&lt; "\n";
        }
    }
    fout &lt;&lt; "Total MST Cost: " &lt;&lt; totalWeight &lt;&lt; "\n";
}


// ----------------------------
// Dijkstra
// ----------------------------
int graphMat[MAX_NODES][MAX_NODES];

void runDijkstra(int src, int dest) {
    int dist[MAX_NODES];
    bool used[MAX_NODES];
    int parentNode[MAX_NODES];

    for (int i = 0; i &lt; N; ++i) {
        dist[i] = INF;
        used[i] = false;
        parentNode[i] = -1;
    }

    dist[src] = 0;

    for (int iter = 0; iter &lt; N; ++iter) {
        int u = -1, best = INF;
        for (int i = 0; i &lt; N; ++i)
            if (!used[i] &amp;&amp; dist[i] &lt; best)
                best = dist[i], u = i;

        if (u == -1) break;
        used[u] = true;

        for (int v = 0; v &lt; N; ++v)
            if (graphMat[u][v] &lt; INF &amp;&amp; dist[u] + graphMat[u][v] &lt; dist[v])
                dist[v] = dist[u] + graphMat[u][v], parentNode[v] = u;
    }

    fout &lt;&lt; "\n--- POWER FLOW ROUTING (Dijkstra) ---\n";
    if (dist[dest] == INF) {
        fout &lt;&lt; "No path.\n";
        return;
    }

    fout &lt;&lt; "Shortest Cost: " &lt;&lt; dist[dest] &lt;&lt; "\nPath: ";
    int path[MAX_NODES], len = 0, cur = dest;
    while (cur != -1) path[len++] = cur, cur = parentNode[cur];

    for (int i = len - 1; i &gt;= 0; --i)
        fout &lt;&lt; path[i] &lt;&lt; (i ? " -&gt; " : "");
    fout &lt;&lt; "\n";
}


// ----------------------------
// Segment Tree
// ----------------------------
long long arrHouses[MAX_HOUSES];
long long segTree[4 * MAX_HOUSES];
int H;

void buildSegTree(int idx, int l, int r) {
    if (l == r) { segTree[idx] = arrHouses[l]; return; }
    int mid = (l + r) / 2;
    buildSegTree(idx * 2, l, mid);
    buildSegTree(idx * 2 + 1, mid + 1, r);
    segTree[idx] = segTree[idx * 2] + segTree[idx * 2 + 1];
}

void updateSegTree(int idx, int l, int r, int pos, long long val) {
    if (l == r) { segTree[idx] = val; return; }
    int mid = (l + r) / 2;
    if (pos &lt;= mid) updateSegTree(idx * 2, l, mid, pos, val);
    else updateSegTree(idx * 2 + 1, mid + 1, r, pos, val);
    segTree[idx] = segTree[idx * 2] + segTree[idx * 2 + 1];
}

long long querySegTree(int idx, int l, int r, int ql, int qr) {
    if (qr &lt; l || ql &gt; r) return 0;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) return segTree[idx];
    int mid = (l + r) / 2;
    return querySegTree(idx * 2, l, mid, ql, qr) +
           querySegTree(idx * 2 + 1, mid + 1, r, ql, qr);
}

void runSegmentTreeQueries() {
    fout &lt;&lt; "\n--- REAL-TIME MONITORING (Segment Tree) ---\n";
    buildSegTree(1, 0, H - 1);
    int Q;
    cin &gt;&gt; Q;

    fout &lt;&lt; "Operations: " &lt;&lt; Q &lt;&lt; "\n";
    while (Q--) {
        char type;
        cin &gt;&gt; type;
        if (type == 'Q') {
            int l, r;
            cin &gt;&gt; l &gt;&gt; r;
            fout &lt;&lt; "Sum(" &lt;&lt; l &lt;&lt; "," &lt;&lt; r &lt;&lt; ") = " &lt;&lt; querySegTree(1, 0, H - 1, l, r) &lt;&lt; "\n";
        } else {
            int pos; long long val;
            cin &gt;&gt; pos &gt;&gt; val;
            updateSegTree(1, 0, H - 1, pos, val);
            fout &lt;&lt; "Updated meter " &lt;&lt; pos &lt;&lt; " to " &lt;&lt; val &lt;&lt; "\n";
        }
    }
}


// ----------------------------
// Outage Detection
// ----------------------------
bool disabledEdge[MAX_EDGES];

void runOutageDetection() {
    fout &lt;&lt; "\n--- OUTAGE DETECTION (Union-Find) ---\n";
    int B;
    cin &gt;&gt; B;

    for (int i = 0; i &lt; M; ++i) disabledEdge[i] = false;

    while (B--) {
        int idx;
        cin &gt;&gt; idx;
        disabledEdge[idx] = true;

        makeSet(N);
        for (int i = 0; i &lt; M; ++i)
            if (!disabledEdge[i])
                unionSet(edges[i].u, edges[i].v);

        fout &lt;&lt; "Failure Edge: #" &lt;&lt; idx &lt;&lt; "\nDisconnected nodes: ";
        int root = findSet(0);
        bool none = true;
        for (int i = 0; i &lt; N; ++i)
            if (findSet(i) != root)
                fout &lt;&lt; i &lt;&lt; " ", none = false;

        if (none) fout &lt;&lt; "None";
        fout &lt;&lt; "\n";
    }
}


// ----------------------------
// MAIN
// ----------------------------
int main() {
    int S;
    cin &gt;&gt; S;
    fout &lt;&lt; "--- POWER SOURCE SELECTION (Max-Heap) ---\n";
    
    for (int i = 0; i &lt; S; ++i) {
        PowerSource s;
        cin &gt;&gt; s.id &gt;&gt; s.name &gt;&gt; s.score;
        heapPush(s);
    }

    PowerSource best = heapTop();
    fout &lt;&lt; "Best Source: " &lt;&lt; best.name &lt;&lt; " (Score: " &lt;&lt; best.score &lt;&lt; ")\n";

    cin &gt;&gt; N &gt;&gt; M;
    
    for (int i = 0; i &lt; N; ++i)
        for (int j = 0; j &lt; N; ++j)
            graphMat[i][j] = (i == j ? 0 : INF);

    for (int i = 0; i &lt; M; ++i) {
        cin &gt;&gt; edges[i].u &gt;&gt; edges[i].v &gt;&gt; edges[i].w;
        graphMat[edges[i].u][edges[i].v] = edges[i].w;
        graphMat[edges[i].v][edges[i].u] = edges[i].w;
    }

    runKruskalMST();

    int src, dest;
    cin &gt;&gt; src &gt;&gt; dest;
    runDijkstra(src, dest);

    cin &gt;&gt; H;
    for (int i = 0; i &lt; H; ++i) cin &gt;&gt; arrHouses[i];

    runSegmentTreeQueries();
    runOutageDetection();

    fout.close();
    return 0;
}



    </div>

    <div class="data-input">
5
0 Solar 95
1 Wind 70
2 Hydro 85
3 Thermal 60
4 Backup 30
50 50
0 1 4
1 2 2
2 3 7
3 4 3
4 5 1
5 6 6
6 7 5
7 8 2
8 9 4
9 10 3
10 11 7
11 12 2
12 13 5
13 14 4
14 15 6
15 16 3
16 17 2
17 18 4
18 19 7
19 20 1
20 21 5
21 22 3
22 23 6
23 24 2
24 25 4
25 26 7
26 27 3
27 28 5
28 29 2
29 30 4
30 31 6
31 32 3
32 33 5
33 34 2
34 35 4
35 36 7
36 37 3
37 38 5
38 39 2
39 40 4
40 41 6
41 42 3
42 43 5
43 44 2
44 45 4
45 46 7
46 47 3
47 48 5
48 49 2
0 49 10
0 25
50
10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300 310 320 330 340 350 360 370 380 390 400 410 420 430 440 450 460 470 480 490 500
4
Q 0 9
Q 10 19
U 3 150
Q 0 9
3
0
10
49

    </div>

    <div class="data-output">
--- POWER SOURCE SELECTION (Max-Heap) ---
Best Source: Solar (Score: 95)

--- DISTRIBUTION NETWORK (Kruskal MST) ---
Edges in MST (u v w):
4 5 1
19 20 1
1 2 2
48 49 2
23 24 2
43 44 2
28 29 2
7 8 2
38 39 2
11 12 2
33 34 2
16 17 2
26 27 3
21 22 3
46 47 3
31 32 3
15 16 3
36 37 3
9 10 3
41 42 3
3 4 3
34 35 4
29 30 4
39 40 4
44 45 4
24 25 4
8 9 4
0 1 4
13 14 4
17 18 4
20 21 5
32 33 5
27 28 5
12 13 5
37 38 5
47 48 5
6 7 5
42 43 5
30 31 6
14 15 6
22 23 6
40 41 6
5 6 6
25 26 7
45 46 7
35 36 7
18 19 7
10 11 7
2 3 7
Total MST Cost: 197

--- POWER FLOW ROUTING (Dijkstra) ---
Shortest Cost: 98
Path: 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 13 -> 14 -> 15 -> 16 -> 17 -> 18 -> 19 -> 20 -> 21 -> 22 -> 23 -> 24 -> 25

--- REAL-TIME MONITORING (Segment Tree) ---
Operations: 4
Sum(0,9) = 550
Sum(10,19) = 1550
Updated meter 3 to 150
Sum(0,9) = 660

--- OUTAGE DETECTION (Union-Find) ---
Failure Edge: #0
Disconnected nodes: None
Failure Edge: #10
Disconnected nodes: 1 2 3 4 5 6 7 8 9 10 
Failure Edge: #49
Disconnected nodes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 

    </div>

</div>




        </div>

        <div class="content-box">
            <h3>Wireless Internet tower grid</h3>
            <div class="rule"></div>

            <p>A Wireless Internet Tower Grid is a city-wide system of interconnected communication towers that deliver fast, reliable, and uninterrupted internet coverage. These towers act as digital infrastructure that ensures every home, business, institution, and public space in Samarthaka city has seamless wireless connectivity—supporting education, healthcare, transport, and smart governance.<br>The Wireless Internet Tower Grid for Samarthaka consists of strategically placed communication towers connected through fiber-optic backbones and microwave relay links. Each tower covers a circular or sector-shaped region, forming an overlapping mesh so there are no dead zones.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>9, 11</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Infrastructure/sequence2.png" class="sequence">

            <p><b>Building the Communication Backbone: </b>To create a robust, central network backbone that connects all major towers together using the minimum possible total length of high-speed fiber or microwave links, starting construction from a central hub.<br> <br>

            <b>The Algorithm: </b><b>Prim's MST</b> is used to build a Minimum Spanning Tree (MST). It starts from an arbitrary "root" tower (perhaps your main data center connection). It then iteratively adds the closest (cheapest connection) neighboring tower that isn't yet part of the backbone. This process repeats until all towers are connected, ensuring the most cost-effective, loop-free backbone structure grows outwards from the center.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/prims.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Extract-Min</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
    </tr>

    <tr>
      <td>Decrease-Key</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>
  </table>


             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Route Internet Packets: </b>To determine the absolute fastest path for data packets to travel between any two towers in the entire grid, ensuring that no matter where a user is and which server they need to reach, the data takes the optimal route.<br> <br>

            <b>The Algorithm: </b><b>Floyd-Warshall</b> is an "all-pairs shortest path" algorithm. It analyzes the entire network graph and calculates the shortest path between every possible combination of source tower and destination tower. The result is a comprehensive routing table (a matrix) that the network uses to immediately know the best path for any packet, regardless of its entry and exit points in the grid.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/floyd.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Matrix Initialization</td>
      <td>O(V²)</td>
      <td>O(V²)</td>
      <td>O(V²)</td>
    </tr>

    <tr>
      <td>Triple Loop Updates</td>
      <td>O(V³)</td>
      <td>O(V³)</td>
      <td>O(V³)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(V³)</td>
      <td>O(V³)</td>
      <td>O(V³)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>
            <p><b>Tower Failure Handling & Rerouting: </b>To provide near-instantaneous recovery when a tower goes offline by immediately switching traffic to pre-calculated backup paths, minimizing service interruption for users.<br> <br>

            <b>The Algorithm: </b><b>Hashing</b> A Hash Table is used for ultra-fast lookups. The system maintains a table where the "key" is the ID of a specific tower, and the corresponding "value" is the pre-determined backup routing plan for that tower. When a tower failure is detected, the system hashes the failed tower's ID to instantly retrieve its backup route from the table (in O(1) constant time) and re-directs traffic without needing to recalculate the entire network topology.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/hash.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Search / Deletion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>


             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>
            <p><b>Load Balancing & Bandwidth Allocation: </b>To efficiently manage user demand by organizing bandwidth requests, ensuring that network resources are allocated fairly and that no single access point becomes overwhelmed by too many high-demand users.<br> <br>

            <b>The Algorithm: </b><b>Binary Search Tree - BST</b> A Binary Search Tree is used to maintain an organized structure of active user sessions or bandwidth requests, sorted by their consumption level (e.g., low bandwidth users on the left branch, high bandwidth on the right). Because the data is sorted hierarchically, the system can efficiently search for available bandwidth slots, identify top consumers, and reallocate resources to balance the load across different parts of the network.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/bst.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Search</td>
      <td>O(1)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Insertion / Deletion</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>


             </div>


            </div>

            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
#include &lt;limits&gt;

using namespace std;

ofstream fout("output.txt");   // All output will go here

const int MAX_NODES = 50;
const int MAX_EDGES = 200;
const int HASH_SIZE = 101;
const int INF = 1000000000;

// -------------------------------
// Graph storage (for Prim + Floyd)
// -------------------------------
int N, M;                         // number of towers, number of links
int graphMat[MAX_NODES][MAX_NODES];

struct Edge {
    int u, v, w;
};

Edge edges[MAX_EDGES];

// -------------------------------
// 1) Prim's MST (Backbone building)
// -------------------------------
void runPrimMST(int root) {
    bool inMST[MAX_NODES];
    int key[MAX_NODES];        // min edge weight to connect this node
    int parent[MAX_NODES];     // parent in MST

    for (int i = 0; i &lt; N; ++i) {
        inMST[i] = false;
        key[i] = INF;
        parent[i] = -1;
    }

    key[root] = 0;

    for (int count = 0; count &lt; N - 1; ++count) {
        int u = -1;
        int best = INF;

        for (int i = 0; i &lt; N; ++i) {
            if (!inMST[i] &amp;&amp; key[i] &lt; best) {
                best = key[i];
                u = i;
            }
        }

        if (u == -1) break; // disconnected graph
        inMST[u] = true;

        // update neighbors
        for (int v = 0; v &lt; N; ++v) {
            if (graphMat[u][v] &lt; INF &amp;&amp; !inMST[v] &amp;&amp; graphMat[u][v] &lt; key[v]) {
                key[v] = graphMat[u][v];
                parent[v] = u;
            }
        }
    }

    fout &lt;&lt; "--- COMMUNICATION BACKBONE (Prim MST) ---\n";
    int totalCost = 0;
    for (int v = 0; v &lt; N; ++v) {
        if (v == root) continue;
        if (parent[v] != -1) {
            fout &lt;&lt; "Link: " &lt;&lt; parent[v] &lt;&lt; " - " &lt;&lt; v
                 &lt;&lt; "  Cost: " &lt;&lt; graphMat[parent[v]][v] &lt;&lt; "\n";
            totalCost += graphMat[parent[v]][v];
        }
    }
    fout &lt;&lt; "Total Backbone Cost = " &lt;&lt; totalCost &lt;&lt; "\n\n";
}

// -------------------------------
// 2) Floyd-Warshall (All-pairs routing)
// -------------------------------
int distFW[MAX_NODES][MAX_NODES];
int nextFW[MAX_NODES][MAX_NODES];

void runFloydWarshall() {
    // Initialize
    for (int i = 0; i &lt; N; ++i) {
        for (int j = 0; j &lt; N; ++j) {
            distFW[i][j] = graphMat[i][j];
            if (graphMat[i][j] &lt; INF &amp;&amp; i != j)
                nextFW[i][j] = j;
            else
                nextFW[i][j] = -1;
        }
    }

    // Floyd-Warshall core
    for (int k = 0; k &lt; N; ++k) {
        for (int i = 0; i &lt; N; ++i) {
            if (distFW[i][k] == INF) continue;
            for (int j = 0; j &lt; N; ++j) {
                if (distFW[k][j] == INF) continue;
                int through = distFW[i][k] + distFW[k][j];
                if (through &lt; distFW[i][j]) {
                    distFW[i][j] = through;
                    nextFW[i][j] = nextFW[i][k];
                }
            }
        }
    }
}

void printFWPath(int u, int v) {
    if (nextFW[u][v] == -1) {
        fout &lt;&lt; "No path";
        return;
    }
    int path[MAX_NODES];
    int len = 0;
    int cur = u;
    path[len++] = cur;
    while (cur != v &amp;&amp; len &lt; MAX_NODES) {
        cur = nextFW[cur][v];
        path[len++] = cur;
    }
    for (int i = 0; i &lt; len; ++i) {
        fout &lt;&lt; path[i];
        if (i + 1 &lt; len) fout &lt;&lt; " -&gt; ";
    }
}

void answerFloydQueries(int Qfw) {
    fout &lt;&lt; "--- INTERNET PACKET ROUTING (Floyd-Warshall) ---\n";
    for (int q = 0; q &lt; Qfw; ++q) {
        int src, dest;
        cin &gt;&gt; src &gt;&gt; dest;
        fout &lt;&lt; "Fastest path from Tower " &lt;&lt; src &lt;&lt; " to Tower " &lt;&lt; dest &lt;&lt; ":\n";
        if (distFW[src][dest] &gt;= INF) {
            fout &lt;&lt; "  No route available.\n\n";
        } else {
            fout &lt;&lt; "  Cost: " &lt;&lt; distFW[src][dest] &lt;&lt; "\n";
            fout &lt;&lt; "  Path: ";
            printFWPath(src, dest);
            fout &lt;&lt; "\n\n";
        }
    }
}

// -------------------------------
// 3) Hash Table (Tower failure → backup routes)
// -------------------------------
struct BackupRoute {
    int towerId;
    int count;
    int backups[10];
    bool used;
};

BackupRoute hashTable[HASH_SIZE];

int hashFunc(int key) {
    if (key &lt; 0) key = -key;
    return key % HASH_SIZE;
}

void initHash() {
    for (int i = 0; i &lt; HASH_SIZE; ++i) {
        hashTable[i].used = false;
        hashTable[i].towerId = -1;
        hashTable[i].count = 0;
    }
}

void insertBackup(int towerId, int count, int *arr) {
    int idx = hashFunc(towerId);
    for (int i = 0; i &lt; HASH_SIZE; ++i) {
        int pos = (idx + i) % HASH_SIZE;
        if (!hashTable[pos].used || hashTable[pos].towerId == towerId) {
            hashTable[pos].used = true;
            hashTable[pos].towerId = towerId;
            hashTable[pos].count = count;
            for (int j = 0; j &lt; count; ++j) {
                hashTable[pos].backups[j] = arr[j];
            }
            return;
        }
    }
}

BackupRoute* findBackup(int towerId) {
    int idx = hashFunc(towerId);
    for (int i = 0; i &lt; HASH_SIZE; ++i) {
        int pos = (idx + i) % HASH_SIZE;
        if (!hashTable[pos].used) return nullptr;
        if (hashTable[pos].towerId == towerId) return &amp;hashTable[pos];
    }
    return nullptr;
}

void runFailureHandling(int Qfail) {
    fout &lt;&lt; "--- TOWER FAILURE HANDLING (Hash Table) ---\n";
    for (int i = 0; i &lt; Qfail; ++i) {
        int failedId;
        cin &gt;&gt; failedId;
        fout &lt;&lt; "Tower " &lt;&lt; failedId &lt;&lt; " FAILED.\n";
        BackupRoute* br = findBackup(failedId);
        if (br == nullptr || br-&gt;count == 0) {
            fout &lt;&lt; "  No precomputed backup route.\n\n";
        } else {
            fout &lt;&lt; "  Backup route via towers: ";
            for (int j = 0; j &lt; br-&gt;count; ++j) {
                fout &lt;&lt; br-&gt;backups[j];
                if (j + 1 &lt; br-&gt;count) fout &lt;&lt; " -&gt; ";
            }
            fout &lt;&lt; "\n\n";
        }
    }
}

// -------------------------------
// 4) BST for Load Balancing
// -------------------------------
struct SessionNode {
    int userId;
    int bandwidth;    // Mbps used
    SessionNode *left;
    SessionNode *right;
};

SessionNode* newNode(int userId, int bandwidth) {
    SessionNode* node = new SessionNode;
    node-&gt;userId = userId;
    node-&gt;bandwidth = bandwidth;
    node-&gt;left = node-&gt;right = nullptr;
    return node;
}

SessionNode* insertSession(SessionNode* root, int userId, int bandwidth) {
    if (root == nullptr) return newNode(userId, bandwidth);
    if (bandwidth &lt; root-&gt;bandwidth)
        root-&gt;left = insertSession(root-&gt;left, userId, bandwidth);
    else
        root-&gt;right = insertSession(root-&gt;right, userId, bandwidth);
    return root;
}

void inorderSessions(SessionNode* root) {
    if (!root) return;
    inorderSessions(root-&gt;left);
    fout &lt;&lt; "User " &lt;&lt; root-&gt;userId &lt;&lt; " - Bandwidth " &lt;&lt; root-&gt;bandwidth &lt;&lt; " Mbps\n";
    inorderSessions(root-&gt;right);
}

void findMaxSession(SessionNode* root, int &amp;maxBw, int &amp;maxUser) {
    if (!root) return;
    if (root-&gt;bandwidth &gt; maxBw) {
        maxBw = root-&gt;bandwidth;
        maxUser = root-&gt;userId;
    }
    findMaxSession(root-&gt;left, maxBw, maxUser);
    findMaxSession(root-&gt;right, maxBw, maxUser);
}

void runLoadBalancing(SessionNode* root) {
    fout &lt;&lt; "--- LOAD BALANCING (BST of Sessions) ---\n";
    fout &lt;&lt; "Active sessions sorted by bandwidth:\n";
    inorderSessions(root);
    int maxBw = -1, maxUser = -1;
    findMaxSession(root, maxBw, maxUser);
    if (maxBw != -1) {
        fout &lt;&lt; "\nTop bandwidth consumer: User " &lt;&lt; maxUser
             &lt;&lt; " with " &lt;&lt; maxBw &lt;&lt; " Mbps\n";
    }
    fout &lt;&lt; "\n";
}

// -------------------------------
// MAIN
// -------------------------------
int main() {
    // 1) Read towers &amp; links
    cin &gt;&gt; N &gt;&gt; M;

    // Initialize adjacency matrix
    for (int i = 0; i &lt; N; ++i) {
        for (int j = 0; j &lt; N; ++j) {
            if (i == j) graphMat[i][j] = 0;
            else graphMat[i][j] = INF;
        }
    }

    for (int i = 0; i &lt; M; ++i) {
        int u, v, w;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        edges[i].u = u;
        edges[i].v = v;
        edges[i].w = w;
        if (w &lt; graphMat[u][v]) {      // keep smallest if multiple
            graphMat[u][v] = w;
            graphMat[v][u] = w;
        }
    }

    // 2) Prim MST (backbone)
    int rootTower;
    cin &gt;&gt; rootTower;
    runPrimMST(rootTower);

    // 3) Floyd-Warshall (all-pairs)
    runFloydWarshall();
    int Qfw;
    cin &gt;&gt; Qfw;
    answerFloydQueries(Qfw);

    // 4) Hash table for tower failure backup routes
    initHash();
    int H;
    cin &gt;&gt; H;
    for (int i = 0; i &lt; H; ++i) {
        int towerId, cnt;
        cin &gt;&gt; towerId &gt;&gt; cnt;
        int temp[10];
        for (int j = 0; j &lt; cnt; ++j) {
            cin &gt;&gt; temp[j];
        }
        insertBackup(towerId, cnt, temp);
    }

    int Qfail;
    cin &gt;&gt; Qfail;
    runFailureHandling(Qfail);

    // 5) BST for load balancing
    int S;
    cin &gt;&gt; S;
    SessionNode* root = nullptr;
    for (int i = 0; i &lt; S; ++i) {
        int uid, bw;
        cin &gt;&gt; uid &gt;&gt; bw;
        root = insertSession(root, uid, bw);
    }
    runLoadBalancing(root);

    fout.close();
    return 0;
}









    </div>

    <div class="data-input">

50 54
0 1 2
1 2 3
2 3 4
3 4 5
4 5 6
5 6 7
6 7 8
7 8 9
8 9 10
9 10 2
10 11 3
11 12 4
12 13 5
13 14 6
14 15 7
15 16 8
16 17 9
17 18 10
18 19 2
19 20 3
20 21 4
21 22 5
22 23 6
23 24 7
24 25 8
25 26 9
26 27 10
27 28 2
28 29 3
29 30 4
30 31 5
31 32 6
32 33 7
33 34 8
34 35 9
35 36 10
36 37 2
37 38 3
38 39 4
39 40 5
40 41 6
41 42 7
42 43 8
43 44 9
44 45 10
45 46 2
46 47 3
47 48 4
48 49 5
49 0 5
0 10 7
10 20 4
20 30 6
30 40 3

0
3
0 25
5 40
12 33

5
5 2 4 6
10 3 0 9 11
20 2 10 30
25 2 20 26
40 2 30 41

3
5
10
40

10
101 5
102 10
103 3
104 20
105 15
106 25
107 8
108 12
109 18
110 30




    </div>

    <div class="data-output">

--- COMMUNICATION BACKBONE (Prim MST) ---
Link: 0 - 1  Cost: 2
Link: 1 - 2  Cost: 3
Link: 2 - 3  Cost: 4
Link: 3 - 4  Cost: 5
Link: 4 - 5  Cost: 6
Link: 5 - 6  Cost: 7
Link: 6 - 7  Cost: 8
Link: 7 - 8  Cost: 9
Link: 10 - 9  Cost: 2
Link: 0 - 10  Cost: 7
Link: 10 - 11  Cost: 3
Link: 11 - 12  Cost: 4
Link: 12 - 13  Cost: 5
Link: 13 - 14  Cost: 6
Link: 14 - 15  Cost: 7
Link: 15 - 16  Cost: 8
Link: 16 - 17  Cost: 9
Link: 19 - 18  Cost: 2
Link: 20 - 19  Cost: 3
Link: 10 - 20  Cost: 4
Link: 20 - 21  Cost: 4
Link: 21 - 22  Cost: 5
Link: 22 - 23  Cost: 6
Link: 23 - 24  Cost: 7
Link: 24 - 25  Cost: 8
Link: 25 - 26  Cost: 9
Link: 28 - 27  Cost: 2
Link: 29 - 28  Cost: 3
Link: 30 - 29  Cost: 4
Link: 20 - 30  Cost: 6
Link: 30 - 31  Cost: 5
Link: 31 - 32  Cost: 6
Link: 32 - 33  Cost: 7
Link: 33 - 34  Cost: 8
Link: 34 - 35  Cost: 9
Link: 37 - 36  Cost: 2
Link: 38 - 37  Cost: 3
Link: 39 - 38  Cost: 4
Link: 40 - 39  Cost: 5
Link: 30 - 40  Cost: 3
Link: 40 - 41  Cost: 6
Link: 41 - 42  Cost: 7
Link: 42 - 43  Cost: 8
Link: 43 - 44  Cost: 9
Link: 46 - 45  Cost: 2
Link: 47 - 46  Cost: 3
Link: 48 - 47  Cost: 4
Link: 49 - 48  Cost: 5
Link: 0 - 49  Cost: 5
Total Backbone Cost = 259

--- INTERNET PACKET ROUTING (Floyd-Warshall) ---
Fastest path from Tower 0 to Tower 25:
  Cost: 41
  Path: 0 -> 10 -> 20 -> 21 -> 22 -> 23 -> 24 -> 25

Fastest path from Tower 5 to Tower 40:
  Cost: 40
  Path: 5 -> 4 -> 3 -> 2 -> 1 -> 0 -> 10 -> 20 -> 30 -> 40

Fastest path from Tower 12 to Tower 33:
  Cost: 35
  Path: 12 -> 11 -> 10 -> 20 -> 30 -> 31 -> 32 -> 33

--- TOWER FAILURE HANDLING (Hash Table) ---
Tower 5 FAILED.
  Backup route via towers: 4 -> 6

Tower 10 FAILED.
  Backup route via towers: 0 -> 9 -> 11

Tower 40 FAILED.
  Backup route via towers: 30 -> 41

--- LOAD BALANCING (BST of Sessions) ---
Active sessions sorted by bandwidth:
User 103 - Bandwidth 3 Mbps
User 101 - Bandwidth 5 Mbps
User 107 - Bandwidth 8 Mbps
User 102 - Bandwidth 10 Mbps
User 108 - Bandwidth 12 Mbps
User 105 - Bandwidth 15 Mbps
User 109 - Bandwidth 18 Mbps
User 104 - Bandwidth 20 Mbps
User 106 - Bandwidth 25 Mbps
User 110 - Bandwidth 30 Mbps

Top bandwidth consumer: User 110 with 30 Mbps



        
    </div>
</div>





        </div>

        <div class="content-box">
            <h3>Integrated Waste management system</h3>
            <div class="rule"></div>

            <p>The Integrated Waste Management System in Samarthaka uses smart sensors in public dustbins to monitor fill levels in real time. This data is sent to a central control dashboard, where collection routes are dynamically optimized so trucks only visit bins that are actually full. The city is divided into zones, each equipped with waste. <br> A digital tracking system records the journey of waste—from bin to truck to processing center—ensuring complete transparency. Recycling centers use compactors, sorters, and shredders to recover materials, while organic waste is sent to biogas plants or composting sites. The system reduces landfill usage, lowers pollution, and ensures a clean, sustainable city environment.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>11, 12</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>


            <img src="Infrastructure/sequence3.png" class="sequence">

            <p><b>Route optimization for garbage trucks: </b>To find the most efficient routes for garbage trucks, which works well when routes have varying weights such as traffic, distance, or time. The system can also handle negative weights, which can represent delays.<br> <br>

            <b>The Algorithm: </b><b>Bellman-Ford</b> algorithm is used to calculate the shortest paths in a network where edges can have different weights, including negative ones, ensuring trucks take the most optimal path even with varying conditions.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/bellman.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Edge Relaxation</td>
      <td>O(E)</td>
      <td>O(VE)</td>
      <td>O(VE)</td>
    </tr>

    <tr>
      <td>Negative Cycle Check</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E)</td>
      <td>O(VE)</td>
      <td>O(VE)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Waste segregation (categorizing recyclable, organic, toxic): </b>To provide fast categorization of waste items based on their material type names or codes, such as "plastic" or "paper".<br> <br>

            <b>The Algorithm: </b><b>Trie</b> or prefix tree, is used for its efficient search and insertion properties, allowing for rapid identification and sorting of waste materials based on their textual descriptions or identifiers.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/trie.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Insertion</td>
      <td>O(L)</td>
      <td>O(L)</td>
      <td>O(L)</td>
    </tr>

    <tr>
      <td>Search / Prefix</td>
      <td>O(L)</td>
      <td>O(L)</td>
      <td>O(L)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N × L)</td>
      <td>O(N × L)</td>
      <td>O(N × L)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Processing facility load balancing: </b>To maintain a fair and even distribution of incoming waste across multiple processing facilities to ensure no single facility is overburdened.<br> <br>

            <b>The Algorithm: </b><b>Red-Black Tree</b> is a self-balancing binary search tree that automatically keeps its height small, ensuring that the distribution of load (represented by the nodes) remains balanced across the available facilities.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/red.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Search</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Insertion / Deletion</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>
            <p><b>Fault detection in bins, trucks, or sensors: </b>To allow for a fast search through a large number of units (bins, trucks, sensors) to quickly identify any that are malfunctioning.<br> <br>

            <b>The Algorithm: </b><b>Skip List</b> is a probabilistic data structure that allows for fast search, insertion, and deletion operations, serving as an efficient alternative to balanced trees for quickly locating faulty units.</p>
            <br>

            <div class="image-box">
             <img src="Infrastructure/skip.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Search</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Insertion / Deletion</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

// Max-Heap Implementation for Power Grid
int main() {
    priority_queue&lt;int&gt; pq;
    pq.push(100); // Solar
    pq.push(80);  // Wind
    pq.push(120); // Thermal
    
    cout << "Optimal Source: " << pq.top() << " MW";
    return 0;
}
    </div>

    <div class="data-input">
3
100 80 120
    </div>

    <div class="data-output">
Optimal Source: 120 MW
    </div>
</div>


        </div>

        </div>

        
       

        <h2 class="section-heading">Transport Network</h2>

        <div class="content-box-container">
            <div class="content-box">
            <h3>Metro Transit System & Digital Ticketing</h3>
            <div class="rule"></div>
            <p>The Metro Transit System in Samarthaka provides a fast, clean, and efficient mode of urban transport that connects major residential zones, commercial districts, and business hubs. It is designed with smart scheduling, automatic fare collection, real-time crowd monitoring, and optimized route planning to ensure smooth mobility for citizens.<br>The system uses digital sensors, central control units, and communication between stations to maintain punctuality, safety, and energy efficiency. By reducing traffic congestion, lowering pollution, and enabling seamless travel, the metro becomes the backbone of sustainable mobility in the city.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>9, 11</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Transport/sequence1.png" class="sequence">

            <p><b>Route Planning & Shortest Travel Time: </b>To enable passengers to instantly find the quickest route between any two metro stations within the expansive Samarthaka network, considering varying travel times between different stretches as the "cost."<br> <br>

            <b>The Algorithm: </b><b>Dijkstra’s Algorithm</b> models the metro network as a graph where stations are nodes and connecting tracks are edges, weighted by their specific travel times. Starting from the passenger's chosen entry station, the algorithm systematically explores neighboring nodes to calculate the path with the absolute minimum total travel time to the destination, ensuring passengers are always directed to the fastest route.</p>
            <br>

            <div class="image-box">
             <img src="Transport/dij.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Extract-Min Operations</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
    </tr>

    <tr>
      <td>Decrease-Key Operations</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
    </tr>
  </table>



             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Train Scheduling & Dispatch Timing: </b>To manage the dynamic and tight schedule of train departures efficiently. The system must ensure trains are dispatched precisely on time and that timetable adjustments—due to unexpected delays or the insertion of extra peak-hour trains—are handled instantly without disrupting the overall operational flow.<br> <br>

            <b>The Algorithm: </b><b>AVL Tree</b> An AVL tree is a self-balancing binary search tree used here to store scheduled train departure times chronologically. The tree automatically maintains its balance after every insertion or deletion, the system can perform operations like searching for the next immediate departure, adding a new train slot etc.</p>
            <br>

            <div class="image-box">
             <img src="Transport/avl.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Search</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Insertion / Deletion</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>



            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>
            <p><b>Passenger Load Monitoring (Crowd Density): </b>To monitor real-time crowd density on moving trains across different segments of the metro line. This allows operators to identify overcrowded stretches instantly and make data-driven decisions, such as deploying extra trains or regulating station entry.<br> <br>

            <b>The Algorithm: </b><b>Fenwick Tree (Binary Indexed Tree)</b> A Fenwick Tree is a specialized data structure designed for efficiently updating values and calculating prefix sums. In this context, it tracks the net number of passengers on board. As passengers board or alight at a station (a "point update"), the tree updates instantly.</p>
            <br>

            <div class="image-box">
             <img src="Transport/fenwick.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Update Value</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Prefix Sum Query</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>
            <p><b>Ticketing & Metro Card Validation: </b>To provide near-instantaneous validation of thousands of metro cards per minute at entry and exit gates. This ensures a seamless, rapid flow of passengers, preventing queues at turnstiles while instantly verifying card validity and sufficient balance.<br> <br>

            <b>The Algorithm: </b><b>Hashing</b> Hashing utilizes a hash table to store the database of millions of active user profiles. The unique ID embedded in the metro card acts as the "key." When a passenger taps their card, a hash function uses this key to compute the exact location of their data in memory.</p>
            <br>

            <div class="image-box">
             <img src="Transport/hash.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Preprocessing (LPS)</td>
      <td>O(M)</td>
      <td>O(M)</td>
      <td>O(M)</td>
    </tr>

    <tr>
      <td>Pattern Search</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

// Max-Heap Implementation for Power Grid
int main() {
    priority_queue&lt;int&gt; pq;
    pq.push(100); // Solar
    pq.push(80);  // Wind
    pq.push(120); // Thermal
    
    cout << "Optimal Source: " << pq.top() << " MW";
    return 0;
}
    </div>

    <div class="data-input">
3
100 80 120
    </div>

    <div class="data-output">
Optimal Source: 120 MW
    </div>
</div>






        </div>

        <div class="content-box">
            <h3>Medical Green Corridors</h3>
            <div class="rule"></div>
            <p>A Medical Green Corridor is a special, high-priority, traffic-free route created to transport organs, critical medical supplies, or emergency patients from one point to another in the shortest possible time.<br>Traffic police, hospitals, and ambulance control rooms coordinate to create a fast, uninterrupted pathway by adjusting traffic signals and clearing roads.It requires real-time decision-making, routing, monitoring, and communication—making it perfect for demonstrating algorithms.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>3, 9, 11</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Transport/sequence2.png" class="sequence">

            <p><b>Route Planning & Shortest Travel Time: </b>Find the fastest path for an ambulance considering real-time traffic.<br> <br>

            <b>The Algorithm: </b><b>Dijkstra’s Algorithm</b> Calculates the path with the lowest total travel time by exploring routes from the starting point.</p>
            <br>

            <div class="image-box">
             <img src="Transport/dij2.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Extract-Min Operations</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
    </tr>

    <tr>
      <td>Decrease-Key Operations</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
    </tr>
  </table>


             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Resource Allocation & Scheduling: </b>Prioritize emergency requests and dispatch the nearest appropriate resources (ambulances, teams).<br> <br>

            <b>The Algorithm: </b><b>Merge/Quick Sort</b> Rapidly sorts incoming requests by medical severity to prioritize critical cases.</p>
            <br>

            <div class="image-box">
             <img src="Transport/sort.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Divide Step</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Merge Step</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Traffic Signal Optimization & Clearance: </b>Create a synchronized "green wave" of traffic lights along the ambulance's route.<br> <br>

            <b>The Algorithm: </b><b>BFS</b> Explores intersections layer by layer ahead of the ambulance to preemptively clear the path.</p>
            <br>

            <div class="image-box">
             <img src="Transport/bfs.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Visit Vertices</td>
      <td>O(V)</td>
      <td>O(V)</td>
      <td>O(V)</td>
    </tr>

    <tr>
      <td>Traverse Edges</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Live Monitoring & Emergency Handling: </b>Detect unexpected blockages on the route and quickly find alternative paths.<br> <br>

            <b>The Algorithm: </b><b>DFS</b> Deeply explores specific detour options to find a viable workaround when the primary route fails.</p>
            <br>

            <div class="image-box">
             <img src="Transport/dfs.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Visit Vertices</td>
      <td>O(V)</td>
      <td>O(V)</td>
      <td>O(V)</td>
    </tr>

    <tr>
      <td>Traverse Edges</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

// Max-Heap Implementation for Power Grid
int main() {
    priority_queue&lt;int&gt; pq;
    pq.push(100); // Solar
    pq.push(80);  // Wind
    pq.push(120); // Thermal
    
    cout << "Optimal Source: " << pq.top() << " MW";
    return 0;
}
    </div>

    <div class="data-input">
3
100 80 120
    </div>

    <div class="data-output">
Optimal Source: 120 MW
    </div>
</div>

            



        </div>

        

        </div>

        
        
        <h2 class="section-heading">Semiconductor R&D</h2>

        <div class="content-box-container">

            <div class="content-box">
            <h3>Chip Design & Architecture Development</h3>

            <div class="rule"></div>
            <p>Chip design and architecture development is the process of creating semiconductor chips that power devices like computers, mobiles, electric vehicles, and IoT systems.
            It involves planning the architecture, designing logic circuits, optimizing layouts, routing connections, and ensuring efficiency, speed, and thermal stability.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>8, 9, 12</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Semiconductor/sequence1.png" class="sequence">

            <p><b>Architecture Planning: </b>Find the optimal arrangement of major functional blocks on the chip die to fit constraints and maximize performance.<br> <br>

            <b>The Algorithm: </b><b>Backtracking</b> Explores potential placement configurations on a grid; if a placement violates design rules, it backtracks to try alternative arrangements until a valid layout is found.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/backtrack.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Constraint Check</td>
      <td>O(1)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>State Space Traversal</td>
      <td>O(N)</td>
      <td>O(b^N)</td>
      <td>O(b^N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N)</td>
      <td>O(b^N)</td>
      <td>O(b^N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Logic Circuit Verification: </b>Ensure the digital logic circuits function correctly by checking for connectivity errors, loops, or faults before manufacturing.<br> <br>

            <b>The Algorithm: </b><b>DFS (Depth-First Search)</b> Treats the circuit as a graph, diving deep along signal paths from inputs to outputs to exhaustively test logic states and ensure complete connectivity.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/dfs.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Visit Vertices</td>
      <td>O(V)</td>
      <td>O(V)</td>
      <td>O(V)</td>
    </tr>

    <tr>
      <td>Traverse Edges</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
      <td>O(V + E)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Physical Layout & Routing: </b>Connect all chip components with the minimum total length of wiring to reduce signal delay and power consumption.<br> <br>

            <b>The Algorithm: </b><b>Kruskal’s Minimum Spanning Tree</b> Selects the shortest necessary wiring paths between components to create a complete network connection without redundant loops, minimizing overall wire usage.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/kruskal.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Sorting Edges</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>

    <tr>
      <td>Union–Find Operations</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>
  </table>

  
                



             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Performance & Thermal Optimization: </b>Analyze massive simulation datasets to identify critical performance bottlenecks and high-temperature areas (hotspots) on the chip.<br> <br>

            <b>The Algorithm: </b><b>Merge Sort</b> Efficiently sorts huge volumes of simulation data (like timing delays or temperature readings) to quickly isolate the worst-case scenarios requiring optimization.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/mergesort.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Divide Step</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Merge Step</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

// Max-Heap Implementation for Power Grid
int main() {
    priority_queue&lt;int&gt; pq;
    pq.push(100); // Solar
    pq.push(80);  // Wind
    pq.push(120); // Thermal
    
    cout << "Optimal Source: " << pq.top() << " MW";
    return 0;
}
    </div>

    <div class="data-input">
3
100 80 120
    </div>

    <div class="data-output">
Optimal Source: 120 MW
    </div>
</div>

            



        </div>
            <div class="content-box">
            <h3>Wafer Fabrication & Defect Detection</h3>

            <div class="rule"></div>
            <p>Wafer fabrication is the process of creating semiconductor chips on ultra-pure silicon wafers through nanometer-level layering, etching, doping, and lithography.
           <br>After each stage, wafers are inspected because even a tiny particle, scratch, or pattern mismatch can destroy thousands of chips.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>4, 8, 9, 11, 12</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Semiconductor/sequence2.png" class="sequence">

            <p><b>Wafer Layer Formation & Lithography Planning: </b>Determine the optimal sequence of processing steps (layer deposition, patterning, etching) to construct the complex 3D chip structure without violating any design rules.<br> <br>

            <b>The Algorithm: </b><b>Backtracking</b> Systematically builds a sequence of process steps. If a proposed step is found to violate a design constraint (e.g., creates an impossible feature size), the algorithm backtracks to the previous valid step and tries a different parameter or process to find a workable fabrication sequence.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/backtrack2.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Constraint Check</td>
      <td>O(1)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>State Space Traversal</td>
      <td>O(N)</td>
      <td>O(b^N)</td>
      <td>O(b^N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N)</td>
      <td>O(b^N)</td>
      <td>O(b^N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Optical Inspection & Image-Based Defect Detection: </b>Rapidly identify visual anomalies like particles, scratches, or pattern irregularities on the wafer surface by comparing high-resolution images against a known good reference.<br> <br>

            <b>The Algorithm: </b><b>KMP Pattern Matching</b> Adapted for 2D image data, this algorithm efficiently searches for the expected reference pattern within the captured image of the wafer. By avoiding redundant comparisons, it quickly locates mismatches, flagging them as potential defects for further review.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/kmp.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Preprocessing (LPS)</td>
      <td>O(M)</td>
      <td>O(M)</td>
      <td>O(M)</td>
    </tr>

    <tr>
      <td>Pattern Search</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Electrical Testing & Circuit Path Validation: </b>Verify the electrical integrity of the fabricated paths, ensuring that critical signals can travel between points with the correct resistance and that there are no open or short circuits.<br> <br>

            <b>The Algorithm: </b><b>Dijkstra’s Algorithm</b> Models the chip's electrical network as a graph where nodes are test points and edges are connections weighted by resistance. It calculates the path of least resistance between probes; deviations from the expected value indicate a physical defect in the circuit path.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/dij.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Extract-Min Operations</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
      <td>O(V log V)</td>
    </tr>

    <tr>
      <td>Decrease-Key Operations</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
      <td>O(E log V)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
      <td>O((V + E) log V)</td>
    </tr>
  </table>


             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>
            <p><b>Yield Analysis, Classification & Defect Mapping: </b>Process massive datasets of collected defects to categorize them, map their physical locations on the wafer, and identify systematic manufacturing problems to improve overall yield.<br> <br>

            <b>The Algorithm: </b><b>Merge Sort</b>A highly efficient and stable sorting algorithm used to organize millions of defect records by various criteria (e.g., size, location, type). This sorted data allows for quick grouping, statistical analysis, and the generation of detailed defect maps to pinpoint problem areas.</p>
            <br>

            <div class="image-box">
             <img src="Semiconductor/merge2.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Divide Step</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Merge Step</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

// Max-Heap Implementation for Power Grid
int main() {
    priority_queue&lt;int&gt; pq;
    pq.push(100); // Solar
    pq.push(80);  // Wind
    pq.push(120); // Thermal
    
    cout << "Optimal Source: " << pq.top() << " MW";
    return 0;
}
    </div>

    <div class="data-input">
3
100 80 120
    </div>

    <div class="data-output">
Optimal Source: 120 MW
    </div>
</div>

            





        </div>

        

        </div>
         
       

        <h2 class="section-heading">Cultural Hub</h2>

        <div class="content-box-container">

             <div class="content-box">
            <h3>Intelligent Event Scheduling & Space Optimization</h3>
            <div class="rule"></div>
             <p>Intelligent Event Scheduling & Space Optimization is a smart-city system that automatically manages events, venues, spaces, time slots, resources, and crowd flow.
             It ensures, no overlapping events,maximum utilization of public spaces,efficient crowd movement, optimal use of auditoriums, halls, parks, and convention centers, automatic conflict resolution and rescheduling</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p> 8, 9, 11, 12, 16</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="CulturalHub/sequence1.png" class="sequence">

            <p><b>Event Request & Time Slot Matching: </b>Rapidly search available time slots to match incoming event requests with suitable openings.<br> <br>

            <b>The Algorithm: </b><b>Binary Search Tree</b> Organizes time slots hierarchically, allowing the system to search, insert, or confirm venue availability for a specific time range with high efficiency (O(log n)).</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/bst.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Search</td>
      <td>O(1)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Insertion / Deletion</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>

            <p><b>Conflict Detection & Resource Linking: </b>Instantly determine if required resources (like A/V equipment or specific rooms) are already in use to prevent double-booking.<br> <br>

            <b>The Algorithm: </b><b>Union–Find</b>Tracks elements partitioned into disjoint sets. It quickly checks if a requested resource is already "united" with another active event, signaling a conflict.</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/union-find.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Find Operation</td>
      <td>O(1)</td>
      <td>O(α(N))</td>
      <td>O(α(N))</td>
    </tr>

    <tr>
      <td>Union Operation</td>
      <td>O(1)</td>
      <td>O(α(N))</td>
      <td>O(α(N))</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>

            <p><b>Venue Allocation & Space Optimization: </b>Connect events to the most appropriate venues while minimizing wasted capacity or travel distance between related sessions.<br> <br>

            <b>The Algorithm: </b><b>Kruskal's algorithm</b> treats events and venues as a graph, selecting the "edges" (allocations) with the lowest "cost" (best fit/closest distance) first to build an efficient allocation network without cycles or redundancies.</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/kruskal.png" class="image">

             <div class="efficiency-box">


                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Sorting Edges</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>

    <tr>
      <td>Union–Find Operations</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
      <td>O(E log E)</td>
    </tr>
  </table>

  


                
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>

            <p><b>Final Schedule Ordering & Publication: </b>compile all confirmed bookings into a single, chronologically sorted master schedule for public view.<br> <br>

            <b>The Algorithm: </b><b>Merge Sort</b> efficiently organizes the complete list of finalized event data into time order, ensuring a stable and predictably sorted schedule ready for publishing.</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/merge.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Divide Step</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Merge Step</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

// Max-Heap Implementation for Power Grid
int main() {
    priority_queue&lt;int&gt; pq;
    pq.push(100); // Solar
    pq.push(80);  // Wind
    pq.push(120); // Thermal
    
    cout << "Optimal Source: " << pq.top() << " MW";
    return 0;
}
    </div>

    <div class="data-input">
3
100 80 120
    </div>

    <div class="data-output">
Optimal Source: 120 MW
    </div>
</div>

            


        </div>

        <div class="content-box">
            <h3>Smart Visitor Flow Prediction & Crowd Management</h3>
            <div class="rule"></div>
            <p>Smart Visitor Flow Prediction & Crowd Management helps Samarthaka monitor how people move through parks, events, markets, stations, temples, sports zones, and public spaces. The system analyzes visitor patterns, predicts where crowds will form, and guides people safely using dynamic routing and smart alerts.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>3, 9, 11, 12, 16</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="CulturalHub/sequence2.png" class="sequence">

            <p><b>Real-Time Visitor Data Collection: </b>To instantly log and track the entry, movements, and exit of tens of thousands of individual visitors across city checkpoints in real-time.<br> <br>

            <b>The Algorithm: </b><b>Hashing</b> uses a hash table to map unique visitor identifiers (like ticket IDs or RFID tags) directly to their location records.</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/hash.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Search / Deletion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>

            <p><b>Zone Density Monitoring & Updates: </b>To continuously calculate and update the total number of people present within specific defined zones (like a market square or a street segment) to detect overcrowding instantly.<br> <br>

            <b>The Algorithm: </b><b>Segment tree</b> stores visitor counts in a hierarchical tree structure representing spatial intervals. This allows the system to rapidly update counts as individuals move and instantaneously query the total density over any range of contiguous zones (O(log n)).</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/segment.png" class="image">

             <div class="efficiency-box">

                 <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Tree Construction</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Query / Update</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    
  </table>


             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>

            <p><b>Safe Path Prediction & Crowd Flow Routing: </b>To determine congestion-free routes to guide crowds during peak times or emergencies, adapting to rapidly changing street conditions.<br> <br>

            <b>The Algorithm: </b><b>Bellman-Ford</b> calculates the shortest (safest/fastest) paths from a source to various destinations. It is chosen here for its ability to handle complex graphs where edge weights (congestion levels) change dynamically, ensuring that visitors aren't routed into areas where movement has become impossible</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/bellman.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Edge Relaxation</td>
      <td>O(E)</td>
      <td>O(VE)</td>
      <td>O(VE)</td>
    </tr>

    <tr>
      <td>Negative Cycle Check</td>
      <td>O(E)</td>
      <td>O(E)</td>
      <td>O(E)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(E)</td>
      <td>O(VE)</td>
      <td>O(VE)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>

            <p><b>Priority-Based Crowd Management Actions: </b>To efficiently manage a queue of required interventions—such as deploying staff, opening overflow exits, or issuing alerts—by addressing the most critical situations first.<br> <br>

            <b>The Algorithm: </b><b>Heap / Priority Queue </b>Organizes all necessary crowd control actions based on an urgency score. A Max-Heap ensures that the highest-priority task (e.g., a zone exceeding safe capacity) is always at the top for immediate execution.</p>
            <br>

            <div class="image-box">
             <img src="CulturalHub/heap.png" class="image">

             <div class="efficiency-box">

                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>
    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Deletion (Extract-Max)</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Updating Priority</td>
      <td>O(1)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>Retrieving Max</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
  </table>

             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

// Max-Heap Implementation for Power Grid
int main() {
    priority_queue&lt;int&gt; pq;
    pq.push(100); // Solar
    pq.push(80);  // Wind
    pq.push(120); // Thermal
    
    cout << "Optimal Source: " << pq.top() << " MW";
    return 0;
}
    </div>

    <div class="data-input">
3
100 80 120
    </div>

    <div class="data-output">
Optimal Source: 120 MW
    </div>
</div>

            


        </div>

        </div>
       
       
        
        <h2 class="section-heading">Sports Academy</h2>

        <div class="content-box-container">
             <div class="content-box">
            <h3>AI-Driven Athlete Performance Analytics</h3>
            <div class="rule"></div>
             <p>AI-Driven Athlete Performance Analytics helps Samarthaka’s sports academies monitor athletes more intelligently by analysing speed, stamina, reaction time, training patterns, and injury risks. The system collects sensor data, identifies patterns, compares performance over time, and gives personalized improvement suggestions.</p>

            <br>
            
            <div class="sdg-container">
            <div class="sdg-div">SDGs :</div>
            <p>3, 4, 9, 8, 11</p>
            </div>

            <br>
            <br>

            <div class="algo-div">Algorithms</div>

            <br>
            <br>
            <img src="Sports/sequence1.png" class="sequence">

            <p><b>Data Collection & Instant Retrieval: </b>Instantly store and retrieve massive volumes of individual athlete data, such as biometric readings and historical stats, using unique identifiers.<br> <br>

            <b>The Algorithm: </b><b>Hashing</b> uses a hash table to map a unique key (e.g., athlete ID) directly to the memory location of their data record, allowing for near-instantaneous access ($O(1)$ average time) regardless of database size.</p>
            <br>

            <div class="image-box">
             <img src="Sports/hash.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Search / Deletion</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>

            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->

            <br>
            <br>

            <p><b>Tracking Real-Time Performance Changes: </b>Continuously monitor and update cumulative performance metrics in real-time, such as total distance covered or aggregate training load during a session.<br> <br>

            <b>The Algorithm: </b><b>Fenwick Tree - Binary Indexed Tree</b>Efficiently updates individual data points (e.g., adding distance from a new lap) and instantly calculates cumulative totals (prefix sums) up to the current moment in logarithmic time.</p>
            <br>

            <div class="image-box">
             <img src="Sports/fen.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Update Value</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Prefix Sum Query</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Space Complexity</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>

            <p><b>Pattern Recognition in Movements & Training Cycles: </b>Identify specific, recurring sequences in sensor data or training logs that indicate optimal performance states, fatigue patterns, or potential injury risks.<br> <br>

            <b>The Algorithm: </b><b>KMP - Knuth–Morris–Pratt</b> Treats streams of movement data or training sequences as text strings, efficiently searching for specific "pattern" sequences within the larger dataset without redundant comparisons to quickly flag notable events.</p>
            <br>

            <div class="image-box">
             <img src="Sports/KMP.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Preprocessing (LPS)</td>
      <td>O(M)</td>
      <td>O(M)</td>
      <td>O(M)</td>
    </tr>

    <tr>
      <td>Pattern Search</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
      <td>O(N + M)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <!-- <button type="button" class="btn btn-success">Code</button> -->
            <br>
            <br>

            <p><b>Athlete Ranking & Report Generation: </b>Compile comprehensive performance reports and generate leaderboards by ordering athletes based on aggregated scores or specific metrics.<br> <br>

            <b>The Algorithm: </b><b>Merge Sort</b>A highly efficient, stable sorting algorithm that systematically divides the dataset of athlete scores, sorts sub-lists, and merges them back together to produce a perfectly ordered ranking list for analysis.</p>
            <br>

            <div class="image-box">
             <img src="Sports/merge.png" class="image">

             <div class="efficiency-box">
                <table class="heap-table">
    <tr>
      <th>Operation</th>
      <th>Best</th>
      <th>Average</th>
      <th>Worst</th>
    </tr>

    <tr>
      <td>Divide Step</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
      <td>O(log N)</td>
    </tr>

    <tr>
      <td>Merge Step</td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>

    <tr>
      <td>Total Time Complexity</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
      <td>O(N log N)</td>
    </tr>
  </table>
             </div>


            </div>
            <br>

            <button type="button" class="btn btn-success" onclick="openModal(this)">Code</button>

            <div class="code-data" style="display:none;">
    <div class="data-cpp">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

// Max-Heap Implementation for Power Grid
int main() {
    priority_queue&lt;int&gt; pq;
    pq.push(100); // Solar
    pq.push(80);  // Wind
    pq.push(120); // Thermal
    
    cout << "Optimal Source: " << pq.top() << " MW";
    return 0;
}
    </div>

    <div class="data-input">
3
100 80 120
    </div>

    <div class="data-output">
Optimal Source: 120 MW
    </div>
</div>

            






        </div>

        </div>
       

       
       


        <a href="../index.html" class="back-btn">← Back to Team</a>

    </div>


    <!-- /* Code tab */ -->

    <!-- Popup Modal -->
        

    <div id="codeModal" class="modal-overlay">
  <div class="code-window">
    <div class="window-header">
      <div class="dots-container">
        <span class="dot red" onclick="closeCode()"></span>
        <span class="dot yellow"></span>
        <span class="dot green"></span>
      </div>
      <div class="tabs-container">
        <button class="tab-btn active" onclick="switchTab(event, 'cpp')">Solution.cpp</button>
        <button class="tab-btn" onclick="switchTab(event, 'input')">Input.txt</button>
        <button class="tab-btn" onclick="switchTab(event, 'output')">Output.txt</button>
      </div>
    </div>
    <div class="code-body">
      <div id="cpp" class="code-content active-content"><pre><code></code></pre></div>
      <div id="input" class="code-content"><pre><code></code></pre></div>
      <div id="output" class="code-content"><pre><code></code></pre></div>
    </div>
  </div>
</div>




      


    <script src="ishi.js"></script>

</body>
</html>
