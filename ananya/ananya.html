<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ananya – Contributions</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="an.css">
</head>

<body>
<div class="page-wrapper">

    <h1 class="page-title">Ananya Kulkarni</h1>
    <p class="subtitle">Detailed Contribution Breakdown</p>

    <!-- =====================================================
         BLOCK 1: LAND & HOUSING
    ====================================================== -->
    <h2 class="section-heading">Land & Housing</h2>

    <div class="content-box-container">

        <!-- i) Master plan & zoning -->
        <div class="content-box">
            <h3>Master Plan & Zoning – Union–Find Engine</h3>
            <div class="rule"></div>

            <p>
                The master plan for Samarthaka divides land into zoning categories such as Residential, Commercial,
                Industrial, Public/Semi‑public, Transport Corridors and Green/Open Space. Each category carries its own
                bundle of regulations like FAR ranges, density bands, and buffer requirements between conflicting uses,
                turning the master plan into a clear rulebook rather than just colours on a map.
            </p>

            <p>
                To make this computable, the city is discretised into a regular 2D grid where each cell represents a
                small land parcel and stores exactly one zoning label (R, C, I, P, T or G). This simple grid lets the
                system quickly identify neighbours in four directions and attach zoning rules directly to individual
                cells, but by itself it still treats parcels as isolated points.
            </p>

            <p>
                The structure that actually groups parcels into meaningful zoning pockets is the
                <b>Union–Find (Disjoint Set / Quick‑Find)</b> layer built on top of the grid. Each cell starts in its
                own set; whenever two adjacent cells share the same zone type, the <code>unionn(u, v)</code> operation
                relabels every parcel that was in the same block as <code>u</code> so that it now uses the block id of
                <code>v</code>. The <code>unionfind(u, v)</code> check simply compares the stored ids to decide whether
                two plots currently lie in the same zoning block.
            </p>

            <p>
                With this representation, typical planning questions become cheap operations on the zoning engine:
                “Are these two plots in the same residential cluster?” is answered by a single
                <code>unionfind(u, v)</code> call; “Merge these two compatible pockets along a corridor” is just one
                <code>unionn(u, v)</code> that updates all affected cells. When rezoning happens near a junction or
                metro station, only the corresponding cells are relabelled and their unions recomputed, while the
                remainder of the city grid stays untouched, keeping the master plan responsive and easy to maintain.
            </p>

            <h4>Implementation:</h4>
            <br>

           

            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/master.jpg"
                     alt="Development control regulations"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
        
            <div class="algo-div">Data Structure:Union Find</div>
            <br><br>

            <button type="button"
                    class="btn btn-success"
                    onclick="toggleZoningCode()">
                Code
            </button>
            <button type="button" class="btn btn-success" 
            onclick="window.location.href='https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/land_housing_zoning_with_status%20(1).csv';">
        Dataset
    </button>
    
        
            


            <div id="zoning-code-block" style="display:none; margin-top:20px;">

                <h4>C++ Logic used</h4>
                <pre><code>#include &lt;iostream&gt;
using namespace std;

int unionfind(int arr[], int u, int v) {
    if (arr[u] == arr[v])
        return 1;
    else
        return 0;
}

// merge zoning block of u into zoning block of v
void unionn(int arr[], int n, int u, int v) {
    int old_id = arr[u];
    int new_id = arr[v];
    if (old_id == new_id) return;          // no work needed

    for (int i = 0; i < n; i++) {
        if (arr[i] == old_id)
            arr[i] = new_id;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, q;
    cin >> n;                  // number of plots (e.g. up to 5000)
    int *arr = new int[n];

    // initially, each plot is its own zoning block
    for (int i = 0; i < n; i++)
        arr[i] = i;

    cin >> m;                  // number of unions
    while (m--) {
        int u, v;
        cin >> u >> v;         // 0-based plot indices
        if (u >= 0 && u < n && v >= 0 && v < n)
            unionn(arr, n, u, v);
    }

    cin >> q;                  // number of queries
    while (q--) {
        int u, v;
        cin >> u >> v;
        if (u >= 0 && u < n && v >= 0 && v < n) {
            if (unionfind(arr, u, v))
                cout << "Same zoning block\n";
            else
                cout << "Different zoning blocks\n";
        } else {
            cout << "Invalid plot index\n";
        }
    }

    delete[] arr;
    return 0;
}
​

</code></pre>


            </div>
        </div>  <!-- close zoning content-box -->

        
<!-- ii) Housing & DCR -->
<div class="content-box">
    <h3>Housing & Development Controls</h3>
    <div class="rule"></div>

    <p>
        For housing and development rules, all regulation bands—combinations of zone, road width, FAR limit, height
        cap, plot size range and open‑space requirements—are treated as clean data and organised into an ordered
        structure backed by a balanced <b>Red‑Black tree</b> using <code>std::map</code> / <code>std::set</code>.
        When a building or layout is proposed, its parameters (zone, abutting road width, plot area) are converted
        into a composite key and used to look up the matching regulation band in log time, then the proposed FAR,
        height and setbacks are checked against the values stored in that band.
    </p>

    <p>
        To support fast queries and easy evolution of the rules, all these bands sit inside the balanced Red‑Black
        tree rather than in ad‑hoc if‑else blocks. The tree automatically maintains its height as bands are inserted
        or updated, so lookups continue to run in <code>O(log n)</code> time even when hundreds of base rules and
        overlays exist. Once the correct node is found, the value at that node directly exposes the
        permitted FAR, maximum height and setback distances; the checking step only has to compare the proposal’s
        numbers against these limits to decide whether it is compliant.
    </p>

    <p>
        This tree‑based design keeps the rule set flexible, which is essential for a growing city. If a new metro line
        is introduced and a higher‑FAR transit‑oriented development band is needed along a defined corridor, that band
        is simply added as a new key in the Red‑Black tree without touching the evaluation pipeline.
        Likewise, if eco‑sensitive edges need stricter caps, their corresponding keys are tightened in place and all
        future proposals automatically see the updated limits.
    </p>

    <p>
        Every proposal therefore passes through the same predictable sequence: construct the composite key from its
        zone, road width and plot area; perform a log‑time lookup in the tree; and validate the submitted FAR, height
        and setbacks against the retrieved band. Policy changes become a matter of editing data in the tree rather than
        rewriting code paths, which keeps the housing and development control layer both technically clean and easy to
        align with new planning decisions.
    </p>

    <h4>Implementation:</h4>
    <br>

    <div style="text-align:center; margin:20px 0;">
        <img src="Masterplan/hoc.jpg"
             alt="Development control regulations"
             style="width:450px; height:auto; border:2px solid #000;">
    </div>

    <div class="algo-div">Data Structure: Red‑Black Tree</div>
    <br><br>

    <button type="button" 
    class="btn btn-success"
    onclick="toggleDcrCode()">
 Code
</button>

<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/housing_development_bands_part1.csv"
   target="_blank">
  Dataset
</a>




<div id="dcr-code-block" style="display:none; margin-top:20px;">

<h4>C++ Logic used</h4>
<pre><code>#include &lt;iostream&gt;
    #include <bits/stdc++.h>
    using namespace std;
    
    // ---------- Red‑Black tree key & value ----------
    
    struct BandKey {
        string zone;
        int road_width_m;   // here derived from max_height_m just for demo
        int plot_band_id;
    
        bool operator<(const BandKey &o) const {
            if (zone != o.zone) return zone < o.zone;
            if (road_width_m != o.road_width_m) return road_width_m < o.road_width_m;
            return plot_band_id < o.plot_band_id;
        }
    };
    
    struct RegBand {
        double max_far;
        double max_height_m;
    };
    
    // ---------- Proposals ----------
    
    struct Proposal {
        string zone;
        double road_width_m;
        double plot_area_sqm;
        double proposed_far;
        double proposed_height_m;
    };
    
    // ---------- Globals ----------
    
    map<BandKey, RegBand> bandTree;
    
    // ---------- Helpers ----------
    
    int plot_band(double a) {
        if (a < 60.0)   return 1;
        if (a < 120.0)  return 2;
        if (a < 240.0)  return 3;
        if (a < 480.0)  return 4;
        return 5;
    }
    
    int round_road(double w) {
        return static_cast<int>(round(w));
    }
    
    vector<string> split_csv(const string &line) {
        vector<string> out;
        string cur;
        bool in_quotes = false;
        for (char c : line) {
            if (c == '"') {
                in_quotes = !in_quotes;
            } else if (c == ',' && !in_quotes) {
                out.push_back(cur);
                cur.clear();
            } else {
                cur.push_back(c);
            }
        }
        out.push_back(cur);
        return out;
    }
    
    // ---------- Load bands from CSV ----------
    
    void load_bands_from_csv(const string &filename) {
        ifstream fin(filename);
        if (!fin.is_open()) {
            cerr << "Cannot open file: " << filename << "\n";
            exit(1);
        }
    
        string line;
        // header
        if (!getline(fin, line)) {
            cerr << "Empty file\n";
            exit(1);
        }
    
        while (getline(fin, line)) {
            if (line.empty()) continue;
            auto cols = split_csv(line);
            if (cols.size() < 7) continue; // sanity
    
            string zone_code    = cols[1];
            double plot_area    = stod(cols[4]);
            double max_far      = stod(cols[5]);
            double max_height_m = stod(cols[6]);
    
            int pb  = plot_band(plot_area);
            int rw  = round_road(max_height_m);   // placeholder for road width
    
            BandKey key{zone_code, rw, pb};
            RegBand rb{max_far, max_height_m};
    
            // insert / update band
            bandTree[key] = rb;
        }
    
        fin.close();
    }
    
    // ---------- Evaluate a proposal ----------
    
    bool evaluate(const Proposal &p, string &reason) {
        BandKey k{p.zone, round_road(p.road_width_m), plot_band(p.plot_area_sqm)};
        auto it = bandTree.find(k);
        if (it == bandTree.end()) {
            reason = "no matching band";
            return false;
        }
        const RegBand &rb = it->second;
    
        if (p.proposed_far > rb.max_far) {
            reason = "FAR exceeds " + to_string(rb.max_far);
            return false;
        }
        if (p.proposed_height_m > rb.max_height_m) {
            reason = "height exceeds " + to_string(rb.max_height_m);
            return false;
        }
        reason = "OK";
        return true;
    }
    
    // ---------- Main demo ----------
    
    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
    
        // change to your actual CSV name
        string filename = "land_housing_zoning_with_status.csv";
        load_bands_from_csv(filename);
    
        cout << "Loaded " << bandTree.size() << " bands into RB‑tree\n";
    
        // two sample proposals using real‑ish values
        Proposal p1{
            "RZ_RES_LOW", 17.0, 110.0, 1.8, 16.0
        };
        Proposal p2{
            "RZ_RES_LOW", 17.0, 110.0, 3.0, 25.0
        };
    
        for (int i = 0; i < 2; ++i) {
            Proposal p = (i == 0 ? p1 : p2);
            string reason;
            bool ok = evaluate(p, reason);
            cout << "Proposal " << (i + 1) << ": "
                 << (ok ? "APPROVED: " : "REJECTED: ")
                 << reason << "\n";
        }
    
        return 0;
    }
    
</pre></code>

</div>
</div> 

        <!-- iii) Permissions / phasing -->
        <div class="content-box">
            <h3>Permissions, Phasing & Updates</h3>
            <div class="rule"></div>

            <p>
               The flow of applications is treated as a controlled processing pipeline and implemented with a
               <b>double‑ended queue (deque)</b>. Normal building and layout applications enter at the back and are
               processed from the front in a clean FIFO manner, while phase‑critical or policy‑priority projects
               (such as public or affordable housing) can be pushed to the front to be handled earlier.
            </p>

            <p>
               Each application’s full data is stored in an indexed array or vector; the deque manages the order through
               <code>push_back</code>, <code>push_front</code> and <code>pop_front</code> in constant time. This mirrors how permissions,
               phasing and plan updates work in practice—mostly queue‑based, but with the flexibility to fast‑track or
               defer specific cases when the city’s development strategy demands it.
            </p>
            <h4>Implementation:</h4>
            <br>
            
            
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/phasing.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Core Structure: Union–Find </div>
            <br><br>

            
            <button type="button" 
            class="btn btn-success"
            onclick="togglePhasingCode()">
        Code
    </button>
    <a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/applications_processed.csv"
   target="_blank">
  Dataset
</a>

    
    <div id="phasing-code-block" style="display:none; margin-top:20px;">
    
        <h4>C++ Logic used</h4>
        <pre><code>#include &lt;iostream&gt;
            #include <bits/stdc++.h>
            using namespace std;
            
            // One application record loaded from CSV
            struct Application {
                string app_id;
                string zone;
                double plot_area_sqm;
                double road_width_m;
                double proposed_far;
                double proposed_height_m;
                string priority;        // "PRIORITY" or "NORMAL"
                string status;          // APPROVED / DEFERRED / PENDING
                string phase;           // PHASE_1 / PHASE_2 / ...
                int    processed_order; // 1..1000
                string fast_tracked;    // "YES" / "NO"
            };
            
            int main() {
                ios::sync_with_stdio(false);
                cin.tie(nullptr);
            
                // ------------ load CSV into vector<Application> ------------
                // Assumes a file "applications_processed.csv" with 1000 rows
                // and header: app_id,zone,plot_area_sqm,road_width_m,proposed_far,proposed_height_m,priority,status,phase,processed_order,fast_tracked
                ifstream fin("ananya/Datasets/applications_processed.csv");
                if (!fin) {
                    cerr << "Could not open applications_processed.csv\n";
                    return 1;
                }
            
                vector<Application> apps;
                string line;
            
                // skip header
                getline(fin, line);
            
                while (getline(fin, line)) {
                    if (line.empty()) continue;
                    stringstream ss(line);
                    string token;
                    Application a;
            
                    getline(ss, a.app_id, ',');
                    getline(ss, a.zone, ',');
                    getline(ss, token, ','); a.plot_area_sqm = stod(token);
                    getline(ss, token, ','); a.road_width_m = stod(token);
                    getline(ss, token, ','); a.proposed_far = stod(token);
                    getline(ss, token, ','); a.proposed_height_m = stod(token);
                    getline(ss, a.priority, ',');
                    getline(ss, a.status, ',');
                    getline(ss, a.phase, ',');
                    getline(ss, token, ','); a.processed_order = stoi(token);
                    getline(ss, a.fast_tracked, ',');
            
                    apps.push_back(a);
                }
            
                cout << "Loaded " << apps.size() << " applications\n";
            
                // ------------ processing pipeline using deque ------------
                deque<int> dq; // stores indices into apps vector
            
                for (int i = 0; i < (int)apps.size(); ++i) {
                    const Application &a = apps[i];
            
                    bool is_priority = (a.priority == "PRIORITY") || (a.fast_tracked == "YES");
                    if (is_priority) {
                        // phase‑critical or policy‑priority: go to the front
                        dq.push_front(i);          // O(1)
                    } else {
                        // normal application: join the back of the queue
                        dq.push_back(i);           // O(1)
                    }
                }
            
                // Process applications in pipeline order (front of deque)
                while (!dq.empty()) {
                    int idx = dq.front();
                    dq.pop_front();                // O(1)
            
                    Application &a = apps[idx];
            
                    // Example processing logic: here just print a summary line
                    cout << "Processing " << a.app_id
                         << " zone=" << a.zone
                         << " priority=" << a.priority
                         << " fast_tracked=" << a.fast_tracked
                         << " phase=" << a.phase << "\n";
            
                    // In a real system, this is where approval/deferral rules would run,
                    // possibly updating a.status or a.phase.
                }
            
                return 0;
            }
            </code></pre>
    
    </div>
        </div>
    

    <!-- =====================================================
         BLOCK 2: WILDLIFE & MANAGEMENT
    ====================================================== -->
    <h2 class="section-heading">Wildlife & Management</h2>

    <div class="content-box-container">

        <!-- i) PATROL & SECURITY -->
        <div class="content-box">
            <h3>Patrol & Security – Dijkstra (Single Source)</h3>
            <div class="rule"></div>

            <p>
                The wildlife zone is treated as a live, data‑driven patrol network where every watchtower, gate, water reservoir and conflict‑prone location is connected by trails and forest roads. 
                Rangers at any post can always ask the system for the fastest safe route to a new incident point, whether it is a poaching alert near a boundary or a distress call near a water body.
              </p>
              
              <p>
                In the implementation, each of these locations becomes a node in a weighted graph, and every road or path between them is an edge with a cost representing travel time, terrain difficulty or risk level. 
                The graph is stored using adjacency lists so that from any location it is efficient to scan all outgoing paths and update their tentative travel cost during routing.
                
              </p>
              
              <p>
                From a selected starting tower or base camp, Dijkstra’s single‑source shortest path algorithm is run once to compute the minimum‑time route to every other node in the reserve. 
                Internally, the system maintains a distance array, a visited set, and a min‑priority queue that repeatedly picks the unvisited node with the smallest known travel time and relaxes its outgoing edges to see if they provide a faster route to neighbouring patrol points.
              </p>
              
              <p>
                In practice, this behaves like a GPS tailored to conservation work: once the rangers’ current position is fixed, the system can instantly answer “what is the best route to this incident?” by looking up the pre‑computed distance and reconstructing the path. 
                If monsoon conditions or temporary closures make certain tracks slower or unsafe, the corresponding edge weights are increased, and the next run of Dijkstra automatically diverts patrols along alternate trails that are slightly longer in distance but better in effective response time and safety.
              
              <p>
                This allows the patrolling module to be framed as hands‑on work: the wildlife wing was modelled as a weighted graph over the reserve’s patrol grid, with Dijkstra’s algorithm driving both routine patrol planning and time‑critical responses. 
                Routes and priorities are no longer based purely on intuition; they adapt continuously to terrain, season and historical patrol data, making coverage and incident response more objective, transparent and data‑driven for the forest department.
              </p>
              

            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/patroling.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Algorithm:Dijakstra  </div>
            <br><br>


            <button type="button" 
        class="btn btn-success"
        onclick="togglePatrolCode()">
    Code
</button>
<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/wildlife_patrol_distances.csv"
   target="_blank">
  Dataset
</a>


<div id="patrol-code-block" style="display:none; margin-top:20px;">

    <h4>C++ Logic used (Patrol Routing with Dijkstra)</h4>
    <pre><code>#include &lt;iostream&gt;
        #include <bits/stdc++.h>
        using namespace std;
        
        struct NodeInfo {
            int    id;
            string type;
            double dist; // minutes from source (precomputed by Python)
        };
        
        int main() {
            ios::sync_with_stdio(false);
            cin.tie(nullptr);
        
            string filename = "wildlife_patrol_distances.csv";
            ifstream fin(filename);
            if (!fin) {
                cerr << "Could not open " << filename << "\n";
                return 1;
            }
        
            vector<NodeInfo> nodes;
            string line;
        
            // skip header
            if (!getline(fin, line)) {
                cerr << "Empty CSV\n";
                return 1;
            }
        
            while (getline(fin, line)) {
                if (line.empty()) continue;
                stringstream ss(line);
                string token;
        
                NodeInfo ni;
        
                // node_id
                getline(ss, token, ',');
                ni.id = stoi(token);
        
                // node_type
                getline(ss, ni.type, ',');
        
                // distance_from_source_minutes
                getline(ss, token, ',');
                ni.dist = stod(token);
        
                nodes.push_back(ni);
            }
        
            cout << "Loaded " << nodes.size()
                 << " patrol points with precomputed travel times.\n\n";
        
            cout << "Node   Type            MinTime(from source, min)\n";
            for (const auto &ni : nodes) {
                cout << setw(4) << ni.id << "   "
                     << setw(12) << ni.type << "   "
                     << fixed << setprecision(2) << ni.dist << "\n";
            }
        
            // Example: sort by travel time to suggest response order
            sort(nodes.begin(), nodes.end(),
                 [](const NodeInfo &a, const NodeInfo &b) {
                     return a.dist < b.dist;
                 });
        
            cout << "\nSuggested incident response order (closest first):\n";
            for (int i = 0; i < min<int>(10, nodes.size()); ++i) {
                const auto &ni = nodes[i];
                cout << i + 1 << ") node " << ni.id
                     << " (" << ni.type << "), "
                     << ni.dist << " minutes from source\n";
            }
        
            return 0;
        }
        
}</code></pre>

    </code></pre>

</div>
</div>


        <!-- ii) ANIMAL HEALTH -->
        <div class="content-box">
            <h3>Animal Health</h3>
            <div class="rule"></div>

            <p>
                Wildlife health management is organised into three parts: emergency triage, central storage of animal
                details and stock monitoring for water and medical supplies. Each component is mapped to a specific
                data structure that reflects how a real sanctuary needs to react and plan every day.[web:113]
            </p>

            <!-- a) Emergency – Max Heap -->
            <h4>a) Emergency – Max‑Heap</h4>
            <p>
                During emergencies, vets must immediately know which case is most critical. Every animal is given a
                dynamic risk score based on injuries, illness, behaviour changes and recent reports. These entries are
                kept in a <b>max‑heap</b>, ordered by risk score, so the animal at the top is always the one that needs
                attention first; updating a score and pushing it back into the heap keeps the priority list constantly
                refreshed.
            </p>
            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/heapp.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Algorithm:Max Heap  </div>
            <br><br>
            <button type="button" 
            class="btn btn-success"
            onclick="toggleHeapCode()">
        Code
    </button>
    <a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/animal_cases_heap_output.csv"
   target="_blank">
  Dataset
</a>

    
    <div id="heap-code-block" style="display:none; margin-top:20px;">
    
      <h4>C++ Logic used (Bottom‑up Max Heap for Priorities)</h4>
      <pre><code>#include &lt;iostream&gt;
        #include <bits/stdc++.h>
using namespace std;

struct CaseInfo {
    int heap_index;
    string case_id;
    string species;
    string condition;
    string triage_level;
    double age_years;
    double temperature_c;
    int resp_rate_min;
    int heart_rate_bpm;
    int trauma_severity_0_3;
    string infectious_suspect;
    string pregnant;
    double priority_score;
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string filename = "animal_cases_heap_output.csv";
    ifstream fin(filename);
    if (!fin) {
        cerr << "Could not open " << filename << "\n";
        return 1;
    }

    vector<CaseInfo> cases;
    string line;

    // skip header
    if (!getline(fin, line)) {
        cerr << "Empty CSV\n";
        return 1;
    }

    while (getline(fin, line)) {
        if (line.empty()) continue;
        stringstream ss(line);
        string token;
        CaseInfo c;

        // heap_index
        getline(ss, token, ',');
        c.heap_index = stoi(token);

        // case_id
        getline(ss, c.case_id, ',');

        // species
        getline(ss, c.species, ',');

        // condition
        getline(ss, c.condition, ',');

        // triage_level
        getline(ss, c.triage_level, ',');

        // age_years
        getline(ss, token, ',');
        c.age_years = stod(token);

        // temperature_c
        getline(ss, token, ',');
        c.temperature_c = stod(token);

        // resp_rate_min
        getline(ss, token, ',');
        c.resp_rate_min = stoi(token);

        // heart_rate_bpm
        getline(ss, token, ',');
        c.heart_rate_bpm = stoi(token);

        // trauma_severity_0_3
        getline(ss, token, ',');
        c.trauma_severity_0_3 = stoi(token);

        // infectious_suspect
        getline(ss, c.infectious_suspect, ',');

        // pregnant
        getline(ss, c.pregnant, ',');

        // priority_score
        getline(ss, token, ',');
        c.priority_score = stod(token);

        cases.push_back(c);
    }

    cout << "Loaded " << cases.size()
         << " animal triage cases from heap dataset.\n\n";

    cout << left
         << setw(4)  << "Idx"
         << setw(8)  << "HeapPos"
         << setw(10) << "CaseID"
         << setw(10) << "Species"
         << setw(14) << "Triage"
         << setw(6)  << "Age"
         << setw(6)  << "Temp"
         << setw(6)  << "RR"
         << setw(6)  << "HR"
         << setw(4)  << "Tra"
         << setw(5)  << "Inf?"
         << setw(5)  << "Preg?"
         << setw(9)  << "Priority"
         << "\n";

    int show = min<int>(15, cases.size());
    for (int i = 0; i < show; ++i) {
        const CaseInfo &c = cases[i];
        cout << setw(4)  << (i + 1)
             << setw(8)  << c.heap_index
             << setw(10) << c.case_id
             << setw(10) << c.species
             << setw(14) << c.triage_level
             << setw(6)  << fixed << setprecision(1) << c.age_years
             << setw(6)  << setprecision(1) << c.temperature_c
             << setw(6)  << c.resp_rate_min
             << setw(6)  << c.heart_rate_bpm
             << setw(4)  << c.trauma_severity_0_3
             << setw(5)  << c.infectious_suspect
             << setw(5)  << c.pregnant
             << setw(9)  << setprecision(2) << c.priority_score
             << "\n";
    }

    // verify heap property for priority_score
    bool heap_ok = true;
    int n = (int)cases.size();

    auto getPriority = [&](int heapPos) -> double {
        return cases[heapPos - 1].priority_score; // heap_index == position
    };

    for (int i = 1; i <= n / 2; ++i) {
        int left  = 2 * i;
        int right = 2 * i + 1;
        double parentP = getPriority(i);
        if (left <= n && parentP < getPriority(left))  heap_ok = false;
        if (right <= n && parentP < getPriority(right)) heap_ok = false;
    }

    cout << "\nHeap property on priority_score: "
         << (heap_ok ? "OK" : "VIOLATED") << "\n";

    return 0;
}

    </code></pre>
    
      
    
    </div>


  
            <!-- b) Storing animal details – Hashmap -->
            <h4>b) Storing Animal Details – Hashmap</h4>
            <p>
                Each animal in the sanctuary receives a unique ID linked to species, age, location, health notes and
                current risk score. These records are stored in a <b>hashmap</b> keyed by animal ID, which provides
                constant‑time access during patrols and routine checks, so any profile can be pulled or updated without
                scanning long lists.
            </p>

            <p>
                Alongside the live record, a vector of historical health snapshots is maintained per animal. At the end
                of each check cycle, a new entry is appended with date, risk score and remarks, enabling trend analysis
                over weeks or months without slowing real‑time operations.
            </p>

            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/heapify.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Data Structure:Hash Maps  </div>
            <br><br>
            <button type="button" 
        class="btn btn-success"
        onclick="toggleAnimalHashCode()">
    Code
</button>
<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/animal_hashmap_output__score_.csv"
   target="_blank">
  Dataset
</a>


<div id="animal-hash-code-block" style="display:none; margin-top:20px;">

  <h4>C++ Logic used (Array‑based Hash Lookup for Animal Records)</h4>
  <pre><code>
    #include <bits/stdc++.h>
    using namespace std;
    
    const int MAX_ANIMALS = 1000;
    
    // Array-based "hash map" (direct index = Animal_ID)
    string  speciesArr[MAX_ANIMALS];
    int     riskScoreArr[MAX_ANIMALS];
    string  zoneArr[MAX_ANIMALS];
    int     ageArr[MAX_ANIMALS];
    string  lastCheckArr[MAX_ANIMALS];
    int     healthScoreArr[MAX_ANIMALS];   // single score only
    
    // Generate a random recent date (last 30 days) in DD-MM-YYYY format
    string randomRecentDate(mt19937 &gen) {
        uniform_int_distribution<int> dayBack(1, 30);
        int back = dayBack(gen);
    
        using namespace chrono;
        auto today  = chrono::system_clock::now();
        auto target = today - chrono::hours(24 * back);
        time_t tt   = chrono::system_clock::to_time_t(target);
        tm *lt      = localtime(&tt);
    
        char buf[11];
        strftime(buf, sizeof(buf), "%d-%m-%Y", lt);   // DD-MM-YYYY
        return string(buf);
    }
    
    int main() {
        // Random engine and distributions
        random_device rd;
        mt19937 gen(rd());
    
        uniform_int_distribution<int> riskDist(1, 10);     // 1..10
        uniform_int_distribution<int> ageDist(1, 25);      // 1..25
        uniform_int_distribution<int> healthDist(50, 100); // 50..100
    
        // Full species list (same as Python)
        vector<string> speciesList = {
            "Tiger", "Elephant", "Bear", "Leopard", "Wolf",
            "TIGER", "LEOPARD", "ELEPHANT", "RHINO",
            "GAUR", "SLOTH_BEAR", "WILD_DOG", "HYENA",
            "SAMBAR_DEER", "CHITAL", "BARASINGHA", "NILGAI",
            "WILD_BOAR", "BLACKBUCK", "LANGUR", "MACAQUE",
            "CROCODILE", "OTTER", "PEAFOWL", "HORNBILL"
        };
    
        vector<string> zones = {"Zone-1", "Zone-2", "Zone-3", "Zone-4", "Zone-5"};
    
        // ---- Generate data for 1000 animals ----
        for (int id = 0; id < MAX_ANIMALS; ++id) {
            // Species and zone pattern must match Python behaviour:
            // Python currently uses species_list[animal_id % 5] and zones[animal_id % 5],
            // so we do the same here.
            speciesArr[id]   = speciesList[id % 5];
            zoneArr[id]      = zones[id % 5];
    
            riskScoreArr[id] = riskDist(gen);
            ageArr[id]       = ageDist(gen);
            lastCheckArr[id] = randomRecentDate(gen);
            healthScoreArr[id] = healthDist(gen);   // exactly ONE health score
        }
    
        // ---- Sample query for Animal ID 0 (similar to Python print) ----
        int queryId = 0;
        cout << "Sample ID " << queryId << ": "
             << speciesArr[queryId]
             << " | Risk: " << riskScoreArr[queryId]
             << " | Zone: " << zoneArr[queryId]
             << " | Health: " << healthScoreArr[queryId]
             << "\n";
    
        // ---- CSV export (same structure and filename as Python) ----
        string filename = "realistic_animal_hashmap_output_single_score_.csv";
        ofstream fout(filename);
        if (!fout) {
            cerr << "Error opening output CSV file\n";
            return 1;
        }
    
        // Header
        fout << "Animal_ID,"
             << "Species,"
             << "Risk_Score,"
             << "Zone,"
             << "Age_Years,"
             << "Last_Check,"
             << "Health_Score\n";
    
        // Rows
        for (int id = 0; id < MAX_ANIMALS; ++id) {
            fout << id << ","
                 << speciesArr[id] << ","
                 << riskScoreArr[id] << ","
                 << zoneArr[id] << ","
                 << ageArr[id] << ","
                 << lastCheckArr[id] << ","
                 << healthScoreArr[id] << "\n";
        }
    
        fout.close();
        cout << "Generated " << filename
             << " with ONE health score per animal\n";
    
        return 0;
    }
    
  </code></pre>

</div>

<!-- c) Stock – Fenwick Tree -->
          <h4>c) Stock (Water & Medical Supplies) – Fenwick Tree</h4>
            <p>
                Water in reservoirs and medical supplies across clinics are monitored as continuous resources that
                fluctuate throughout the day. Storage points are indexed, and a <b>Fenwick Tree (Binary Indexed
                Tree)</b> is built over this index to support fast prefix and range‑sum queries such as “total water in
                this cluster of reservoirs” or “total vaccine doses available along one corridor”.
            </p>

            <p>
                Individual refills and consumptions update single positions in the Fenwick Tree, while range summaries
                can still be answered in logarithmic time. This structure makes continuous stock monitoring efficient
                and keeps the system ready for sudden demand during emergencies.
            </p>

            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/BIT.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Data Structure:Fenwick Tree  </div>
            <br><br>
            <button type="button" 
        class="btn btn-success"
        onclick="toggleBITCode()">
    Code
</button>
<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/animal_hashmap_output__score_.csv"
   target="_blank">
  Dataset
</a>

<div id="bit-code-block" style="display:none; margin-top:20px;">

  <h4>C++ Logic used (Fenwick / BIT for Resource Monitoring)</h4>
  <pre><code>#include &lt;iostream&gt;
using namespace std;

const int MAXN = 100;  
int BIT[MAXN + 1];      
int n;


void update(int x, int delta) {
    for (int i = x; i &lt;= n; i = i + (i &amp; -i)) {
        BIT[i] += delta;
    }
}


int prefixSum(int x) {
    int s = 0;
    for (int i = x; i &gt; 0; i = i - (i &amp; -i)) {
        s += BIT[i];
    }
    return s;
}


int rangeSum(int l, int r) {
    return prefixSum(r) - prefixSum(l - 1);
}

int main() {
    cout &lt;&lt; "Enter number of storage points (n):\n";
    cin &gt;&gt; n;

    int a[MAXN + 1];
    cout &lt;&lt; "Enter initial units at each point (1..n):\n";
    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; a[i];
        update(i, a[i]);          
    }

    
    int idx, delta;
    cout &lt;&lt; "Enter index and change in stock (delta):\n";
    cin &gt;&gt; idx &gt;&gt; delta;
    update(idx, delta);

    int L, R;
    cout &lt;&lt; "Enter range [L R] to query total stock:\n";
    cin &gt;&gt; L &gt;&gt; R;

    cout &lt;&lt; "Total stock from " &lt;&lt; L &lt;&lt; " to " &lt;&lt; R
         &lt;&lt; " = " &lt;&lt; rangeSum(L, R) &lt;&lt; "\n";

    return 0;
}</code></pre>

  <h4>Sample Input</h4>
  <pre><code>5
10 5 0 12 3
3 4
2 5</code></pre>

  <h4>Explanation</h4>
  <pre><code>n = 5
Initial stock: [10, 5, 0, 12, 3]
Update: index 3 += 4  -> [10, 5, 4, 12, 3]
Query: total from 2..5 -> 5 + 4 + 12 + 3 = 24</code></pre>

  <h4>Expected Output</h4>
  <pre><code>Total stock from 2 to 5 = 24</code></pre>

</div>
</div>
        <!-- iii) R&D – Boyer–Moore -->
        <div class="content-box">
            <h3>Research & Development – Boyer–Moore</h3>
            <div class="rule"></div>

            <p>
                The wildlife zone also functions as a research space where genetic data and long‑term behaviour logs
                are stored as sequences. Important signals such as risky gene markers or recurring stress patterns need
                to be located quickly inside these long strings, so the <b>Boyer–Moore</b> string‑matching algorithm is
                used instead of naive scanning.
            </p>

            <p>
                Each gene sample or weekly behaviour trace is saved as a long text over some alphabet, such as nucleotides for genetics or stress‑event codes for behaviour. When a biologist wants to check if a risky marker (a short pattern) appears anywhere inside that text, Boyer–Moore pre‑processes just the pattern once and then scans the big string from right to left, skipping whole chunks whenever a mismatch proves that alignment impossible
            </p>
            <p>
                Instead of checking every character position like the naive algorithm, Boyer–Moore uses “bad‑character” and “good‑suffix” rules to jump ahead several indices at a time, which makes it much faster on long logs and genome‑scale data. In practice this means a researcher can run near real‑time queries such as “find all occurrences of this gene motif” or “locate every repeated stress code subsequence” across months of stored data without blocking the system.
            </p>

            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/boyree.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Algorithm:Boyer Moore  </div>
            <br><br>
            <button type="button" 
        class="btn btn-success"
        onclick="toggleBMCode()">
       
    Code
</button>
</button>
<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/wildlife_boyer_moore_1000_matches.csv"
   target="_blank">
  Dataset
</a>



<div id="bm-code-block" style="display:none; margin-top:20px;">

  <h4>C++ Logic used (Boyer–Moore for Gene / Behaviour Logs)</h4>
  <pre><code>#include &lt;iostream&gt;
    #include <bits/stdc++.h>
    using namespace std;
    
    const int ALPH = 256;
    
    void buildLast(const string &pat, int last[]) {
        for (int i = 0; i < ALPH; ++i) last[i] = -1;
        for (int i = 0; i < (int)pat.size(); ++i)
            last[(unsigned char)pat[i]] = i;
    }
    
    vector<int> boyerMoore(const string &text, const string &pat) {
        int n = (int)text.size(), m = (int)pat.size();
        vector<int> matches;
        if (m == 0 || n == 0 || m > n) return matches;
        int last[ALPH];
        buildLast(pat, last);
        int s = 0;
        while (s <= n - m) {
            int j = m - 1;
            while (j >= 0 && pat[j] == text[s + j]) --j;
            if (j < 0) {
                matches.push_back(s);
                if (s + m < n) s += m - last[(unsigned char)text[s + m]];
                else ++s;
            } else {
                unsigned char bad = text[s + j];
                int shift = j - last[bad];
                if (shift < 1) shift = 1;
                s += shift;
            }
        }
        return matches;
    }
    
    string randomGene(int len, mt19937 &g) {
        static const string alph = "ACGT";
        uniform_int_distribution<int> d(0, (int)alph.size() - 1);
        string s(len, 'A');
        for (int i = 0; i < len; ++i) s[i] = alph[d(g)];
        return s;
    }
    
    string randomStress(int len, mt19937 &g) {
        static const string alph = "HL";
        uniform_int_distribution<int> d(0, (int)alph.size() - 1);
        string s(len, 'H');
        for (int i = 0; i < len; ++i) s[i] = alph[d(g)];
        return s;
    }
    
    int main() {
        mt19937 gen(random_device{}());
        string riskyPattern  = "ACGTACG";
        string stressPattern = "HHLH";
    
        struct Sample { string id, type, text, pattern; };
        vector<Sample> data;
        data.reserve(1000);
    
        for (int i = 0; i < 1000; ++i) {
            Sample s;
            s.id = "S" + to_string(i + 1);
            if (i % 2 == 0) {
                s.type = "GENE";
                s.text = randomGene(80, gen);
                s.pattern = riskyPattern;
            } else {
                s.type = "STRESS";
                s.text = randomStress(80, gen);
                s.pattern = stressPattern;
            }
            data.push_back(move(s));
        }
    
        ofstream fout("wildlife_boyer_moore_1000_matches_cpp.csv");
        if (!fout) {
            cerr << "Error opening CSV\n";
            return 1;
        }
        fout << "Sample_ID,Log_Type,Pattern,Start_Index\n";
    
        for (const auto &s : data) {
            vector<int> pos = boyerMoore(s.text, s.pattern);
            for (int p : pos) {
                fout << s.id << "," << s.type << ","
                     << s.pattern << "," << p << "\n";
            }
        }
        fout.close();
        cout << "Generated wildlife_boyer_moore_1000_matches_cpp.csv\n";
        return 0;
    }
    </code></pre>

</div>

</div>
        <!-- iv) CARBON CREDITS – Segment Tree -->
        <div class="content-box">
            <h3>Carbon Credits – Segment Tree</h3>
            <div class="rule"></div>

            <p>
                Each forest band, plantation strip or wetland patch is mapped to an index in a base array, where a[i] stores the estimated annual carbon sequestration (in tonnes of CO₂) for segment i. This linearisation lets the carbon layer plug directly into a segment tree, since the structure is designed to answer repeated range‑sum questions over such arrays while still allowing point updates.
            </p>
            <p>
                bove this array, a segment tree is built as a binary tree in an internal array tree[], where each node covers a contiguous range of segments and stores the sum of their carbon values. Leaves correspond to single segments, and each internal node stores tree[node] = leftSum + rightSum, so building the tree once from the base array costs 
O
(
n
)
O(n) time and prepares it for queries and updates.
            </p>

            <p>
                To keep this data ready for continuous analysis, the segments are placed in a linear structure and a
                <b>Segment Tree</b> is built over them. This allows range‑sum queries like “total carbon captured along
                this corridor” and point updates when restoration, degradation or new planting occurs, so carbon‑credit
                values can be recalculated quickly for many funding and reporting scenarios.
            </p>

            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/seg.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Algorithm:Segment Tree </div>
            <br><br>
            <button type="button" 
        class="btn btn-success"
        onclick="toggleSegTreeCode()">
    Code
</button>

<div id="seg-code-block" style="display:none; margin-top:20px;">

  <h4>C++ Logic used (Segment Tree for Carbon Bands)</h4>
  <pre><code>#include &lt;iostream&gt;
using namespace std;

const int MAXN = 100;

int n;
long long a[MAXN];
long long tree[4 * MAXN];

void build(int node, int l, int r) {
    if (l == r) {
        tree[node] = a[l];
        return;
    }
    int mid = (l + r) / 2;
    build(2 * node, l, mid);
    build(2 * node + 1, mid + 1, r);
    tree[node] = tree[2 * node] + tree[2 * node + 1];
}

void update(int node, int l, int r, int idx, long long val) {
    if (l == r) {
        tree[node] = val;
        a[idx] = val;
        return;
    }
    int mid = (l + r) / 2;
    if (idx <= mid) update(2 * node, l, mid, idx, val);
    else update(2 * node + 1, mid + 1, r, idx, val);
    tree[node] = tree[2 * node] + tree[2 * node + 1];
}

long long query(int node, int l, int r, int ql, int qr) {
    if (qr &lt; l || r &lt; ql) return 0;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[node];
    int mid = (l + r) / 2;
    return query(2 * node, l, mid, ql, qr)
         + query(2 * node + 1, mid + 1, r, ql, qr);
}

int main() {
    cout &lt;&lt; "Enter number of forest bands:\n";
    cin &gt;&gt; n;

    cout &lt;&lt; "Enter carbon value for each band (1..n):\n";
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];

    build(1, 1, n);

    int idx;
    long long val;
    cout &lt;&lt; "Enter band index and new carbon value:\n";
    cin &gt;&gt; idx &gt;&gt; val;
    update(1, 1, n, idx, val);

    int L, R;
    cout &lt;&lt; "Enter corridor range [L R] to query total carbon:\n";
    cin &gt;&gt; L &gt;&gt; R;

    long long ans = query(1, 1, n, L, R);
    cout &lt;&lt; "Total carbon from band " &lt;&lt; L &lt;&lt; " to " &lt;&lt; R
         &lt;&lt; " = " &lt;&lt; ans &lt;&lt; "\n";

    return 0;
}</code></pre>

  <h4>Sample Input</h4>
  <pre><code>5
10 8 4 6 12
3 9
2 5</code></pre>

  <h4>Expected Output</h4>
  <pre><code>Total carbon from band 2 to 5 = 35</code></pre>
        </div>

    </div>

    <!-- =====================================================
         BLOCK 3: TEAK & SANDALWOOD INDUSTRY
    ====================================================== -->
    <h2 class="section-heading">Sandalwood Industry</h2>

    <div class="content-box-container">

        <!-- Overall industry idea -->
        <div class="content-box">
            <h3>Green Industrial Timber Belt</h3>
            <div class="rule"></div>

            <p>
                The sandalwood industry wing treats every plantation block as a long-term asset with its own age, host-tree mix and expected harvest year. 
                Instead of keeping these blocks in flat lists or spreadsheets, the planning system organises them in a <b>Binary Search Tree (BST)</b>, keyed by harvest year, so that upcoming harvest windows can be queried and adjusted quickly for different policy and investment scenarios.
              </p>
              
              <p>
                Each node of the BST represents one sandalwood block: it stores the block identifier or compartment number as the key, along with its harvest year and a projected yield score. 
                The tree property—values smaller than a node’s key on the left, larger on the right—lets the planner insert new blocks, delete retired ones and traverse the tree in sorted order to generate a year-wise or range-wise harvest schedule without scanning the full registry every time.
              </p>
              
              <p>
                In practice this means that when the forest department wants to answer questions such as “which blocks are due between 2032 and 2035?” or “what does the 2030 harvest basket look like if we drop one risky block?”, the system simply walks the BST in-order or deletes/updates specific nodes. 
                The core operations—insert, delete and inorder traversal—run in time proportional to the height of the tree, so with reasonably balanced data the planning tool stays responsive even as more sandalwood estates and farmer groups are onboarded.
              </p>

            <h4>Implementation – Plantation Logic:</h4>
            <div class="algo-div">Structures: Structured Records + Priority Queue for Blocks</div>
            <br>

            <div class="image-box">
                <img src="Industry/teak-queue.png" class="image" alt="Teak & sandal priority queue">
                <div class="efficiency-box">
                    <h3>Greedy, transparent harvest planning</h3>
                </div>
            </div>

            <button type="button" class="btn btn-success">Code</button>

            <br><br>

            <h4>Transport & Routing – Dijkstra</h4>
            <p>
                Movement of timber from plantations to sawmills and then to logistics hubs is handled as a transport
                network problem. Plantation blocks, mills and depots form the nodes of a weighted graph, with roads and
                internal tracks as edges carrying travel time or cost.[web:167][web:179] To minimise hauling effort and
                improve turnaround, <b>Dijkstra’s algorithm</b> is used to compute shortest paths from each mill or hub
                to all relevant blocks.
            </p>

            <p>
                This routing layer links directly with the priority queue: once the best blocks are chosen for a given
                season, their logs move along the cheapest or fastest routes suggested by the graph. The result is an
                industry sector that appears as forest on the map, but behaves like an optimised supply chain in the
                backend.
            </p>

            <h4>Implementation – Transport Logic:</h4>
            <div class="algo-div">Algorithm: Dijkstra on Industry Transport Graph</div>
            <br>

            <div class="image-box">
                <img src="Industry/transport-dijkstra.png" class="image" alt="Industry transport graph">
                <div class="efficiency-box">
                    <h3>Shortest‑path hauling from block to mill</h3>
                </div>
            </div>

            <button type="button" class="btn btn-success">Code</button>
        </div>

    </div>

   <a href="../index.html" class="back-btn">Back</a>

</div>

<!-- <script>
    

</script> -->

<script src="an.js"></script>

</body>
</html>