<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ananya – Contributions</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="an.css">
</head>

<body>
<div class="page-wrapper">

    <h1 class="page-title">Ananya Kulkarni</h1>
    <p class="subtitle">Detailed Contribution Breakdown</p>

    <!-- =====================================================
         BLOCK 1: LAND & HOUSING
    ====================================================== -->
    <h2 class="section-heading">Land & Housing</h2>

    <div class="content-box-container">

        <!-- i) Master plan & zoning -->
        <div class="content-box">
            <h3>Master Plan & Zoning – Union–Find Engine</h3>
            <div class="rule"></div>

            <p>
                The master plan for Samarthaka divides land into zoning categories such as Residential, Commercial,
                Industrial, Public/Semi‑public, Transport Corridors and Green/Open Space. Each category carries its own
                bundle of regulations like FAR ranges, density bands, and buffer requirements between conflicting uses,
                turning the master plan into a clear rulebook rather than just colours on a map.
            </p>

            <p>
                To make this computable, the city is discretised into a regular 2D grid where each cell represents a
                small land parcel and stores exactly one zoning label (R, C, I, P, T or G). This simple grid lets the
                system quickly identify neighbours in four directions and attach zoning rules directly to individual
                cells, but by itself it still treats parcels as isolated points.
            </p>

            <p>
                The structure that actually groups parcels into meaningful zoning pockets is the
                <b>Union–Find (Disjoint Set / Quick‑Find)</b> layer built on top of the grid. Each cell starts in its
                own set; whenever two adjacent cells share the same zone type, the <code>unionn(u, v)</code> operation
                relabels every parcel that was in the same block as <code>u</code> so that it now uses the block id of
                <code>v</code>. The <code>unionfind(u, v)</code> check simply compares the stored ids to decide whether
                two plots currently lie in the same zoning block.
            </p>

            <p>
                With this representation, typical planning questions become cheap operations on the zoning engine:
                “Are these two plots in the same residential cluster?” is answered by a single
                <code>unionfind(u, v)</code> call; “Merge these two compatible pockets along a corridor” is just one
                <code>unionn(u, v)</code> that updates all affected cells. When rezoning happens near a junction or
                metro station, only the corresponding cells are relabelled and their unions recomputed, while the
                remainder of the city grid stays untouched, keeping the master plan responsive and easy to maintain.
            </p>

            <h4>Implementation:</h4>
            <br>

           

            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/master.jpg"
                     alt="Development control regulations"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
        
            <div class="algo-div">Data Structure:Union Find</div>
            <br><br>

            <button type="button"
                    class="btn btn-success"
                    onclick="toggleZoningCode()">
                Code
            </button>
            <button type="button" class="btn btn-success" 
            onclick="window.location.href='https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/land_housing_zoning_with_status%20(1).csv';">
        Dataset
    </button>
    
        
            


            <div id="zoning-code-block" style="display:none; margin-top:20px;">

                <h4>C++ Logic used</h4>
                <pre><code>#include &lt;iostream&gt;
using namespace std;

int unionfind(int arr[], int u, int v) {
    if (arr[u] == arr[v])
        return 1;
    else
        return 0;
}

// merge zoning block of u into zoning block of v
void unionn(int arr[], int n, int u, int v) {
    int old_id = arr[u];
    int new_id = arr[v];
    if (old_id == new_id) return;          // no work needed

    for (int i = 0; i < n; i++) {
        if (arr[i] == old_id)
            arr[i] = new_id;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, q;
    cin >> n;                  // number of plots (e.g. up to 5000)
    int *arr = new int[n];

    // initially, each plot is its own zoning block
    for (int i = 0; i < n; i++)
        arr[i] = i;

    cin >> m;                  // number of unions
    while (m--) {
        int u, v;
        cin >> u >> v;         // 0-based plot indices
        if (u >= 0 && u < n && v >= 0 && v < n)
            unionn(arr, n, u, v);
    }

    cin >> q;                  // number of queries
    while (q--) {
        int u, v;
        cin >> u >> v;
        if (u >= 0 && u < n && v >= 0 && v < n) {
            if (unionfind(arr, u, v))
                cout << "Same zoning block\n";
            else
                cout << "Different zoning blocks\n";
        } else {
            cout << "Invalid plot index\n";
        }
    }

    delete[] arr;
    return 0;
}
​

</code></pre>


            </div>
        </div>  <!-- close zoning content-box -->

        
<!-- ii) Housing & DCR -->
<div class="content-box">
    <h3>Housing & Development Controls</h3>
    <div class="rule"></div>

    <p>
        For housing and development rules, all regulation bands—combinations of zone, road width, FAR limit, height
        cap, plot size range and open‑space requirements—are treated as clean data and organised into an ordered
        structure backed by a balanced <b>Red‑Black tree</b> using <code>std::map</code> / <code>std::set</code>.
        When a building or layout is proposed, its parameters (zone, abutting road width, plot area) are converted
        into a composite key and used to look up the matching regulation band in log time, then the proposed FAR,
        height and setbacks are checked against the values stored in that band.
    </p>

    <p>
        To support fast queries and easy evolution of the rules, all these bands sit inside the balanced Red‑Black
        tree rather than in ad‑hoc if‑else blocks. The tree automatically maintains its height as bands are inserted
        or updated, so lookups continue to run in <code>O(log n)</code> time even when hundreds of base rules and
        overlays exist. Once the correct node is found, the value at that node directly exposes the
        permitted FAR, maximum height and setback distances; the checking step only has to compare the proposal’s
        numbers against these limits to decide whether it is compliant.
    </p>

    <p>
        This tree‑based design keeps the rule set flexible, which is essential for a growing city. If a new metro line
        is introduced and a higher‑FAR transit‑oriented development band is needed along a defined corridor, that band
        is simply added as a new key in the Red‑Black tree without touching the evaluation pipeline.
        Likewise, if eco‑sensitive edges need stricter caps, their corresponding keys are tightened in place and all
        future proposals automatically see the updated limits.
    </p>

    <p>
        Every proposal therefore passes through the same predictable sequence: construct the composite key from its
        zone, road width and plot area; perform a log‑time lookup in the tree; and validate the submitted FAR, height
        and setbacks against the retrieved band. Policy changes become a matter of editing data in the tree rather than
        rewriting code paths, which keeps the housing and development control layer both technically clean and easy to
        align with new planning decisions.
    </p>

    <h4>Implementation:</h4>
    <br>

    <div style="text-align:center; margin:20px 0;">
        <img src="Masterplan/hoc.jpg"
             alt="Development control regulations"
             style="width:450px; height:auto; border:2px solid #000;">
    </div>

    <div class="algo-div">Data Structure: Red‑Black Tree</div>
    <br><br>

    <button type="button" 
    class="btn btn-success"
    onclick="toggleDcrCode()">
 Code
</button>

<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/housing_development_bands_part1.csv"
   target="_blank">
  Dataset
</a>




<div id="dcr-code-block" style="display:none; margin-top:20px;">

<h4>C++ Logic used</h4>
<pre><code>#include &lt;iostream&gt;
    #include <bits/stdc++.h>
    using namespace std;
    
    // ---------- Red‑Black tree key & value ----------
    
    struct BandKey {
        string zone;
        int road_width_m;   // here derived from max_height_m just for demo
        int plot_band_id;
    
        bool operator<(const BandKey &o) const {
            if (zone != o.zone) return zone < o.zone;
            if (road_width_m != o.road_width_m) return road_width_m < o.road_width_m;
            return plot_band_id < o.plot_band_id;
        }
    };
    
    struct RegBand {
        double max_far;
        double max_height_m;
    };
    
    // ---------- Proposals ----------
    
    struct Proposal {
        string zone;
        double road_width_m;
        double plot_area_sqm;
        double proposed_far;
        double proposed_height_m;
    };
    
    // ---------- Globals ----------
    
    map<BandKey, RegBand> bandTree;
    
    // ---------- Helpers ----------
    
    int plot_band(double a) {
        if (a < 60.0)   return 1;
        if (a < 120.0)  return 2;
        if (a < 240.0)  return 3;
        if (a < 480.0)  return 4;
        return 5;
    }
    
    int round_road(double w) {
        return static_cast<int>(round(w));
    }
    
    vector<string> split_csv(const string &line) {
        vector<string> out;
        string cur;
        bool in_quotes = false;
        for (char c : line) {
            if (c == '"') {
                in_quotes = !in_quotes;
            } else if (c == ',' && !in_quotes) {
                out.push_back(cur);
                cur.clear();
            } else {
                cur.push_back(c);
            }
        }
        out.push_back(cur);
        return out;
    }
    
    // ---------- Load bands from CSV ----------
    
    void load_bands_from_csv(const string &filename) {
        ifstream fin(filename);
        if (!fin.is_open()) {
            cerr << "Cannot open file: " << filename << "\n";
            exit(1);
        }
    
        string line;
        // header
        if (!getline(fin, line)) {
            cerr << "Empty file\n";
            exit(1);
        }
    
        while (getline(fin, line)) {
            if (line.empty()) continue;
            auto cols = split_csv(line);
            if (cols.size() < 7) continue; // sanity
    
            string zone_code    = cols[1];
            double plot_area    = stod(cols[4]);
            double max_far      = stod(cols[5]);
            double max_height_m = stod(cols[6]);
    
            int pb  = plot_band(plot_area);
            int rw  = round_road(max_height_m);   // placeholder for road width
    
            BandKey key{zone_code, rw, pb};
            RegBand rb{max_far, max_height_m};
    
            // insert / update band
            bandTree[key] = rb;
        }
    
        fin.close();
    }
    
    // ---------- Evaluate a proposal ----------
    
    bool evaluate(const Proposal &p, string &reason) {
        BandKey k{p.zone, round_road(p.road_width_m), plot_band(p.plot_area_sqm)};
        auto it = bandTree.find(k);
        if (it == bandTree.end()) {
            reason = "no matching band";
            return false;
        }
        const RegBand &rb = it->second;
    
        if (p.proposed_far > rb.max_far) {
            reason = "FAR exceeds " + to_string(rb.max_far);
            return false;
        }
        if (p.proposed_height_m > rb.max_height_m) {
            reason = "height exceeds " + to_string(rb.max_height_m);
            return false;
        }
        reason = "OK";
        return true;
    }
    
    // ---------- Main demo ----------
    
    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
    
        // change to your actual CSV name
        string filename = "land_housing_zoning_with_status.csv";
        load_bands_from_csv(filename);
    
        cout << "Loaded " << bandTree.size() << " bands into RB‑tree\n";
    
        // two sample proposals using real‑ish values
        Proposal p1{
            "RZ_RES_LOW", 17.0, 110.0, 1.8, 16.0
        };
        Proposal p2{
            "RZ_RES_LOW", 17.0, 110.0, 3.0, 25.0
        };
    
        for (int i = 0; i < 2; ++i) {
            Proposal p = (i == 0 ? p1 : p2);
            string reason;
            bool ok = evaluate(p, reason);
            cout << "Proposal " << (i + 1) << ": "
                 << (ok ? "APPROVED: " : "REJECTED: ")
                 << reason << "\n";
        }
    
        return 0;
    }
    
</pre></code>

</div>
</div> 

        <!-- iii) Permissions / phasing -->
        <div class="content-box">
            <h3>Permissions, Phasing & Updates</h3>
            <div class="rule"></div>

            <p>
               The flow of applications is treated as a controlled processing pipeline and implemented with a
               <b>double‑ended queue (deque)</b>. Normal building and layout applications enter at the back and are
               processed from the front in a clean FIFO manner, while phase‑critical or policy‑priority projects
               (such as public or affordable housing) can be pushed to the front to be handled earlier.
            </p>

            <p>
               Each application’s full data is stored in an indexed array or vector; the deque manages the order through
               <code>push_back</code>, <code>push_front</code> and <code>pop_front</code> in constant time. This mirrors how permissions,
               phasing and plan updates work in practice—mostly queue‑based, but with the flexibility to fast‑track or
               defer specific cases when the city’s development strategy demands it.
            </p>
            <h4>Implementation:</h4>
            <br>
            
            
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/phasing.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Core Structure: Deque </div>
            <br><br>

            
            <button type="button" 
            class="btn btn-success"
            onclick="togglePhasingCode()">
        Code
    </button>
    <a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/applications_processed.csv"
   target="_blank">
  Dataset
</a>

    
    <div id="phasing-code-block" style="display:none; margin-top:20px;">
    
        <h4>C++ Logic used</h4>
        <pre><code>#include &lt;iostream&gt;
            #include <bits/stdc++.h>
            using namespace std;
            
            // One application record loaded from CSV
            struct Application {
                string app_id;
                string zone;
                double plot_area_sqm;
                double road_width_m;
                double proposed_far;
                double proposed_height_m;
                string priority;        // "PRIORITY" or "NORMAL"
                string status;          // APPROVED / DEFERRED / PENDING
                string phase;           // PHASE_1 / PHASE_2 / ...
                int    processed_order; // 1..1000
                string fast_tracked;    // "YES" / "NO"
            };
            
            int main() {
                ios::sync_with_stdio(false);
                cin.tie(nullptr);
            
                // ------------ load CSV into vector<Application> ------------
                // Assumes a file "applications_processed.csv" with 1000 rows
                // and header: app_id,zone,plot_area_sqm,road_width_m,proposed_far,proposed_height_m,priority,status,phase,processed_order,fast_tracked
                ifstream fin("ananya/Datasets/applications_processed.csv");
                if (!fin) {
                    cerr << "Could not open applications_processed.csv\n";
                    return 1;
                }
            
                vector<Application> apps;
                string line;
            
                // skip header
                getline(fin, line);
            
                while (getline(fin, line)) {
                    if (line.empty()) continue;
                    stringstream ss(line);
                    string token;
                    Application a;
            
                    getline(ss, a.app_id, ',');
                    getline(ss, a.zone, ',');
                    getline(ss, token, ','); a.plot_area_sqm = stod(token);
                    getline(ss, token, ','); a.road_width_m = stod(token);
                    getline(ss, token, ','); a.proposed_far = stod(token);
                    getline(ss, token, ','); a.proposed_height_m = stod(token);
                    getline(ss, a.priority, ',');
                    getline(ss, a.status, ',');
                    getline(ss, a.phase, ',');
                    getline(ss, token, ','); a.processed_order = stoi(token);
                    getline(ss, a.fast_tracked, ',');
            
                    apps.push_back(a);
                }
            
                cout << "Loaded " << apps.size() << " applications\n";
            
                // ------------ processing pipeline using deque ------------
                deque<int> dq; // stores indices into apps vector
            
                for (int i = 0; i < (int)apps.size(); ++i) {
                    const Application &a = apps[i];
            
                    bool is_priority = (a.priority == "PRIORITY") || (a.fast_tracked == "YES");
                    if (is_priority) {
                        // phase‑critical or policy‑priority: go to the front
                        dq.push_front(i);          // O(1)
                    } else {
                        // normal application: join the back of the queue
                        dq.push_back(i);           // O(1)
                    }
                }
            
                // Process applications in pipeline order (front of deque)
                while (!dq.empty()) {
                    int idx = dq.front();
                    dq.pop_front();                // O(1)
            
                    Application &a = apps[idx];
            
                    // Example processing logic: here just print a summary line
                    cout << "Processing " << a.app_id
                         << " zone=" << a.zone
                         << " priority=" << a.priority
                         << " fast_tracked=" << a.fast_tracked
                         << " phase=" << a.phase << "\n";
            
                    // In a real system, this is where approval/deferral rules would run,
                    // possibly updating a.status or a.phase.
                }
            
                return 0;
            }
            </code></pre>
    
    </div>
        </div>
    

    <!-- =====================================================
         BLOCK 2: WILDLIFE & MANAGEMENT
    ====================================================== -->
    <h2 class="section-heading">Wildlife & Management</h2>

    <div class="content-box-container">

        <!-- i) PATROL & SECURITY -->
        <div class="content-box">
            <h3>Patrol & Security – Dijkstra (Single Source)</h3>
            <div class="rule"></div>

            <p>
                The wildlife zone is treated as a live, data‑driven patrol network where every watchtower, gate, water reservoir and conflict‑prone location is connected by trails and forest roads. 
                Rangers at any post can always ask the system for the fastest safe route to a new incident point, whether it is a poaching alert near a boundary or a distress call near a water body.
              </p>
              
              <p>
                In the implementation, each of these locations becomes a node in a weighted graph, and every road or path between them is an edge with a cost representing travel time, terrain difficulty or risk level. 
                The graph is stored using adjacency lists so that from any location it is efficient to scan all outgoing paths and update their tentative travel cost during routing.
                
              </p>
              
              <p>
                From a selected starting tower or base camp, Dijkstra’s single‑source shortest path algorithm is run once to compute the minimum‑time route to every other node in the reserve. 
                Internally, the system maintains a distance array, a visited set, and a min‑priority queue that repeatedly picks the unvisited node with the smallest known travel time and relaxes its outgoing edges to see if they provide a faster route to neighbouring patrol points.
              </p>
              
              <p>
                In practice, this behaves like a GPS tailored to conservation work: once the rangers’ current position is fixed, the system can instantly answer “what is the best route to this incident?” by looking up the pre‑computed distance and reconstructing the path. 
                If monsoon conditions or temporary closures make certain tracks slower or unsafe, the corresponding edge weights are increased, and the next run of Dijkstra automatically diverts patrols along alternate trails that are slightly longer in distance but better in effective response time and safety.
              
              <p>
                This allows the patrolling module to be framed as hands‑on work: the wildlife wing was modelled as a weighted graph over the reserve’s patrol grid, with Dijkstra’s algorithm driving both routine patrol planning and time‑critical responses. 
                Routes and priorities are no longer based purely on intuition; they adapt continuously to terrain, season and historical patrol data, making coverage and incident response more objective, transparent and data‑driven for the forest department.
              </p>
              

            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/patroling.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Algorithm:Dijakstra  </div>
            <br><br>


            <button type="button" 
        class="btn btn-success"
        onclick="togglePatrolCode()">
    Code
</button>
<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/wildlife_patrol_distances.csv"
   target="_blank">
  Dataset
</a>


<div id="patrol-code-block" style="display:none; margin-top:20px;">

    <h4>C++ Logic used (Patrol Routing with Dijkstra)</h4>
    <pre><code>#include &lt;iostream&gt;
        #include <bits/stdc++.h>
        using namespace std;
        
        struct NodeInfo {
            int    id;
            string type;
            double dist; // minutes from source (precomputed by Python)
        };
        
        int main() {
            ios::sync_with_stdio(false);
            cin.tie(nullptr);
        
            string filename = "wildlife_patrol_distances.csv";
            ifstream fin(filename);
            if (!fin) {
                cerr << "Could not open " << filename << "\n";
                return 1;
            }
        
            vector<NodeInfo> nodes;
            string line;
        
            // skip header
            if (!getline(fin, line)) {
                cerr << "Empty CSV\n";
                return 1;
            }
        
            while (getline(fin, line)) {
                if (line.empty()) continue;
                stringstream ss(line);
                string token;
        
                NodeInfo ni;
        
                // node_id
                getline(ss, token, ',');
                ni.id = stoi(token);
        
                // node_type
                getline(ss, ni.type, ',');
        
                // distance_from_source_minutes
                getline(ss, token, ',');
                ni.dist = stod(token);
        
                nodes.push_back(ni);
            }
        
            cout << "Loaded " << nodes.size()
                 << " patrol points with precomputed travel times.\n\n";
        
            cout << "Node   Type            MinTime(from source, min)\n";
            for (const auto &ni : nodes) {
                cout << setw(4) << ni.id << "   "
                     << setw(12) << ni.type << "   "
                     << fixed << setprecision(2) << ni.dist << "\n";
            }
        
            // Example: sort by travel time to suggest response order
            sort(nodes.begin(), nodes.end(),
                 [](const NodeInfo &a, const NodeInfo &b) {
                     return a.dist < b.dist;
                 });
        
            cout << "\nSuggested incident response order (closest first):\n";
            for (int i = 0; i < min<int>(10, nodes.size()); ++i) {
                const auto &ni = nodes[i];
                cout << i + 1 << ") node " << ni.id
                     << " (" << ni.type << "), "
                     << ni.dist << " minutes from source\n";
            }
        
            return 0;
        }
        
}</code></pre>

    </code></pre>

</div>
</div>


        <!-- ii) ANIMAL HEALTH -->
        <div class="content-box">
            <h3>Animal Health</h3>
            <div class="rule"></div>

            <p>
                Wildlife health management is organised into three parts: emergency triage, central storage of animal
                details and stock monitoring for water and medical supplies. Each component is mapped to a specific
                data structure that reflects how a real sanctuary needs to react and plan every day.[web:113]
            </p>

            <!-- a) Emergency – Max Heap -->
            <h4>a) Emergency – Max‑Heap</h4>
            <p>
                During emergencies, vets must immediately know which case is most critical. Every animal is given a
                dynamic risk score based on injuries, illness, behaviour changes and recent reports. These entries are
                kept in a <b>max‑heap</b>, ordered by risk score, so the animal at the top is always the one that needs
                attention first; updating a score and pushing it back into the heap keeps the priority list constantly
                refreshed.
            </p>
            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/heapp.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Algorithm:Max Heap  </div>
            <br><br>
            <button type="button" 
            class="btn btn-success"
            onclick="toggleHeapCode()">
        Code
    </button>
    <a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/animal_cases_heap_output.csv"
   target="_blank">
  Dataset
</a>

    
    <div id="heap-code-block" style="display:none; margin-top:20px;">
    
      <h4>C++ Logic used (Bottom‑up Max Heap for Priorities)</h4>
      <pre><code>#include &lt;iostream&gt;
        #include <bits/stdc++.h>
using namespace std;

struct CaseInfo {
    int heap_index;
    string case_id;
    string species;
    string condition;
    string triage_level;
    double age_years;
    double temperature_c;
    int resp_rate_min;
    int heart_rate_bpm;
    int trauma_severity_0_3;
    string infectious_suspect;
    string pregnant;
    double priority_score;
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string filename = "animal_cases_heap_output.csv";
    ifstream fin(filename);
    if (!fin) {
        cerr << "Could not open " << filename << "\n";
        return 1;
    }

    vector<CaseInfo> cases;
    string line;

    // skip header
    if (!getline(fin, line)) {
        cerr << "Empty CSV\n";
        return 1;
    }

    while (getline(fin, line)) {
        if (line.empty()) continue;
        stringstream ss(line);
        string token;
        CaseInfo c;

        // heap_index
        getline(ss, token, ',');
        c.heap_index = stoi(token);

        // case_id
        getline(ss, c.case_id, ',');

        // species
        getline(ss, c.species, ',');

        // condition
        getline(ss, c.condition, ',');

        // triage_level
        getline(ss, c.triage_level, ',');

        // age_years
        getline(ss, token, ',');
        c.age_years = stod(token);

        // temperature_c
        getline(ss, token, ',');
        c.temperature_c = stod(token);

        // resp_rate_min
        getline(ss, token, ',');
        c.resp_rate_min = stoi(token);

        // heart_rate_bpm
        getline(ss, token, ',');
        c.heart_rate_bpm = stoi(token);

        // trauma_severity_0_3
        getline(ss, token, ',');
        c.trauma_severity_0_3 = stoi(token);

        // infectious_suspect
        getline(ss, c.infectious_suspect, ',');

        // pregnant
        getline(ss, c.pregnant, ',');

        // priority_score
        getline(ss, token, ',');
        c.priority_score = stod(token);

        cases.push_back(c);
    }

    cout << "Loaded " << cases.size()
         << " animal triage cases from heap dataset.\n\n";

    cout << left
         << setw(4)  << "Idx"
         << setw(8)  << "HeapPos"
         << setw(10) << "CaseID"
         << setw(10) << "Species"
         << setw(14) << "Triage"
         << setw(6)  << "Age"
         << setw(6)  << "Temp"
         << setw(6)  << "RR"
         << setw(6)  << "HR"
         << setw(4)  << "Tra"
         << setw(5)  << "Inf?"
         << setw(5)  << "Preg?"
         << setw(9)  << "Priority"
         << "\n";

    int show = min<int>(15, cases.size());
    for (int i = 0; i < show; ++i) {
        const CaseInfo &c = cases[i];
        cout << setw(4)  << (i + 1)
             << setw(8)  << c.heap_index
             << setw(10) << c.case_id
             << setw(10) << c.species
             << setw(14) << c.triage_level
             << setw(6)  << fixed << setprecision(1) << c.age_years
             << setw(6)  << setprecision(1) << c.temperature_c
             << setw(6)  << c.resp_rate_min
             << setw(6)  << c.heart_rate_bpm
             << setw(4)  << c.trauma_severity_0_3
             << setw(5)  << c.infectious_suspect
             << setw(5)  << c.pregnant
             << setw(9)  << setprecision(2) << c.priority_score
             << "\n";
    }

    // verify heap property for priority_score
    bool heap_ok = true;
    int n = (int)cases.size();

    auto getPriority = [&](int heapPos) -> double {
        return cases[heapPos - 1].priority_score; // heap_index == position
    };

    for (int i = 1; i <= n / 2; ++i) {
        int left  = 2 * i;
        int right = 2 * i + 1;
        double parentP = getPriority(i);
        if (left <= n && parentP < getPriority(left))  heap_ok = false;
        if (right <= n && parentP < getPriority(right)) heap_ok = false;
    }

    cout << "\nHeap property on priority_score: "
         << (heap_ok ? "OK" : "VIOLATED") << "\n";

    return 0;
}

    </code></pre>
    
      
    
    </div>


  
            <!-- b) Storing animal details – Hashmap -->
            <h4>b) Storing Animal Details – Hashmap</h4>
            <p>
                Each animal in the sanctuary receives a unique ID linked to species, age, location, health notes and
                current risk score. These records are stored in a <b>hashmap</b> keyed by animal ID, which provides
                constant‑time access during patrols and routine checks, so any profile can be pulled or updated without
                scanning long lists.
            </p>

            <p>
                Alongside the live record, a vector of historical health snapshots is maintained per animal. At the end
                of each check cycle, a new entry is appended with date, risk score and remarks, enabling trend analysis
                over weeks or months without slowing real‑time operations.
            </p>

            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/heapify.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Data Structure:Hash Maps  </div>
            <br><br>
            <button type="button" 
        class="btn btn-success"
        onclick="toggleAnimalHashCode()">
    Code
</button>
<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/animal_hashmap_output__score_.csv"
   target="_blank">
  Dataset
</a>


<div id="animal-hash-code-block" style="display:none; margin-top:20px;">

  <h4>C++ Logic used (Array‑based Hash Lookup for Animal Records)</h4>
  <pre><code>
    #include <bits/stdc++.h>
    using namespace std;
    
    const int MAX_ANIMALS = 1000;
    
    // Array-based "hash map" (direct index = Animal_ID)
    string  speciesArr[MAX_ANIMALS];
    int     riskScoreArr[MAX_ANIMALS];
    string  zoneArr[MAX_ANIMALS];
    int     ageArr[MAX_ANIMALS];
    string  lastCheckArr[MAX_ANIMALS];
    int     healthScoreArr[MAX_ANIMALS];   // single score only
    
    // Generate a random recent date (last 30 days) in DD-MM-YYYY format
    string randomRecentDate(mt19937 &gen) {
        uniform_int_distribution<int> dayBack(1, 30);
        int back = dayBack(gen);
    
        using namespace chrono;
        auto today  = chrono::system_clock::now();
        auto target = today - chrono::hours(24 * back);
        time_t tt   = chrono::system_clock::to_time_t(target);
        tm *lt      = localtime(&tt);
    
        char buf[11];
        strftime(buf, sizeof(buf), "%d-%m-%Y", lt);   // DD-MM-YYYY
        return string(buf);
    }
    
    int main() {
        // Random engine and distributions
        random_device rd;
        mt19937 gen(rd());
    
        uniform_int_distribution<int> riskDist(1, 10);     // 1..10
        uniform_int_distribution<int> ageDist(1, 25);      // 1..25
        uniform_int_distribution<int> healthDist(50, 100); // 50..100
    
        // Full species list (same as Python)
        vector<string> speciesList = {
            "Tiger", "Elephant", "Bear", "Leopard", "Wolf",
            "TIGER", "LEOPARD", "ELEPHANT", "RHINO",
            "GAUR", "SLOTH_BEAR", "WILD_DOG", "HYENA",
            "SAMBAR_DEER", "CHITAL", "BARASINGHA", "NILGAI",
            "WILD_BOAR", "BLACKBUCK", "LANGUR", "MACAQUE",
            "CROCODILE", "OTTER", "PEAFOWL", "HORNBILL"
        };
    
        vector<string> zones = {"Zone-1", "Zone-2", "Zone-3", "Zone-4", "Zone-5"};
    
        // ---- Generate data for 1000 animals ----
        for (int id = 0; id < MAX_ANIMALS; ++id) {
            // Species and zone pattern must match Python behaviour:
            // Python currently uses species_list[animal_id % 5] and zones[animal_id % 5],
            // so we do the same here.
            speciesArr[id]   = speciesList[id % 5];
            zoneArr[id]      = zones[id % 5];
    
            riskScoreArr[id] = riskDist(gen);
            ageArr[id]       = ageDist(gen);
            lastCheckArr[id] = randomRecentDate(gen);
            healthScoreArr[id] = healthDist(gen);   // exactly ONE health score
        }
    
        // ---- Sample query for Animal ID 0 (similar to Python print) ----
        int queryId = 0;
        cout << "Sample ID " << queryId << ": "
             << speciesArr[queryId]
             << " | Risk: " << riskScoreArr[queryId]
             << " | Zone: " << zoneArr[queryId]
             << " | Health: " << healthScoreArr[queryId]
             << "\n";
    
        // ---- CSV export (same structure and filename as Python) ----
        string filename = "realistic_animal_hashmap_output_single_score_.csv";
        ofstream fout(filename);
        if (!fout) {
            cerr << "Error opening output CSV file\n";
            return 1;
        }
    
        // Header
        fout << "Animal_ID,"
             << "Species,"
             << "Risk_Score,"
             << "Zone,"
             << "Age_Years,"
             << "Last_Check,"
             << "Health_Score\n";
    
        // Rows
        for (int id = 0; id < MAX_ANIMALS; ++id) {
            fout << id << ","
                 << speciesArr[id] << ","
                 << riskScoreArr[id] << ","
                 << zoneArr[id] << ","
                 << ageArr[id] << ","
                 << lastCheckArr[id] << ","
                 << healthScoreArr[id] << "\n";
        }
    
        fout.close();
        cout << "Generated " << filename
             << " with ONE health score per animal\n";
    
        return 0;
    }
    
  </code></pre>

</div>

<!-- c) Stock – Fenwick Tree -->
          <h4>c) Stock (Water & Medical Supplies) – Fenwick Tree</h4>
            <p>
                Water in reservoirs and medical supplies across clinics are monitored as continuous resources that
                fluctuate throughout the day. Storage points are indexed, and a <b>Fenwick Tree (Binary Indexed
                Tree)</b> is built over this index to support fast prefix and range‑sum queries such as “total water in
                this cluster of reservoirs” or “total vaccine doses available along one corridor”.
            </p>

            <p>
                Individual refills and consumptions update single positions in the Fenwick Tree, while range summaries
                can still be answered in logarithmic time. This structure makes continuous stock monitoring efficient
                and keeps the system ready for sudden demand during emergencies.
            </p>

            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/BIT.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Data Structure:Fenwick Tree  </div>
            <br><br>
            <button type="button" 
        class="btn btn-success"
        onclick="toggleBITCode()">
    Code
</button>
<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/stock_points_fenwick_rich.csv"
   target="_blank">
  Dataset
</a>

<div id="bit-code-block" style="display:none; margin-top:20px;">

  <h4>C++ Logic used (Fenwick / BIT for Resource Monitoring)</h4>
  #include <bits/stdc++.h>
using namespace std;

struct StockPoint {
    int index;
    string node_type;
    string zone;
    string corridor;
    string facility_name;
    double gps_lat;
    double gps_lon;
    string criticality_level;
    string resource_type;
    double capacity_units;
    double final_stock_units;
};

struct FenwickTree {
    int n;
    vector<double> bit; // 1-indexed

    FenwickTree(int n = 0) { init(n); }

    void init(int n_) {
        n = n_;
        bit.assign(n + 1, 0.0);
    }

    void update(int idx, double delta) {
        for (int i = idx; i <= n; i += i & -i)
            bit[i] += delta;
    }

    double prefix_sum(int idx) const {
        double s = 0.0;
        for (int i = idx; i > 0; i -= i & -i)
            s += bit[i];
        return s;
    }

    double range_sum(int l, int r) const {
        if (l > r) return 0.0;
        return prefix_sum(r) - prefix_sum(l - 1);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string filename = "stock_points_fenwick_rich.csv";
    ifstream fin(filename);
    if (!fin) {
        cerr << "Could not open " << filename << "\n";
        return 1;
    }

    vector<StockPoint> pts;
    string line;

    // skip header
    if (!getline(fin, line)) {
        cerr << "Empty CSV\n";
        return 1;
    }

    while (getline(fin, line)) {
        if (line.empty()) continue;
        stringstream ss(line);
        string token;
        StockPoint p;

        getline(ss, token, ','); p.index = stoi(token);
        getline(ss, p.node_type, ',');
        getline(ss, p.zone, ',');
        getline(ss, p.corridor, ',');
        getline(ss, p.facility_name, ',');
        getline(ss, token, ','); p.gps_lat = stod(token);
        getline(ss, token, ','); p.gps_lon = stod(token);
        getline(ss, p.criticality_level, ',');
        getline(ss, p.resource_type, ',');
        getline(ss, token, ','); p.capacity_units = stod(token);
        getline(ss, token, ','); p.final_stock_units = stod(token);

        pts.push_back(p);
    }

    int n = (int)pts.size();
    cout << "Loaded " << n << " stock points.\n";

    FenwickTree ft(n);
    for (const auto &p : pts)
        ft.update(p.index, p.final_stock_units);

    // Example 1: total stock in first 100 indexed points
    cout << "Total stock [1, 100]: "
         << ft.range_sum(1, 100) << "\n";

    // Example 2: total stock in one corridor
    string target_corridor = "RIVER_EAST";
    double corridor_total = 0.0;
    for (const auto &p : pts)
        if (p.corridor == target_corridor)
            corridor_total += p.final_stock_units;
    cout << "Total stock in corridor " << target_corridor
         << ": " << corridor_total << "\n";

    // Example 3: upgrade a HIGH-criticality clinic at index 25
    int idx = 25;
    double extra = 300.0;
    ft.update(idx, extra);
    cout << "After adding " << extra << " units at index " << idx
         << ", prefix up to " << idx << " = "
         << ft.prefix_sum(idx) << "\n";

    return 0;
}
</code></pre>

</div>
</div>
        <!-- iii) R&D – Boyer–Moore -->
        <div class="content-box">
            <h3>Research & Development – Boyer–Moore</h3>
            <div class="rule"></div>

            <p>
                The wildlife zone also functions as a research space where genetic data and long‑term behaviour logs
                are stored as sequences. Important signals such as risky gene markers or recurring stress patterns need
                to be located quickly inside these long strings, so the <b>Boyer–Moore</b> string‑matching algorithm is
                used instead of naive scanning.
            </p>

            <p>
                Each gene sample or weekly behaviour trace is saved as a long text over some alphabet, such as nucleotides for genetics or stress‑event codes for behaviour. When a biologist wants to check if a risky marker (a short pattern) appears anywhere inside that text, Boyer–Moore pre‑processes just the pattern once and then scans the big string from right to left, skipping whole chunks whenever a mismatch proves that alignment impossible
            </p>
            <p>
                Instead of checking every character position like the naive algorithm, Boyer–Moore uses “bad‑character” and “good‑suffix” rules to jump ahead several indices at a time, which makes it much faster on long logs and genome‑scale data. In practice this means a researcher can run near real‑time queries such as “find all occurrences of this gene motif” or “locate every repeated stress code subsequence” across months of stored data without blocking the system.
            </p>

            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/boyree.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Algorithm:Boyer Moore  </div>
            <br><br>
            <button type="button" 
        class="btn btn-success"
        onclick="toggleBMCode()">
       
    Code
</button>
</button>
<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/wildlife_boyer_moore_1000_matches.csv"
   target="_blank">
  Dataset
</a>



<div id="bm-code-block" style="display:none; margin-top:20px;">

  <h4>C++ Logic used (Boyer–Moore for Gene / Behaviour Logs)</h4>
  <pre><code>#include &lt;iostream&gt;
    #include <bits/stdc++.h>
    using namespace std;
    
    const int ALPH = 256;
    
    void buildLast(const string &pat, int last[]) {
        for (int i = 0; i < ALPH; ++i) last[i] = -1;
        for (int i = 0; i < (int)pat.size(); ++i)
            last[(unsigned char)pat[i]] = i;
    }
    
    vector<int> boyerMoore(const string &text, const string &pat) {
        int n = (int)text.size(), m = (int)pat.size();
        vector<int> matches;
        if (m == 0 || n == 0 || m > n) return matches;
        int last[ALPH];
        buildLast(pat, last);
        int s = 0;
        while (s <= n - m) {
            int j = m - 1;
            while (j >= 0 && pat[j] == text[s + j]) --j;
            if (j < 0) {
                matches.push_back(s);
                if (s + m < n) s += m - last[(unsigned char)text[s + m]];
                else ++s;
            } else {
                unsigned char bad = text[s + j];
                int shift = j - last[bad];
                if (shift < 1) shift = 1;
                s += shift;
            }
        }
        return matches;
    }
    
    string randomGene(int len, mt19937 &g) {
        static const string alph = "ACGT";
        uniform_int_distribution<int> d(0, (int)alph.size() - 1);
        string s(len, 'A');
        for (int i = 0; i < len; ++i) s[i] = alph[d(g)];
        return s;
    }
    
    string randomStress(int len, mt19937 &g) {
        static const string alph = "HL";
        uniform_int_distribution<int> d(0, (int)alph.size() - 1);
        string s(len, 'H');
        for (int i = 0; i < len; ++i) s[i] = alph[d(g)];
        return s;
    }
    
    int main() {
        mt19937 gen(random_device{}());
        string riskyPattern  = "ACGTACG";
        string stressPattern = "HHLH";
    
        struct Sample { string id, type, text, pattern; };
        vector<Sample> data;
        data.reserve(1000);
    
        for (int i = 0; i < 1000; ++i) {
            Sample s;
            s.id = "S" + to_string(i + 1);
            if (i % 2 == 0) {
                s.type = "GENE";
                s.text = randomGene(80, gen);
                s.pattern = riskyPattern;
            } else {
                s.type = "STRESS";
                s.text = randomStress(80, gen);
                s.pattern = stressPattern;
            }
            data.push_back(move(s));
        }
    
        ofstream fout("wildlife_boyer_moore_1000_matches_cpp.csv");
        if (!fout) {
            cerr << "Error opening CSV\n";
            return 1;
        }
        fout << "Sample_ID,Log_Type,Pattern,Start_Index\n";
    
        for (const auto &s : data) {
            vector<int> pos = boyerMoore(s.text, s.pattern);
            for (int p : pos) {
                fout << s.id << "," << s.type << ","
                     << s.pattern << "," << p << "\n";
            }
        }
        fout.close();
        cout << "Generated wildlife_boyer_moore_1000_matches_cpp.csv\n";
        return 0;
    }
    </code></pre>

</div>

</div>
        <!-- iv) CARBON CREDITS – Segment Tree -->
        <div class="content-box">
            <h3>Carbon Credits – Segment Tree</h3>
            <div class="rule"></div>

            <p>
                Each forest band, plantation strip or wetland patch is mapped to an index in a base array, where a[i] stores the estimated annual carbon sequestration (in tonnes of CO₂) for segment i. This linearisation lets the carbon layer plug directly into a segment tree, since the structure is designed to answer repeated range‑sum questions over such arrays while still allowing point updates.
            </p>
            <p>
                bove this array, a segment tree is built as a binary tree in an internal array tree[], where each node covers a contiguous range of segments and stores the sum of their carbon values. Leaves correspond to single segments, and each internal node stores tree[node] = leftSum + rightSum, so building the tree once from the base array costs 
O
(
n
)
O(n) time and prepares it for queries and updates.
            </p>

            <p>
                To keep this data ready for continuous analysis, the segments are placed in a linear structure and a
                <b>Segment Tree</b> is built over them. This allows range‑sum queries like “total carbon captured along
                this corridor” and point updates when restoration, degradation or new planting occurs, so carbon‑credit
                values can be recalculated quickly for many funding and reporting scenarios.
            </p>

            <h4>Implementation:</h4>
            <div style="text-align:center; margin:20px 0;">
                <img src="Masterplan/seg.jpg"
                     alt="City Master Plan & Zoning mindmap"
                     style="width:450px; height:auto; border:2px solid #000;">
            </div>
            <div class="algo-div">Algorithm:Segment Tree </div>
            <br><br>
            <button type="button" 
        class="btn btn-success"
        onclick="toggleSegTreeCode()">
    Code
</button>
<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/carbon_segments_1000.csv"
   target="_blank">
  Dataset
</a>


<div id="seg-code-block" style="display:none; margin-top:20px;">
    // carbon_segment_tree.cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    struct Segment {
        int segmentId;
        string bandType;          // Forest / Plantation / Wetland
        string zone;              // Zone-1 .. Zone-5
        double lengthKm;
        double widthM;
        double areaHa;
        double carbonPerYear;     // tCO2/year, this is a[i]
    };
    
    const int MAX_SEGMENTS = 1000;
    
    // ---------- Segment Tree for range-sum and point update ----------
    struct CarbonSegmentTree {
        int n;
        vector<double> a;      // base array
        vector<double> tree;   // 4*n
    
        CarbonSegmentTree() : n(0) {}
    
        explicit CarbonSegmentTree(const vector<double> &values) {
            build(values);
        }
    
        void build(const vector<double> &values) {
            a = values;
            n = (int)a.size();
            tree.assign(4 * max(1, n), 0.0);
            if (n > 0) buildRec(1, 0, n - 1);
        }
    
        void buildRec(int node, int l, int r) {
            if (l == r) {
                tree[node] = a[l];
                return;
            }
            int mid = (l + r) / 2;
            buildRec(2 * node, l, mid);
            buildRec(2 * node + 1, mid + 1, r);
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    
        void update(int idx, double val) {
            if (idx < 0 || idx >= n) return;
            updateRec(1, 0, n - 1, idx, val);
        }
    
        void updateRec(int node, int l, int r, int idx, double val) {
            if (l == r) {
                tree[node] = val;
                a[idx] = val;
                return;
            }
            int mid = (l + r) / 2;
            if (idx <= mid) updateRec(2 * node, l, mid, idx, val);
            else updateRec(2 * node + 1, mid + 1, r, idx, val);
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    
        double query(int ql, int qr) const {
            if (n == 0 || ql < 0 || qr >= n || ql > qr) return 0.0;
            return queryRec(1, 0, n - 1, ql, qr);
        }
    
        double queryRec(int node, int l, int r, int ql, int qr) const {
            if (qr < l || r < ql) return 0.0;
            if (ql <= l && r <= qr) return tree[node];
            int mid = (l + r) / 2;
            return queryRec(2 * node, l, mid, ql, qr)
                 + queryRec(2 * node + 1, mid + 1, r, ql, qr);
        }
    };
    
    // ---------- Generate realistic segments ----------
    vector<Segment> generateSegments(int n = MAX_SEGMENTS) {
        vector<Segment> segs;
        segs.reserve(n);
    
        vector<string> bandTypes = {"Forest", "Plantation", "Wetland"};
        vector<string> zones = {"Zone-1", "Zone-2", "Zone-3", "Zone-4", "Zone-5"};
    
        mt19937 rng(42);
        uniform_real_distribution<double> lenDist(0.5, 5.0);     // km
        uniform_real_distribution<double> widthDist(20.0, 200.0); // m
        uniform_real_distribution<double> forestPerHa(8.0, 25.0);
        uniform_real_distribution<double> plantPerHa(5.0, 18.0);
        uniform_real_distribution<double> wetPerHa(3.0, 12.0);
        // ranges loosely aligned with typical sequestration rates. [web:172][web:182]
    
        for (int i = 0; i < n; ++i) {
            Segment s;
            s.segmentId = i;
            s.bandType = bandTypes[i % (int)bandTypes.size()];
            s.zone = zones[i % (int)zones.size()];
    
            s.lengthKm = round(lenDist(rng) * 100.0) / 100.0;
            s.widthM   = round(widthDist(rng) * 10.0) / 10.0;
    
            // area (ha) = length_km * 1000 * width_m / 10000
            s.areaHa = s.lengthKm * 1000.0 * s.widthM / 10000.0;
            s.areaHa = round(s.areaHa * 100.0) / 100.0;
    
            double perHa;
            if (s.bandType == "Forest")      perHa = forestPerHa(rng);
            else if (s.bandType == "Plantation") perHa = plantPerHa(rng);
            else                               perHa = wetPerHa(rng);
    
            s.carbonPerYear = perHa * s.areaHa;
            s.carbonPerYear = round(s.carbonPerYear * 100.0) / 100.0;
    
            segs.push_back(s);
        }
    
        return segs;
    }
    
    // ---------- Optional: write dataset to CSV (one file to show as dataset) ----------
    void exportSegmentsCSV(const vector<Segment> &segs,
                           const string &filename = "carbon_segments_1000_cpp.csv") {
        ofstream out(filename);
        if (!out) {
            cerr << "Error opening " << filename << " for writing\n";
            return;
        }
        out << "Segment_ID,Band_Type,Zone,Length_km,Width_m,Area_ha,Carbon_tCO2_per_year\n";
        out.setf(ios::fixed);
        out << setprecision(2);
    
        for (const auto &s : segs) {
            out << s.segmentId << ","
                << s.bandType << ","
                << s.zone << ","
                << s.lengthKm << ","
                << s.widthM << ","
                << s.areaHa << ","
                << s.carbonPerYear << "\n";
        }
        out.close();
        cout << "Written dataset to " << filename << "\n";
    }
    
    int main() {
        // 1) Generate 1000 segments
        vector<Segment> segments = generateSegments();
    
        // 2) Build base array and segment tree
        vector<double> carbonValues;
        carbonValues.reserve(segments.size());
        for (const auto &s : segments) carbonValues.push_back(s.carbonPerYear);
    
        CarbonSegmentTree segTree(carbonValues);
    
        // 3) Example: print one corridor query and one update like C++ logic
        int L = 0, R = 99; // corridor [0, 99]
        double totalBefore = segTree.query(L, R);
        cout << "Total carbon from band " << L << " to " << R
             << " before update = " << totalBefore << " tCO2/year\n";
    
        // Point update: simulate restoration at some index
        int idx = 50;
        double newVal = segTree.a[idx] * 1.3; // +30%
        segTree.update(idx, newVal);
    
        double totalAfter = segTree.query(L, R);
        cout << "After updating band " << idx << " to " << newVal
             << ", total carbon in [" << L << "," << R << "] = "
             << totalAfter << " tCO2/year\n";
    
        // 4) Export dataset (single CSV you can show as dataset)
        exportSegmentsCSV(segments);
    
        return 0;
    }
    
  
/code></pre>
        </div>

    </div>

    <!-- =====================================================
         BLOCK 3: TEAK & SANDALWOOD INDUSTRY
    ====================================================== -->
    <h2 class="section-heading">Sandalwood Industry</h2>

<div class="content-box-container">
  <div class="content-box">
    <h3>Green Industrial Timber Belt</h3>
    <div class="rule"></div>

    <p>
      The sandalwood industry wing treats every plantation block as a long-term asset with its own age, host-tree mix and expected harvest year. 
      Instead of keeping these blocks in flat lists or spreadsheets, the planning system organises them in a <b>Binary Search Tree (BST)</b>, keyed by harvest year, so that upcoming harvest windows can be queried and adjusted quickly for different policy and investment scenarios.
    </p>

    <p>
      Each node of the BST represents one sandalwood block: it stores the block identifier or compartment number as the key, along with its harvest year and a projected yield score. 
      The tree property—values smaller than a node’s key on the left, larger on the right—lets the planner insert new blocks, delete retired ones and traverse the tree in sorted order to generate a year-wise or range-wise harvest schedule without scanning the full registry every time.
    </p>

    <p>
      In practice this means that when the forest department wants to answer questions such as “which blocks are due between 2032 and 2035?” or “what does the 2030 harvest basket look like if we drop one risky block?”, the system simply walks the BST in-order or deletes/updates specific nodes. 
      The core operations—insert, delete and inorder traversal—run in time proportional to the height of the tree, so with reasonably balanced data the planning tool stays responsive even as more sandalwood estates and farmer groups are onboarded.
    </p>

    <h4>Implementation – Plantation Logic:</h4>
    <div style="text-align:center; margin:20px 0;">
      <img src="Masterplan/bst.jpg"
           alt="Sandalwood Harvest Planning – BST"
           style="width:450px; height:auto; border:2px solid #000;">
    </div>
    <div class="algo-div">Algorithm: Binary Search Tree</div>
    <br><br>

    <button type="button"
            class="btn btn-success"
            onclick="toggleBSTCode()">
      Code
    </button>
    <a class="btn btn-success text-decoration-none"
       href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/sandalwood_bst_blocks_1000.csv"
       target="_blank">
      Dataset
    </a>

    <!-- EVERYTHING TOGGLEABLE STAYS INSIDE THIS DIV -->
    <div id="bst-code-block" style="display:none; margin-top:20px;">

      <h4>C++ Logic used (BST for Sandalwood Blocks)</h4>
      <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

struct SandalwoodBlock {
    int blockId;
    int harvestYear;
    int plantingYear;
    int ageYears;
    string hostTreeMix;
    double projectedYieldScore;
};

struct BSTNode {
    pair&lt;int,int&gt; key;   // (harvestYear, blockId)
    SandalwoodBlock data;
    BSTNode *left;
    BSTNode *right;
    BSTNode(const pair&lt;int,int&gt; &amp;k, const SandalwoodBlock &amp;d)
        : key(k), data(d), left(nullptr), right(nullptr) {}
};

class SandalwoodBST {
public:
    BSTNode *root = nullptr;

    void insert(const SandalwoodBlock &amp;b) {
        pair&lt;int,int&gt; key = {b.harvestYear, b.blockId};
        root = insertRec(root, key, b);
    }

    vector&lt;SandalwoodBlock&gt; inorderBlocks() const {
        vector&lt;SandalwoodBlock&gt; res;
        inorderRec(root, res);
        return res;
    }

    vector&lt;SandalwoodBlock&gt; rangeQuery(int ys, int ye) const {
        vector&lt;SandalwoodBlock&gt; res;
        rangeRec(root, ys, ye, res);
        return res;
    }

private:
    static BSTNode* insertRec(BSTNode *node,
                              const pair&lt;int,int&gt; &amp;key,
                              const SandalwoodBlock &amp;b) {
        if (!node) return new BSTNode(key, b);
        if (key &lt; node-&gt;key)      node-&gt;left  = insertRec(node-&gt;left, key, b);
        else if (key &gt; node-&gt;key) node-&gt;right = insertRec(node-&gt;right, key, b);
        else                      node-&gt;data = b;
        return node;
    }

    static void inorderRec(BSTNode *node, vector&lt;SandalwoodBlock&gt; &amp;out) {
        if (!node) return;
        inorderRec(node-&gt;left, out);
        out.push_back(node-&gt;data);
        inorderRec(node-&gt;right, out);
    }

    static void rangeRec(BSTNode *node, int ys, int ye,
                         vector&lt;SandalwoodBlock&gt; &amp;out) {
        if (!node) return;
        int hy = node-&gt;data.harvestYear;
        if (hy &gt; ys)  rangeRec(node-&gt;left, ys, ye, out);
        if (ys &lt;= hy &amp;&amp; hy &lt;= ye) out.push_back(node-&gt;data);
        if (hy &lt; ye)  rangeRec(node-&gt;right, ys, ye, out);
    }
};

int main() {
    SandalwoodBST bst;
    SandalwoodBlock b1{101, 2030, 2010, 20, "Acacia_dominant", 82.5};
    SandalwoodBlock b2{102, 2033, 2015, 18, "Mixed_Hardwood", 78.0};
    SandalwoodBlock b3{103, 2035, 2012, 23, "Agroforestry_Farm", 74.3};

    bst.insert(b1);
    bst.insert(b2);
    bst.insert(b3);

    vector&lt;SandalwoodBlock&gt; due = bst.rangeQuery(2032, 2035);
    cout &lt;&lt; "Blocks due between 2032 and 2035:\\n";
    for (auto &amp;blk : due) {
        cout &lt;&lt; "  Block " &lt;&lt; blk.blockId
             &lt;&lt; " harvest " &lt;&lt; blk.harvestYear
             &lt;&lt; " score " &lt;&lt; blk.projectedYieldScore &lt;&lt; "\\n";
    }
    return 0;
}</code></pre>

    </div> <!-- /bst-code-block -->

  </div> <!-- /content-box -->
</div> <!-- /content-box-container -->

<script>
// single toggle function for this section
function toggleBSTCode() {
  var block = document.getElementById('bst-code-block');
  if (!block) return;
  var current = window.getComputedStyle(block).display;
  block.style.display = (current === 'none') ? 'block' : 'none';
}
</script>

<!-- Sandal wood planation block -->
<h2 class="section-heading">Sandalwood Access Network</h2>

<div class="content-box-container">
  <div class="content-box">
    <h3>Road & Track Planning Graph</h3>
    <div class="rule"></div>

    <p>
        The sandalwood access wing treats depots, plantation blocks and junctions as nodes in a weighted graph, where each edge represents a candidate forest track with a construction or maintenance cost.
        This graph structure lets planners reason about connectivity and route choices instead of static road lists, so new blocks or closures can be reflected immediately in the access plan.
      </p>
  
      <p>
        On top of this graph, Prim’s algorithm builds a Minimum Spanning Tree (MST) that selects a low-cost backbone of tracks connecting all active sandalwood blocks to at least one depot.
        Standard graph traversals like BFS and DFS then run over the same structure to simulate patrol routes, check reachability after storms, and explore local clusters of farmer estates.
      </p>
  
      <p>
        In practice this means queries such as “what is the cheapest network that connects these 200 new farmer blocks?” or “which blocks become unreachable if one critical bridge fails?” are answered by simply recomputing the MST or running BFS from a chosen depot.
        Because MST construction and traversal scale roughly with the number of edges in the graph, the access-planning tool stays responsive even as more sandalwood corridors and community plantations are added.
      </p>
      <h4>Implementation – Plantation Logic:</h4>
<div style="text-align:center; margin:20px 0;">
  <img src="Masterplan/prim.jpg"
       alt="Sandalwood Access Network – Prim's MST"
       style="width:450px; height:auto; border:2px solid #000;">
</div>
<div class="algo-div">Algorithm: Prim's Algorithm (Weighted Graph)</div>
<br><br>

<button type="button"
        class="btn btn-success"
        onclick="toggleSandalwoodGraphCode()">
  Code
</button>
<a class="btn btn-success text-decoration-none"
   href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/sandalwood_graph_nodes_1000.csv"
   target="_blank">
  Dataset
</a>

<!-- EVERYTHING TOGGLEABLE GOES INSIDE THIS DIV -->
<div id="sandalwood-graph-code-block" style="display:none; margin-top:20px;">

  <h4>C++ Logic used (Weighted Graph – Prim's for Network)</h4>
  <pre><code>// sandalwood_prim_mst.cpp
#include &lt;bits/stdc++.h&gt;
// sandalwood_prim_mst.cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int nodeId;
    string nodeType;     // "Block" or "Depot"
    string zone;         // Zone-1 .. Zone-5
    double blockAreaHa;
    int harvestYear;
    double priorityScore;
};

struct Edge {
    int u, v;
    double distanceKm;
    string trackType;
    double costWeight;
};

const int MAX_NODES = 1000;

vector<Node> generateNodes(int n = MAX_NODES, int seed = 7) {
    mt19937 rng(seed);
    vector<Node> nodes;
    nodes.reserve(n);

    vector<string> zones = {"Zone-1", "Zone-2", "Zone-3", "Zone-4", "Zone-5"};

    // choose ~10 depots
    unordered_set<int> depotIds;
    uniform_int_distribution<int> idDist(0, n - 1);
    while ((int)depotIds.size() < 10) {
        depotIds.insert(idDist(rng));
    }

    uniform_real_distribution<double> areaDist(2.0, 40.0);
    uniform_int_distribution<int> harvestDist(2028, 2055);
    uniform_real_distribution<double> depotPriorityDist(70.0, 95.0);
    uniform_real_distribution<double> noiseDist(0.0, 10.0);

    for (int i = 0; i < n; ++i) {
        Node node;
        node.nodeId = i;
        node.zone = zones[i % (int)zones.size()];

        if (depotIds.count(i)) {
            node.nodeType = "Depot";
            node.blockAreaHa = 0.0;
            node.harvestYear = 0;
            node.priorityScore = depotPriorityDist(rng);
        } else {
            node.nodeType = "Block";
            node.blockAreaHa = round(areaDist(rng) * 100.0) / 100.0;
            node.harvestYear = harvestDist(rng);
            int yearsToHarvest = max(1, node.harvestYear - 2025);
            double base = 80.0 / yearsToHarvest;
            double areaFactor = min(1.5, node.blockAreaHa / 20.0);
            double score = base * areaFactor + noiseDist(rng);
            score = min(100.0, max(0.0, score));
            node.priorityScore = floor(score * 10.0 + 0.5) / 10.0;
        }

        nodes.push_back(node);
    }

    return nodes;
}

vector<Edge> generateEdges(const vector<Node> &nodes,
                           int avgDegree = 6,
                           int seed = 11) {
    mt19937 rng(seed);
    int n = (int)nodes.size();
    vector<Edge> edges;
    edges.reserve(avgDegree * n / 2 + n);

    vector<string> trackTypes = {"Primary", "Secondary", "Trail"};
    vector<double> weights = {0.3, 0.5, 0.2};
    unordered_set<long long> used;

    auto edgeKey = [](int u, int v) -> long long {
        if (u > v) swap(u, v);
        return ( (long long)u << 32 ) ^ (unsigned int)v;
    };

    uniform_real_distribution<double> dist1(0.5, 15.0);
    uniform_real_distribution<double> dist2(0.5, 20.0);
    uniform_real_distribution<double> prob(0.0, 1.0);

    auto pickTrackType = [&](mt19937 &rnd) {
        double r = prob(rnd);
        if (r < weights[0]) return string("Primary");
        if (r < weights[0] + weights[1]) return string("Secondary");
        return string("Trail");
    };

    auto typeFactor = [](const string &t) {
        if (t == "Primary") return 1.0;
        if (t == "Secondary") return 1.3;
        return 1.7;
    };

    // ensure connectivity by linking each node v with a previous node u
    for (int v = 1; v < n; ++v) {
        uniform_int_distribution<int> pickU(0, v - 1);
        int u = pickU(rng);
        double d = dist1(rng);
        string t = pickTrackType(rng);
        double w = d * typeFactor(t);

        Edge e{u, v, d, t, w};
        edges.push_back(e);
        used.insert(edgeKey(u, v));
    }

    int targetEdges = avgDegree * n / 2;
    uniform_int_distribution<int> nodeDist(0, n - 1);

    while ((int)edges.size() < targetEdges) {
        int u = nodeDist(rng);
        int v = nodeDist(rng);
        if (u == v) continue;
        long long k = edgeKey(u, v);
        if (used.count(k)) continue;

        double d = dist2(rng);
        string t = pickTrackType(rng);
        double w = d * typeFactor(t);
        Edge e{u, v, d, t, w};
        edges.push_back(e);
        used.insert(k);
    }

    return edges;
}

// Prim's MST using adjacency list + min-heap. [web:255][web:267]
vector<tuple<int,int,double>> primMST(int n,
                                      const vector<vector<pair<int,double>>> &adj) {
    vector<bool> inMST(n, false);
    vector<tuple<int,int,double>> mstEdges;

    // min-heap on (weight, u, v)
    using T = tuple<double,int,int>;
    priority_queue<T, vector<T>, greater<T>> pq;

    inMST[0] = true;
    for (auto [v, w] : adj[0]) {
        pq.emplace(w, 0, v);
    }

    while (!pq.empty() && (int)mstEdges.size() < n - 1) {
        auto [w, u, v] = pq.top();
        pq.pop();
        if (inMST[v]) continue;
        inMST[v] = true;
        mstEdges.emplace_back(u, v, w);
        for (auto [nxt, wt] : adj[v]) {
            if (!inMST[nxt]) pq.emplace(wt, v, nxt);
        }
    }

    return mstEdges;
}

void exportNodesCSV(const vector<Node> &nodes,
                    const string &filename) {
    ofstream out(filename);
    if (!out) {
        cerr << "Error opening " << filename << "\n";
        return;
    }
    out << "Node_ID,Node_Type,Zone,Block_Area_ha,Harvest_Year,Priority_Score\n";
    out << fixed << setprecision(2);
    for (const auto &n : nodes) {
        out << n.nodeId << ","
            << n.nodeType << ","
            << n.zone << ","
            << n.blockAreaHa << ",";
        out << setprecision(0) << n.harvestYear << ",";
        out << setprecision(1) << n.priorityScore << "\n";
        out << setprecision(2);
    }
}

void exportEdgesCSV(const vector<Edge> &edges,
                    const string &filename) {
    ofstream out(filename);
    if (!out) {
        cerr << "Error opening " << filename << "\n";
        return;
    }
    out << "From_Node,To_Node,Distance_km,Track_Type,Cost_Weight\n";
    out << fixed << setprecision(2);
    for (const auto &e : edges) {
        out << e.u << ","
            << e.v << ","
            << e.distanceKm << ","
            << e.trackType << ",";
        out << setprecision(3) << e.costWeight << "\n";
        out << setprecision(2);
    }
}

void exportMstCSV(const vector<tuple<int,int,double>> &mst,
                  const string &filename) {
    ofstream out(filename);
    if (!out) {
        cerr << "Error opening " << filename << "\n";
        return;
    }
    out << "From_Node,To_Node,MST_Edge_Weight\n";
    out << fixed << setprecision(3);
    for (auto [u, v, w] : mst) {
        out << u << "," << v << "," << w << "\n";
    }
}

int main() {
    cout << "Generating sandalwood access graph with 1000 nodes...\n";
    vector<Node> nodes = generateNodes();
    vector<Edge> edges = generateEdges(nodes);

    int n = (int)nodes.size();
    vector<vector<pair<int,double>>> adj(n);
    for (const auto &e : edges) {
        adj[e.u].push_back({e.v, e.costWeight});
        adj[e.v].push_back({e.u, e.costWeight});
    }

    cout << "Running Prim's MST...\n";
    auto mst = primMST(n, adj);
    cout << "MST edges: " << mst.size() << " (expected " << n - 1 << ")\n";

    exportNodesCSV(nodes, "sandalwood_graph_nodes_1000_cpp.csv");
    exportEdgesCSV(edges, "sandalwood_graph_edges_1000_cpp.csv");
    exportMstCSV(mst, "sandalwood_graph_mst_1000_cpp.csv");

    cout << "Written sandalwood_graph_nodes_1000_cpp.csv, "
         << "sandalwood_graph_edges_1000_cpp.csv, "
         << "sandalwood_graph_mst_1000_cpp.csv\n";

    return 0;
}




</code></pre>
</div> <!-- /sandalwood-graph-code-block -->
</div> <!-- /sandalwood content-box -->
</div>

<script>
function toggleSandalwoodGraphCode() {
  const block = document.getElementById('sandalwood-graph-code-block');
  if (!block) return;
  const current = window.getComputedStyle(block).display;
  block.style.display = (current === 'none') ? 'block' : 'none';
}
</script>
<!--TEAAKAKWOOD-->

<h2 class="section-heading">Teakwood Industry</h2>

<div class="content-box-container">

  <div class="content-box">
    <h3>Teak Rotation Planning (BST)</h3>
    <div class="rule"></div>

    <p>
      Teak plantations are managed as long-rotation assets, with planned thinnings and a final harvest spread over several decades depending on site quality and local guidelines.
      Typical management schedules include early thinnings within the first 5–10 years and subsequent interventions at wider intervals, before the stand reaches its final felling age. 
    </p>

    <p>
      For planning and decision support, each teak block is stored in a <b>Binary Search Tree (BST)</b> keyed by a chosen priority value such as next thinning year, stand density index or composite rotation score.
      Because the BST keeps blocks in sorted order by this key, planners can quickly traverse from the earliest due teak operations to the latest, and insert or remove blocks as management plans change. 
    </p>

    <p>
      In the application, searching the BST allows the system to instantly locate the next teak block due for thinning or final harvest, while an in‑order traversal produces a time‑sorted list of blocks for scheduling.
      This keeps teak scheduling transparent and explorable for field officers, while still being efficient enough to handle hundreds or thousands of plantation blocks across different zones.
    </p>

    <h4>Implementation – Plantation Logic:</h4>
    <div style="text-align:center; margin:20px 0;">
      <img src="Masterplan/teak.jpg"
           alt="Teak Rotation Planning – BST"
           style="width:450px; height:auto; border:2px solid #000;">
    </div>
    <div class="algo-div">Algorithm: BST</div>
    <br><br>

    <!-- Buttons row -->
    <button type="button"
            class="btn btn-success"
            onclick="toggleTeakBSTCode()">
      Code
    </button>

    <a class="btn btn-success text-decoration-none"
       href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/teak_blocks_1000.csv"
       target="_blank">
      Dataset
    </a>

    <!-- TOGGLE TARGET OUTSIDE THE <a> -->
    <div id="teak-bst-code-block" style="display:none; margin-top:20px;">
      <h4>C++ Logic used (BST for Teak Priority)</h4>
      <pre><code>
// teak_bst.cpp
#include &lt;bits/stdc++.h&gt;
using namespace std;

// teak_bst.cpp
#include <bits/stdc++.h>
using namespace std;

struct TeakBlock {
    int blockId;
    string zone;
    string blockType;
    string siteQuality;
    string agroZone;
    string soilClass;
    string slopeClass;
    double areaHa;
    int plantingYear;
    int rotationAge;
    int firstThinningYear;
    int secondThinningYear;
    int finalHarvestYear;
    int treesPerHa;
    double avgDBH_cm;
    double avgHeight_m;
    double stocking_m3_per_ha;
    double heartwoodShare_pct;
    double riskIndex;
    double roadDistance_km;
    double marketDistance_km;
    string nextOperationType;
    int nextOperationYear;
    double priorityScore;
};

// BST node keyed by (priorityScore, blockId)
struct BSTNode {
    TeakBlock data;
    BSTNode *left;
    BSTNode *right;
    BSTNode(const TeakBlock &b) : data(b), left(nullptr), right(nullptr) {}
};

bool lessByKey(const TeakBlock &a, const TeakBlock &b) {
    if (fabs(a.priorityScore - b.priorityScore) > 1e-9)
        return a.priorityScore < b.priorityScore; // smaller score "later"
    return a.blockId < b.blockId;
}

BSTNode* insertNode(BSTNode *root, const TeakBlock &blk) {
    if (!root) return new BSTNode(blk);
    if (lessByKey(blk, root->data)) {
        root->left = insertNode(root->left, blk);
    } else {
        root->right = insertNode(root->right, blk);
    }
    return root;
}

// in-order traversal: lowest priority first
void inorderTraversal(BSTNode *root) {
    if (!root) return;
    inorderTraversal(root->left);
    cout << "Block " << root->data.blockId
         << " priority=" << root->data.priorityScore
         << " nextOp=" << root->data.nextOperationType
         << " year=" << root->data.nextOperationYear << "\n";
    inorderTraversal(root->right);
}

// read the 1000-row CSV and build BST
TeakBlock parseTeakBlock(const vector<string> &cols) {
    TeakBlock b;
    int i = 0;
    b.blockId             = stoi(cols[i++]);
    b.zone                = cols[i++];
    b.blockType           = cols[i++];
    b.siteQuality         = cols[i++];
    b.agroZone            = cols[i++];
    b.soilClass           = cols[i++];
    b.slopeClass          = cols[i++];
    b.areaHa              = stod(cols[i++]);
    b.plantingYear        = stoi(cols[i++]);
    b.rotationAge         = stoi(cols[i++]);
    b.firstThinningYear   = stoi(cols[i++]);
    b.secondThinningYear  = stoi(cols[i++]);
    b.finalHarvestYear    = stoi(cols[i++]);
    b.treesPerHa          = stoi(cols[i++]);
    b.avgDBH_cm           = stod(cols[i++]);
    b.avgHeight_m         = stod(cols[i++]);
    b.stocking_m3_per_ha  = stod(cols[i++]);
    b.heartwoodShare_pct  = stod(cols[i++]);
    b.riskIndex           = stod(cols[i++]);
    b.roadDistance_km     = stod(cols[i++]);
    b.marketDistance_km   = stod(cols[i++]);
    b.nextOperationType   = cols[i++];
    b.nextOperationYear   = stoi(cols[i++]);
    b.priorityScore       = stod(cols[i++]);
    return b;
}

vector<string> splitCSVLine(const string &line) {
    vector<string> out;
    string cur;
    bool inQuotes = false;
    for (char c : line) {
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            out.push_back(cur);
            cur.clear();
        } else {
            cur.push_back(c);
        }
    }
    out.push_back(cur);
    return out;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    ifstream in("teak_blocks_1000.csv");
    if (!in) {
        cerr << "Cannot open teak_blocks_1000.csv\n";
        return 1;
    }

    string line;
    // skip header
    if (!getline(in, line)) {
        cerr << "Empty CSV\n";
        return 1;
    }

    BSTNode *root = nullptr;
    int count = 0;

    while (getline(in, line)) {
        if (line.empty()) continue;
        auto cols = splitCSVLine(line);
        if (cols.size() < 24) continue; // safety
        TeakBlock blk = parseTeakBlock(cols);
        root = insertNode(root, blk);
        ++count;
    }

    cerr << "Loaded " << count << " teak blocks into BST\n";

    // Example: print all blocks in increasing priorityScore
    inorderTraversal(root);

    // TODO: free BST nodes if needed (or rely on OS at program exit)
    return 0;
}

      </code></pre>
    </div>

  </div> <!-- /.content-box -->
</div> <!-- /.content-box-container -->

<script>
  function toggleTeakBSTCode() {
    const block = document.getElementById('teak-bst-code-block');
    if (!block) return;
    const current = window.getComputedStyle(block).display;
    block.style.display = (current === 'none') ? 'block' : 'none';
  }
</script>

  </script>
  <!--Teak wood marketing-->
  <h2 class="section-heading">Teakwood Marketing Network</h2>

<div class="content-box-container">

  <div class="content-box">
    <h3>Lean Marketing Backbone (Kruskal)</h3>
    <div class="rule"></div>

    <p>
      To keep selling costs under control, the teak marketing cell models plantations, intermediate depots and major markets as an undirected, weighted graph where each edge carries the full delivered cost of moving teak between two points.
      Edge weights combine factors such as distance, road condition, loading and unloading charges, and even differential prices for premium versus standard grades in urban markets. 
    </p>

    <p>
      The system then applies <b>Kruskal’s algorithm</b> to this graph to compute a minimum spanning tree, choosing the cheapest combination of trade links that still keeps all plantations connected to at least one key market.
      Using a Union–Find structure, the algorithm sorts all potential links by cost and incrementally adds only those edges that do not create cycles, ensuring that redundant and expensive links are avoided in the core network design. 
    </p>

    <p>
      Planners can visualise this Kruskal-based marketing backbone on the map and decide where to prioritise road upgrades, new depots or additional contracts when demand rises, by selectively adding extra edges on top of the minimum tree.
      This turns teak marketing into a transparent, data-driven optimisation task, where every new route can be compared against the current minimum-cost structure before investment decisions are made. 
    </p>

    <h4>Implementation – Marketing Logic:</h4>
    <div style="text-align:center; margin:20px 0;">
      <img src="Masterplan/kruskal.jpg"
           alt="Teak Marketing Backbone – Kruskal MST"
           style="width:450px; height:auto; border:2px solid #000;">
    </div>

    <div class="algo-div">Algorithm: Kruskal’s MST (Marketing Backbone)</div>
    <br><br>

    <button type="button"
            class="btn btn-success"
            onclick="toggleTeakKruskalCode()">
      Code
    </button>

    <a class="btn btn-success text-decoration-none"
       href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/teak_marketing_edges_kruskal.csv"
       target="_blank">
      Dataset
    </a>

    <div id="teak-kruskal-code-block" style="display:none; margin-top:20px;">
      <h4>C++ Logic used (Kruskal for Teak Marketing)</h4>
      <pre><code>
        // teak_marketing_kruskal.cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        struct Edge {
            int u, v;                 // integer ids of srcNode, dstNode
            string srcNodeLabel;
            string dstNodeLabel;
            string roadType;
            double distanceKm;
            double transportCostPerTonne;
            double handlingCost;
            double tollCost;
            double riskFactor;
            double totalEdgeCost;     // used as weight in Kruskal
            int capacityTonnes;
            string allowedGrade;
            int certifiedOnlyFlag;
        };
        
        struct DSU {
            vector<int> parent, rnk;
            DSU(int n = 0) { init(n); }
            void init(int n) {
                parent.resize(n);
                rnk.assign(n, 0);
                iota(parent.begin(), parent.end(), 0);
            }
            int find(int x) {
                if (parent[x] == x) return x;
                return parent[x] = find(parent[x]);
            }
            bool unite(int a, int b) {
                a = find(a); b = find(b);
                if (a == b) return false;
                if (rnk[a] < rnk[b]) swap(a, b);
                parent[b] = a;
                if (rnk[a] == rnk[b]) rnk[a]++;
                return true;
            }
        };
        
        vector<string> splitCSV(const string &line) {
            vector<string> out;
            string cur;
            bool inQuotes = false;
            for (char c : line) {
                if (c == '"') {
                    inQuotes = !inQuotes;
                } else if (c == ',' && !inQuotes) {
                    out.push_back(cur);
                    cur.clear();
                } else {
                    cur.push_back(c);
                }
            }
            out.push_back(cur);
            return out;
        }
        
        int main() {
            ios::sync_with_stdio(false);
            cin.tie(nullptr);
        
            ifstream in("teak_marketing_edges_kruskal.csv");
            if (!in) {
                cerr << "Cannot open teak_marketing_edges_kruskal.csv\n";
                return 1;
            }
        
            string header;
            if (!getline(in, header)) {
                cerr << "Empty CSV\n";
                return 1;
            }
        
            vector<Edge> edges;
            unordered_map<string,int> nodeId;
            vector<string> idToLabel;
        
            auto getId = [&](const string &label) {
                auto it = nodeId.find(label);
                if (it != nodeId.end()) return it->second;
                int id = (int)nodeId.size();
                nodeId[label] = id;
                idToLabel.push_back(label);
                return id;
            };
        
            string line;
            while (getline(in, line)) {
                if (line.empty()) continue;
                auto cols = splitCSV(line);
                if (cols.size() < 12) continue;
        
                Edge e;
                e.srcNodeLabel          = cols[0];
                e.dstNodeLabel          = cols[1];
                e.roadType              = cols[2];
                e.distanceKm            = stod(cols[3]);
                e.transportCostPerTonne = stod(cols[4]);
                e.handlingCost          = stod(cols[5]);
                e.tollCost              = stod(cols[6]);
                e.riskFactor            = stod(cols[7]);
                e.totalEdgeCost         = stod(cols[8]);
                e.capacityTonnes        = stoi(cols[9]);
                e.allowedGrade          = cols[10];
                e.certifiedOnlyFlag     = stoi(cols[11]);
        
                e.u = getId(e.srcNodeLabel);
                e.v = getId(e.dstNodeLabel);
                edges.push_back(e);
            }
        
            int n = (int)nodeId.size();
            cerr << "Loaded " << edges.size() << " edges over "
                 << n << " nodes\n";
        
            // Kruskal: sort by totalEdgeCost
            sort(edges.begin(), edges.end(),
                 [](const Edge &a, const Edge &b) {
                     return a.totalEdgeCost < b.totalEdgeCost;
                 });
        
            DSU dsu(n);
            vector<Edge> mst;
            double totalCost = 0.0;
        
            for (const auto &e : edges) {
                if (dsu.unite(e.u, e.v)) {
                    mst.push_back(e);
                    totalCost += e.totalEdgeCost;
                    if ((int)mst.size() == n - 1) break;
                }
            }
        
            cout << "Kruskal MST over teak marketing network\n";
            cout << "Nodes: " << n << ", MST edges: " << mst.size()
                 << ", Total cost: " << totalCost << "\n\n";
        
            for (const auto &e : mst) {
                cout << e.srcNodeLabel << " -> " << e.dstNodeLabel
                     << "  cost=" << e.totalEdgeCost
                     << "  road=" << e.roadType
                     << "  cap=" << e.capacityTonnes
                     << "  grade=" << e.allowedGrade
                     << (e.certifiedOnlyFlag ? "  [certified]" : "")
                     << "\n";
            }
        
            return 0;
        }
        
      </code></pre>
    </div>

  </div>
</div>

<script>
  function toggleTeakKruskalCode() {
    const block = document.getElementById('teak-kruskal-code-block');
    if (!block) return;
    const current = window.getComputedStyle(block).display;
    block.style.display = (current === 'none') ? 'block' : 'none';
  }
</script>
<h2 class="section-heading">Administration & Governance</h2>

<div class="content-box-container">

  <div class="content-box">
    <h3>Budgeting & Expenditure Tracking (Persistent Segment Tree)</h3>
    <div class="rule"></div>

    <p>
      Forest finance cells manage multiple schemes at once – from protection and fire management to plantation, CAMPA and climate missions – each releasing funds in tranches across circles, divisions and ranges over many financial years. Administrators must quickly answer questions like how much has been sanctioned versus actually spent under a specific scheme in a division, or how today’s position compares to what it was two budgets ago. 
    </p>

    <p>
      The budgeting module treats each scheme–division–year combination as a position in a timeline array and builds a <b>Persistent Segment Tree</b> over this budget line to support both historical and current queries. Every time a release, re‑appropriation or utilisation certificate is entered, the system creates a new version of the segment tree that shares unchanged nodes with earlier versions, so the full history is preserved without copying entire arrays. 
    </p>

    <p>
      With this structure, administrators can query any version of the tree to see “budget status as of March 2023” or “cumulative expenditure under teak improvement schemes up to the last financial year” in logarithmic time.  Range queries over the tree allow instant roll‑ups from individual ranges to divisions and circles, while still letting officers drill down to find which sub‑offices are lagging in utilisation or overshooting their sanctioned limits. 
    </p>

    <p>
      Because the tree is persistent, audits and reviews can reconstruct the exact financial picture at the moment a decision was taken, rather than only seeing today’s updated totals.  This makes budgeting and expenditure tracking both transparent and defensible, turning complex multi‑year forestry finances into a versioned, queryable history that supports better planning and compliance with national funding guidelines. 
    </p>

    <h4>Implementation – Budget Logic:</h4>
    <div style="text-align:center; margin:20px 0;">
      <img src="Masterplan/budget.jpg"
           alt="Forest Budget Tracking – Persistent Segment Tree"
           style="width:450px; height:auto; border:2px solid #000;">
    </div>

    <div class="algo-div">
      Data Structure: Persistent Segment Tree (Versioned Budget Line)
    </div>
    <br><br>

    <button type="button"
            class="btn btn-success"
            onclick="toggleAdminBudgetCode()">
      Code
    </button>

    <a class="btn btn-success text-decoration-none"
       href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/admin_budget_versions.csv"
       target="_blank">
      Dataset
    </a>

    <div id="admin-budget-code-block" style="display:none; margin-top:20px;">
      <h4>C++ / Python Logic used (Budget Persistent Segment Tree)</h4>
      <pre><code>
        // admin_budget_pst.cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        struct BudgetRecord {
            int versionId;
            string scheme;
            string circle;
            string division;
            string rangeName;
            int financialYear;
            string budgetHead;
            double sanctionedAmountRs;
            double spentAmountRs;
            string lastUpdateRole;
            string lastUpdateDate;
            string utilisationRemark;
        };
        
        // simple CSV splitter
        vector<string> splitCSV(const string &line) {
            vector<string> out;
            string cur;
            bool inQuotes = false;
            for (char c : line) {
                if (c == '"') {
                    inQuotes = !inQuotes;
                } else if (c == ',' && !inQuotes) {
                    out.push_back(cur);
                    cur.clear();
                } else {
                    cur.push_back(c);
                }
            }
            out.push_back(cur);
            return out;
        }
        
        int main() {
            ios::sync_with_stdio(false);
            cin.tie(nullptr);
        
            ifstream in("admin_budget_versions.csv");
            if (!in) {
                cerr << "Cannot open admin_budget_versions.csv\n";
                return 1;
            }
        
            string line;
            if (!getline(in, line)) {
                cerr << "Empty CSV\n";
                return 1;
            }
        
            vector<BudgetRecord> recs;
            while (getline(in, line)) {
                if (line.empty()) continue;
                auto cols = splitCSV(line);
                if (cols.size() < 12) continue;
        
                BudgetRecord r;
                int i = 0;
                r.versionId          = stoi(cols[i++]);
                r.scheme             = cols[i++];
                r.circle             = cols[i++];
                r.division           = cols[i++];
                r.rangeName          = cols[i++];
                r.financialYear      = stoi(cols[i++]);
                r.budgetHead         = cols[i++];
                r.sanctionedAmountRs = stod(cols[i++]);
                r.spentAmountRs      = stod(cols[i++]);
                r.lastUpdateRole     = cols[i++];
                r.lastUpdateDate     = cols[i++];
                r.utilisationRemark  = cols[i++];
        
                recs.push_back(r);
            }
        
            cerr << "Loaded " << recs.size() << " budget records\n";
        
            // Map (scheme, division, year) => array index
            unordered_map<string,int> keyToIndex;
            vector<string> indexToKey;
        
            auto makeKey = [](const string &scheme,
                              const string &division,
                              int year) {
                return scheme + "|" + division + "|" + to_string(year);
            };
        
            for (const auto &r : recs) {
                string key = makeKey(r.scheme, r.division, r.financialYear);
                if (!keyToIndex.count(key)) {
                    int idx = (int)keyToIndex.size();
                    keyToIndex[key] = idx;
                    indexToKey.push_back(key);
                }
            }
        
            int n = (int)keyToIndex.size();
            cerr << "Distinct scheme-division-year slots: " << n << "\n";
        
            // Base array: current spent amount per slot (for latest version only)
            vector<double> base(n, 0.0);
        
            // For demonstration, treat versionId ordering as timeline:
            sort(recs.begin(), recs.end(),
                 [](const BudgetRecord &a, const BudgetRecord &b) {
                     return a.versionId < b.versionId;
                 });
        
            // For each version we could build/keep a root pointer to a persistent segment tree.
            // Here, we just compute base[] as if we applied all versions.
            for (const auto &r : recs) {
                string key = makeKey(r.scheme, r.division, r.financialYear);
                int idx = keyToIndex[key];
                base[idx] = r.spentAmountRs; // latest spent for that slot
            }
        
            // Placeholder: this is where you'd build a persistent segment tree over base[]
            // and then create new versions per update in recs.
            cout << "Ready to build Persistent Segment Tree over " << n
                 << " scheme-division-year slots.\n";
        
            // Example output: print first 10 slots
            for (int i = 0; i < min(n, 10); ++i) {
                cout << i << " : " << indexToKey[i]
                     << " -> spent=" << base[i] << "\n";
            }
        
            return 0;
        }
        
      </code></pre>
    </div>

  </div>
</div>

<script>
  function toggleAdminBudgetCode() {
    const block = document.getElementById('admin-budget-code-block');
    if (!block) return;
    const current = window.getComputedStyle(block).display;
    block.style.display = (current === 'none') ? 'block' : 'none';
  }
</script>
<h2 class="section-heading">Administration & Governance</h2>

<div class="content-box-container">

  <div class="content-box">
    <h3>Rules & Compliance Engine (AVL Tree)</h3>
    <div class="rule"></div>

    <p>
      Forest administration relies on a large and evolving rulebook: working plan prescriptions, government orders, court directions, circulars and scheme guidelines that together decide who can approve which activity, in what quantity and under what conditions. 
      Officers processing permits, payments or offence cases must quickly know which rules apply to a specific range, species, volume and season combination, without manually scanning long PDFs each time. 
    </p>

    <p>
      The rules engine stores every operative clause as a node in an <b>AVL Tree</b>, using a composite key that can combine priority, effective date, jurisdiction and rule code so that the most relevant rules are always found in logarithmic time. 
      Because the AVL tree self‑balances after each insertion or deletion, new circulars or court orders can be added and obsolete rules retired without degrading lookup performance as the rulebase grows. 
    </p>

    <p>
      When a transaction is initiated – such as issuing a transport permit, sanctioning a budget item or compounding an offence – the engine queries the AVL tree with the relevant key to retrieve all active rules that match the case attributes. 
      The matched nodes include thresholds, required approval levels and any special conditions, allowing the system to validate the action in real time and highlight exactly which clause was applied in the decision log. 
    </p>

    <p>
      Version and scope fields in each node let administrators restrict rules to specific periods or locations, and a change log records which AVL operations (insert, rotate, delete) correspond to which notified circulars. 
      This turns the rulebook into an auditable, queryable data structure where governance staff can trace every decision back to a precise rule node, strengthening accountability and consistency across the forest department. 
    </p>

    <h4>Implementation – Rules Logic:</h4>
    <div style="text-align:center; margin:20px 0;">
        <img src="Masterplan/rules.jpg"
           alt="Rules & Compliance Engine – AVL Tree"
           style="width:450px; height:auto; border:2px solid #000;">
    </div>

    <div class="algo-div">
      Data Structure: AVL Tree (Balanced Rule Index)
    </div>
    <br><br>

    <button type="button"
            class="btn btn-success"
            onclick="toggleAdminRulesCode()">
      Code
    </button>

    <a class="btn btn-success text-decoration-none"
       href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/admin_rules_avl.csv"
       target="_blank">
      Dataset
    </a>

    <div id="admin-rules-code-block" style="display:none; margin-top:20px;">
      <h4>C++ Logic used (Rules AVL Tree)</h4>
      <pre><code>
        // admin_rules_avl.cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        struct Rule {
            int ruleId;
            int priorityScore;
            string effectiveFrom;
            string effectiveToOrBlank;
            string jurisdiction;
            string minLevel;
            string maxLevel;
            string domain;
            string actionType;
            double minThreshold;
            double maxThreshold;
            int requiresWrittenOrder;
            int requiresLegalVet;
            string primaryApproverRole;
            string secondaryApproverRole;
            string citationCode;
            string shortTitle;
        };
        
        // composite key for AVL: (priorityScore, effectiveFrom, jurisdiction, citationCode)
        struct Key {
            int priorityScore;
            string effectiveFrom;
            string jurisdiction;
            string citationCode;
        };
        
        bool keyLess(const Key &a, const Key &b) {
            if (a.priorityScore != b.priorityScore)
                return a.priorityScore < b.priorityScore; // lower score = higher priority
            if (a.effectiveFrom != b.effectiveFrom)
                return a.effectiveFrom < b.effectiveFrom;
            if (a.jurisdiction != b.jurisdiction)
                return a.jurisdiction < b.jurisdiction;
            return a.citationCode < b.citationCode;
        }
        
        struct AVLNode {
            Rule rule;
            Key key;
            AVLNode *left;
            AVLNode *right;
            int height;
            AVLNode(const Rule &r, const Key &k)
                : rule(r), key(k), left(nullptr), right(nullptr), height(1) {}
        };
        
        int nodeHeight(AVLNode *n) {
            return n ? n->height : 0;
        }
        
        int balanceFactor(AVLNode *n) {
            return n ? nodeHeight(n->left) - nodeHeight(n->right) : 0;
        }
        
        void updateHeight(AVLNode *n) {
            if (n)
                n->height = 1 + max(nodeHeight(n->left), nodeHeight(n->right));
        }
        
        AVLNode* rotateRight(AVLNode *y) {
            AVLNode *x = y->left;
            AVLNode *T2 = x->right;
        
            x->right = y;
            y->left = T2;
            updateHeight(y);
            updateHeight(x);
            return x;
        }
        
        AVLNode* rotateLeft(AVLNode *x) {
            AVLNode *y = x->right;
            AVLNode *T2 = y->left;
        
            y->left = x;
            x->right = T2;
            updateHeight(x);
            updateHeight(y);
            return y;
        }
        
        AVLNode* insertNode(AVLNode *node, const Rule &r) {
            Key k{r.priorityScore, r.effectiveFrom, r.jurisdiction, r.citationCode};
            if (!node) return new AVLNode(r, k);
        
            if (keyLess(k, node->key)) {
                node->left = insertNode(node->left, r);
            } else {
                node->right = insertNode(node->right, r);
            }
        
            updateHeight(node);
            int bf = balanceFactor(node);
        
            // LL
            if (bf > 1 && keyLess(k, node->left->key))
                return rotateRight(node);
            // RR
            if (bf < -1 && !keyLess(k, node->right->key))
                return rotateLeft(node);
            // LR
            if (bf > 1 && !keyLess(k, node->left->key)) {
                node->left = rotateLeft(node->left);
                return rotateRight(node);
            }
            // RL
            if (bf < -1 && keyLess(k, node->right->key)) {
                node->right = rotateRight(node->right);
                return rotateLeft(node);
            }
            return node;
        }
        
        // Simple CSV splitter
        vector<string> splitCSV(const string &line) {
            vector<string> out;
            string cur;
            bool inQuotes = false;
            for (char c : line) {
                if (c == '"') {
                    inQuotes = !inQuotes;
                } else if (c == ',' && !inQuotes) {
                    out.push_back(cur);
                    cur.clear();
                } else {
                    cur.push_back(c);
                }
            }
            out.push_back(cur);
            return out;
        }
        
        Rule parseRule(const vector<string> &c) {
            Rule r;
            int i = 0;
            r.ruleId               = stoi(c[i++]);
            r.priorityScore        = stoi(c[i++]);
            r.effectiveFrom        = c[i++];
            r.effectiveToOrBlank   = c[i++];
            r.jurisdiction         = c[i++];
            r.minLevel             = c[i++];
            r.maxLevel             = c[i++];
            r.domain               = c[i++];
            r.actionType           = c[i++];
            r.minThreshold         = stod(c[i++]);
            r.maxThreshold         = stod(c[i++]);
            r.requiresWrittenOrder = stoi(c[i++]);
            r.requiresLegalVet     = stoi(c[i++]);
            r.primaryApproverRole  = c[i++];
            r.secondaryApproverRole= c[i++];
            r.citationCode         = c[i++];
            r.shortTitle           = c[i++];
            return r;
        }
        
        void inorderPrint(AVLNode *root, int maxPrint = 20) {
            static int printed = 0;
            if (!root || printed >= maxPrint) return;
            inorderPrint(root->left, maxPrint);
            if (printed < maxPrint) {
                cout << "[" << root->rule.citationCode << "] "
                     << root->rule.shortTitle
                     << " | priority=" << root->rule.priorityScore
                     << " | juris=" << root->rule.jurisdiction
                     << " | domain=" << root->rule.domain
                     << " | action=" << root->rule.actionType
                     << "\n";
                ++printed;
            }
            inorderPrint(root->right, maxPrint);
        }
        
        int main() {
            ios::sync_with_stdio(false);
            cin.tie(nullptr);
        
            ifstream in("admin_rules_avl.csv");
            if (!in) {
                cerr << "Cannot open admin_rules_avl.csv\n";
                return 1;
            }
        
            string line;
            if (!getline(in, line)) {
                cerr << "Empty CSV\n";
                return 1;
            }
        
            AVLNode *root = nullptr;
            int count = 0;
        
            while (getline(in, line)) {
                if (line.empty()) continue;
                auto cols = splitCSV(line);
                if (cols.size() < 17) continue;
                Rule r = parseRule(cols);
                root = insertNode(root, r);
                ++count;
            }
        
            cerr << "Loaded " << count << " rules into AVL tree\n";
        
            cout << "Sample in-order traversal of rules (by priority, effective date, jurisdiction):\n";
            inorderPrint(root, 25);
        
            return 0;
        }
        
      </code></pre>
    </div>

  </div>


<script>
  function toggleAdminRulesCode() {
    const block = document.getElementById('admin-rules-code-block');
    if (!block) return;
    const current = window.getComputedStyle(block).display;
    block.style.display = (current === 'none') ? 'block' : 'none';
  }
</script>
<h2 class="section-heading">Administration & Governance</h2>

<div class="content-box-container">

  <div class="content-box">
    <h3>Time-series Monitoring of Operations (Segment Tree)</h3>
    <div class="rule"></div>

    <p>
      Day-to-day administration generates a continuous stream of dated events: satellite fire alerts, patrol GPS logs, planting completions, nursery dispatches, payment releases and grievance closures across all divisions and ranges. 
      Supervisors need fast answers to questions like how many high-risk fire alerts occurred in the last 7 days in a circle, how many patrols missed their planned beats this month, or which ranges are lagging on plantation milestones. 
    </p>

    <p>
      The monitoring module organises these events on a calendar line and builds a <b>Segment Tree</b> over time, where each leaf corresponds to a day (or week) and each internal node aggregates counts and severity scores for its entire date range. 
      This structure supports efficient range queries and updates, so dashboards can compute metrics such as “fire alerts in the last 30 days” or “patrols completed this quarter” in logarithmic time even when the underlying event log contains years of data. 
    </p>

    <p>
      When new events arrive—like a fresh fire warning, patrol completion or payment entry—the segment tree updates the corresponding leaf and propagates changes up the tree, automatically refreshing all affected aggregates. 
      Administrators can maintain separate trees for different event types (fires, patrols, finance milestones) or combine them into multi-metric nodes, enabling rich visualisations of activity intensity over any chosen period. 
    </p>

    <p>
      This time-series layer also underpins alerting logic: if the sum of high-severity alerts in the past N days in a division exceeds a configured threshold, or if patrol counts fall below a minimum, the system can highlight those divisions in red on the dashboard. 
      By using a segment tree instead of naive scans, the platform keeps these rolling-window checks responsive, even as more years of operational history accumulate in the administrative data lake. 
    </p>

    <h4>Implementation – Monitoring Logic:</h4>
    <div style="text-align:center; margin:20px 0;">
      <img src="Masterplan/think.jpg"
           alt="Time-series Monitoring – Segment Tree"
           style="width:450px; height:auto; border:2px solid #000;">
    </div>

    <div class="algo-div">
      Data Structure: Segment Tree (Time-series Event Aggregation)
    </div>
    <br><br>

    <button type="button"
            class="btn btn-success"
            onclick="toggleAdminMonitoringCode()">
      Code
    </button>

    <a class="btn btn-success text-decoration-none"
       href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/admin_timeseries_events.csv"
       target="_blank">
      Dataset
    </a>

    <div id="admin-monitoring-code-block" style="display:none; margin-top:20px;">
      <h4>C++  Logic used (Time-series Segment Tree)</h4>
      <pre><code>
        // admin_timeseries_segment_tree.cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        struct Event {
            int eventId;
            string dateStr;
            string division;
            string rangeName;
            string eventType;
            string severityLevel;
            int severityScore;
            int durationMinutes;
            double amountRs;
        };
        
        // ---- date helpers (YYYY-MM-DD -> ordinal) ----
        int toOrdinal(const string &s) {
            int y, m, d;
            sscanf(s.c_str(), "%d-%d-%d", &y, &m, &d);
            tm t = {};
            t.tm_year = y - 1900;
            t.tm_mon  = m - 1;
            t.tm_mday = d;
            time_t tt = timegm(&t);
            return (int)(tt / 86400);  // days since epoch
        }
        
        // ---- segment tree for range sum ----
        struct SegTree {
            int n;
            vector<long long> tree;
            SegTree() : n(0) {}
            explicit SegTree(int n_) { init(n_); }
        
            void init(int n_) {
                n = 1;
                while (n < n_) n <<= 1;
                tree.assign(2 * n, 0);
            }
        
            void pointAdd(int idx, long long val) {
                int pos = idx + n;
                tree[pos] += val;
                for (pos >>= 1; pos > 0; pos >>= 1)
                    tree[pos] = tree[pos << 1] + tree[(pos << 1) | 1];
            }
        
            long long rangeSum(int l, int r) { // inclusive l,r
                if (l > r) return 0;
                l += n; r += n;
                long long res = 0;
                while (l <= r) {
                    if (l & 1) res += tree[l++];
                    if (!(r & 1)) res += tree[r--];
                    l >>= 1; r >>= 1;
                }
                return res;
            }
        };
        
        vector<string> splitCSV(const string &line) {
            vector<string> out;
            string cur;
            bool inQuotes = false;
            for (char c : line) {
                if (c == '"') inQuotes = !inQuotes;
                else if (c == ',' && !inQuotes) {
                    out.push_back(cur);
                    cur.clear();
                } else cur.push_back(c);
            }
            out.push_back(cur);
            return out;
        }
        
        int main() {
            ios::sync_with_stdio(false);
            cin.tie(nullptr);
        
            ifstream in("admin_timeseries_events.csv");
            if (!in) {
                cerr << "Cannot open admin_timeseries_events.csv\n";
                return 1;
            }
        
            string line;
            if (!getline(in, line)) {
                cerr << "Empty CSV\n";
                return 1;
            }
        
            vector<Event> events;
            vector<int> ordinals;
        
            while (getline(in, line)) {
                if (line.empty()) continue;
                auto c = splitCSV(line);
                if (c.size() < 9) continue;
        
                Event e;
                int i = 0;
                e.eventId         = stoi(c[i++]);
                e.dateStr         = c[i++];
                e.division        = c[i++];
                e.rangeName       = c[i++];
                e.eventType       = c[i++];
                e.severityLevel   = c[i++];
                e.severityScore   = stoi(c[i++]);
                e.durationMinutes = stoi(c[i++]);
                e.amountRs        = stod(c[i++]);
        
                events.push_back(e);
                ordinals.push_back(toOrdinal(e.dateStr));
            }
        
            if (events.empty()) {
                cerr << "No events\n";
                return 1;
            }
        
            int minOrd = *min_element(ordinals.begin(), ordinals.end());
            int maxOrd = *max_element(ordinals.begin(), ordinals.end());
            int days = maxOrd - minOrd + 1;
        
            SegTree st(days);
        
            for (size_t i = 0; i < events.size(); ++i) {
                int idx = ordinals[i] - minOrd;
                st.pointAdd(idx, events[i].severityScore);
            }
        
            cout << "Built segment tree over " << days
                 << " days, with " << events.size() << " events.\n";
        
            // Example: query last 7 days (relative to maxOrd)
            int last7_start = max(0, days - 7);
            int last7_end   = days - 1;
            long long sevLast7 = st.rangeSum(last7_start, last7_end);
            cout << "Total severityScore in last 7 days: " << sevLast7 << "\n";
        
            return 0;
        }
        
      </code></pre>
    </div>

  </div>
</div>

<script>
  function toggleAdminMonitoringCode() {
    const block = document.getElementById('admin-monitoring-code-block');
    if (!block) return;
    const current = window.getComputedStyle(block).display;
    block.style.display = (current === 'none') ? 'block' : 'none';
  }
</script>
<h2 class="section-heading">Administration & Governance</h2>

<div class="content-box-container">

  <div class="content-box">
    <h3>Knowledge & Document Management (Trie)</h3>
    <div class="rule"></div>

    <p>
      Administration teams work with thousands of documents: working plans, circulars, court orders, office memoranda and scheme guidelines, each tagged by reference number, year, subject and the beats or divisions they apply to. 
      Officers often remember only part of a notification code or a few keywords, yet need to quickly pull up all relevant documents for a case, inspection or audit without scrolling through long folder trees. 
    </p>

    <p>
      The knowledge layer stores all document keys in a <b>Trie (Prefix Tree)</b>, where each path from the root corresponds to a sequence of characters from a reference code or subject tag. 
      As users type a notification number prefix, beat code or topic, the trie follows that prefix down the tree and instantly lists all matching documents under that node, enabling fast autocomplete and filtered search even as the corpus grows. 
    </p>

    <p>
      Each terminal node in the trie carries a small posting list with document IDs, titles, issuing authority and effective period, so that search results can be further refined by date range or jurisdiction. 
      Shared prefixes between related codes are stored only once in the tree, making the index memory‑efficient while still supporting rich, prefix‑based navigation through the rule and knowledge base. 
    </p>

    <p>
      When new circulars are issued or old ones are superseded, the system simply inserts or marks nodes in the trie without rebuilding the entire index, keeping updates lightweight. 
      This turns the document repository into an interactive, data‑structure‑driven library where officers can move from a partial code or phrase to the exact governing document in a few keystrokes, improving consistency and institutional memory. 
    </p>

    <h4>Implementation – Knowledge Logic:</h4>
    <div style="text-align:center; margin:20px 0;">
      <img src="Masterplan/trie.jpg"
           alt="Knowledge & Document Management – Trie Index"
           style="width:450px; height:auto; border:2px solid #000;">
    </div>

    <div class="algo-div">
      Data Structure: Trie (Prefix-based Document Index)
    </div>
    <br><br>

    <button type="button"
            class="btn btn-success"
            onclick="toggleAdminKnowledgeCode()">
      Code
    </button>

    <a class="btn btn-success text-decoration-none"
       href="https://github.com/Ishitha06/city-samarthaka.github.io/blob/main/ananya/Datasets/admin_budget_versions.csv"
       target="_blank">
      Dataset
    </a>

    <div id="admin-knowledge-code-block" style="display:none; margin-top:20px;">
      <h4>C++  Logic used (Document Trie)</h4>
      <pre><code>
        // admin_knowledge_trie.cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        struct Document {
            int documentId;
            string referenceCode;
            string department;
            string category;
            string subject;
            string shortTitle;
            string longTitle;
            int year;
            string issueDate;
            string effectiveToOrBlank;
            string status;
            string jurisdiction;
            int pageCount;
            string tags;
        };
        
        struct TrieNode {
            // map<char, TrieNode*> to support letters, digits, '-'
            unordered_map<char, TrieNode*> child;
            vector<int> docIds;  // documents that end exactly at this code
        };
        
        class Trie {
        public:
            Trie() { root = new TrieNode(); }
        
            void insert(const string &key, int docId) {
                TrieNode *node = root;
                for (char c : key) {
                    if (!node->child.count(c))
                        node->child[c] = new TrieNode();
                    node = node->child[c];
                }
                node->docIds.push_back(docId);
            }
        
            // collect all document IDs under given prefix
            vector<int> collectWithPrefix(const string &prefix) const {
                TrieNode *node = root;
                for (char c : prefix) {
                    auto it = node->child.find(c);
                    if (it == node->child.end()) return {};
                    node = it->second;
                }
                vector<int> result;
                dfs(node, result);
                return result;
            }
        
        private:
            TrieNode *root;
        
            static void dfs(TrieNode *node, vector<int> &out) {
                for (int id : node->docIds) out.push_back(id);
                for (auto &kv : node->child) {
                    dfs(kv.second, out);
                }
            }
        };
        
        vector<string> splitCSV(const string &line) {
            vector<string> out;
            string cur;
            bool inQuotes = false;
            for (char c : line) {
                if (c == '"') inQuotes = !inQuotes;
                else if (c == ',' && !inQuotes) {
                    out.push_back(cur);
                    cur.clear();
                } else cur.push_back(c);
            }
            out.push_back(cur);
            return out;
        }
        
        Document parseDoc(const vector<string> &c) {
            Document d;
            int i = 0;
            d.documentId        = stoi(c[i++]);
            d.referenceCode     = c[i++];
            d.department        = c[i++];
            d.category          = c[i++];
            d.subject           = c[i++];
            d.shortTitle        = c[i++];
            d.longTitle         = c[i++];
            d.year              = stoi(c[i++]);
            d.issueDate         = c[i++];
            d.effectiveToOrBlank= c[i++];
            d.status            = c[i++];
            d.jurisdiction      = c[i++];
            d.pageCount         = stoi(c[i++]);
            d.tags              = c[i++];
            return d;
        }
        
        int main() {
            ios::sync_with_stdio(false);
            cin.tie(nullptr);
        
            ifstream in("admin_documents_trie.csv");
            if (!in) {
                cerr << "Cannot open admin_documents_trie.csv\n";
                return 1;
            }
        
            string line;
            if (!getline(in, line)) {
                cerr << "Empty CSV\n";
                return 1;
            }
        
            vector<Document> docs;
            Trie trie;
        
            while (getline(in, line)) {
                if (line.empty()) continue;
                auto cols = splitCSV(line);
                if (cols.size() < 14) continue;
                Document d = parseDoc(cols);
                docs.push_back(d);
                trie.insert(d.referenceCode, d.documentId);
            }
        
            cerr << "Loaded " << docs.size() << " documents into trie\n";
        
            // Example prefix queries
            string prefix1 = "F-CIR-2023";
            auto ids1 = trie.collectWithPrefix(prefix1);
            cout << "Documents with reference prefix \"" << prefix1 << "\":\n";
            for (int id : ids1) {
                const Document &d = docs[id - 1]; // assuming ids are 1..N continuous
                cout << "  [" << d.referenceCode << "] " << d.shortTitle << "\n";
            }
        
            return 0;
        }
        
      </code></pre>
    </div>

  </div>
</div>

<script>
  function toggleAdminKnowledgeCode() {
    const block = document.getElementById('admin-knowledge-code-block');
    if (!block) return;
    const current = window.getComputedStyle(block).display;
    block.style.display = (current === 'none') ? 'block' : 'none';
  }
</script>







<script src="an.js"></script>

</body>
</html>
